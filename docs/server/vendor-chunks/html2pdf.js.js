"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/html2pdf.js";
exports.ids = ["vendor-chunks/html2pdf.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/html2pdf.js/dist/html2pdf.js":
/*!***************************************************!*\
  !*** ./node_modules/html2pdf.js/dist/html2pdf.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*!\n * html2pdf.js v0.10.3\n * Copyright (c) 2025 Erik Koopmans\n * Released under the MIT License.\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! jspdf */ \"(ssr)/./node_modules/jspdf/dist/jspdf.es.min.js\"), __webpack_require__(/*! html2canvas */ \"(ssr)/./node_modules/html2canvas/dist/html2canvas.esm.js\"));\n    else {}\n})(self, function(__WEBPACK_EXTERNAL_MODULE_jspdf__, __WEBPACK_EXTERNAL_MODULE_html2canvas__) {\n    return /******/ function() {\n        /******/ var __webpack_modules__ = {\n            /***/ \"./src/plugin/hyperlinks.js\": /*!**********************************!*\\\n  !*** ./src/plugin/hyperlinks.js ***!\n  \\**********************************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1035__) {\n                \"use strict\";\n                __nested_webpack_require_1035__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1035__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_1035__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_string_link_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1035__(/*! core-js/modules/es.string.link.js */ \"./node_modules/core-js/modules/es.string.link.js\");\n                /* harmony import */ var core_js_modules_es_string_link_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_1035__.n(core_js_modules_es_string_link_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1035__(/*! ../worker.js */ \"./src/worker.js\");\n                /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1035__(/*! ../utils.js */ \"./src/utils.js\");\n                // Add hyperlink functionality to the PDF creation.\n                // Main link array, and refs to original functions.\n                var linkInfo = [];\n                var orig = {\n                    toContainer: _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toContainer,\n                    toPdf: _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toPdf\n                };\n                _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toContainer = function toContainer() {\n                    return orig.toContainer.call(this).then(function toContainer_hyperlink() {\n                        // Retrieve hyperlink info if the option is enabled.\n                        if (this.opt.enableLinks) {\n                            // Find all anchor tags and get the container's bounds for reference.\n                            var container = this.prop.container;\n                            var links = container.querySelectorAll(\"a\");\n                            var containerRect = (0, _utils_js__WEBPACK_IMPORTED_MODULE_3__.unitConvert)(container.getBoundingClientRect(), this.prop.pageSize.k);\n                            linkInfo = []; // Loop through each anchor tag.\n                            Array.prototype.forEach.call(links, function(link) {\n                                // Treat each client rect as a separate link (for text-wrapping).\n                                var clientRects = link.getClientRects();\n                                for(var i = 0; i < clientRects.length; i++){\n                                    var clientRect = (0, _utils_js__WEBPACK_IMPORTED_MODULE_3__.unitConvert)(clientRects[i], this.prop.pageSize.k);\n                                    clientRect.left -= containerRect.left;\n                                    clientRect.top -= containerRect.top;\n                                    var page = Math.floor(clientRect.top / this.prop.pageSize.inner.height) + 1;\n                                    var top = this.opt.margin[0] + clientRect.top % this.prop.pageSize.inner.height;\n                                    var left = this.opt.margin[1] + clientRect.left;\n                                    linkInfo.push({\n                                        page: page,\n                                        top: top,\n                                        left: left,\n                                        clientRect: clientRect,\n                                        link: link\n                                    });\n                                }\n                            }, this);\n                        }\n                    });\n                };\n                _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toPdf = function toPdf() {\n                    return orig.toPdf.call(this).then(function toPdf_hyperlink() {\n                        // Add hyperlinks if the option is enabled.\n                        if (this.opt.enableLinks) {\n                            // Attach each anchor tag based on info from toContainer().\n                            linkInfo.forEach(function(l) {\n                                this.prop.pdf.setPage(l.page);\n                                this.prop.pdf.link(l.left, l.top, l.clientRect.width, l.clientRect.height, {\n                                    url: l.link.href\n                                });\n                            }, this); // Reset the active page of the PDF to the final page.\n                            var nPages = this.prop.pdf.internal.getNumberOfPages();\n                            this.prop.pdf.setPage(nPages);\n                        }\n                    });\n                };\n            /***/ },\n            /***/ \"./src/plugin/jspdf-plugin.js\": /*!************************************!*\\\n  !*** ./src/plugin/jspdf-plugin.js ***!\n  \\************************************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_6312__) {\n                \"use strict\";\n                __nested_webpack_require_6312__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_6312__(/*! core-js/modules/es.symbol.js */ \"./node_modules/core-js/modules/es.symbol.js\");\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_6312__(/*! core-js/modules/es.symbol.description.js */ \"./node_modules/core-js/modules/es.symbol.description.js\");\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_6312__(/*! core-js/modules/es.object.to-string.js */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_6312__(/*! core-js/modules/es.symbol.iterator.js */ \"./node_modules/core-js/modules/es.symbol.iterator.js\");\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_6312__(/*! core-js/modules/es.array.iterator.js */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_6312__(/*! core-js/modules/es.string.iterator.js */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__);\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_6312__(/*! core-js/modules/web.dom-collections.iterator.js */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__);\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_6312__(/*! jspdf */ \"jspdf\");\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_6312__.n(jspdf__WEBPACK_IMPORTED_MODULE_7__);\n                function _typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        _typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        _typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return _typeof(obj);\n                }\n                // Import dependencies.\n                // Get dimensions of a PDF page, as determined by jsPDF.\n                jspdf__WEBPACK_IMPORTED_MODULE_7__.jsPDF.getPageSize = function(orientation, unit, format) {\n                    // Decode options object\n                    if (_typeof(orientation) === \"object\") {\n                        var options = orientation;\n                        orientation = options.orientation;\n                        unit = options.unit || unit;\n                        format = options.format || format;\n                    } // Default options\n                    unit = unit || \"mm\";\n                    format = format || \"a4\";\n                    orientation = (\"\" + (orientation || \"P\")).toLowerCase();\n                    var format_as_string = (\"\" + format).toLowerCase(); // Size in pt of various paper formats\n                    var pageFormats = {\n                        \"a0\": [\n                            2383.94,\n                            3370.39\n                        ],\n                        \"a1\": [\n                            1683.78,\n                            2383.94\n                        ],\n                        \"a2\": [\n                            1190.55,\n                            1683.78\n                        ],\n                        \"a3\": [\n                            841.89,\n                            1190.55\n                        ],\n                        \"a4\": [\n                            595.28,\n                            841.89\n                        ],\n                        \"a5\": [\n                            419.53,\n                            595.28\n                        ],\n                        \"a6\": [\n                            297.64,\n                            419.53\n                        ],\n                        \"a7\": [\n                            209.76,\n                            297.64\n                        ],\n                        \"a8\": [\n                            147.40,\n                            209.76\n                        ],\n                        \"a9\": [\n                            104.88,\n                            147.40\n                        ],\n                        \"a10\": [\n                            73.70,\n                            104.88\n                        ],\n                        \"b0\": [\n                            2834.65,\n                            4008.19\n                        ],\n                        \"b1\": [\n                            2004.09,\n                            2834.65\n                        ],\n                        \"b2\": [\n                            1417.32,\n                            2004.09\n                        ],\n                        \"b3\": [\n                            1000.63,\n                            1417.32\n                        ],\n                        \"b4\": [\n                            708.66,\n                            1000.63\n                        ],\n                        \"b5\": [\n                            498.90,\n                            708.66\n                        ],\n                        \"b6\": [\n                            354.33,\n                            498.90\n                        ],\n                        \"b7\": [\n                            249.45,\n                            354.33\n                        ],\n                        \"b8\": [\n                            175.75,\n                            249.45\n                        ],\n                        \"b9\": [\n                            124.72,\n                            175.75\n                        ],\n                        \"b10\": [\n                            87.87,\n                            124.72\n                        ],\n                        \"c0\": [\n                            2599.37,\n                            3676.54\n                        ],\n                        \"c1\": [\n                            1836.85,\n                            2599.37\n                        ],\n                        \"c2\": [\n                            1298.27,\n                            1836.85\n                        ],\n                        \"c3\": [\n                            918.43,\n                            1298.27\n                        ],\n                        \"c4\": [\n                            649.13,\n                            918.43\n                        ],\n                        \"c5\": [\n                            459.21,\n                            649.13\n                        ],\n                        \"c6\": [\n                            323.15,\n                            459.21\n                        ],\n                        \"c7\": [\n                            229.61,\n                            323.15\n                        ],\n                        \"c8\": [\n                            161.57,\n                            229.61\n                        ],\n                        \"c9\": [\n                            113.39,\n                            161.57\n                        ],\n                        \"c10\": [\n                            79.37,\n                            113.39\n                        ],\n                        \"dl\": [\n                            311.81,\n                            623.62\n                        ],\n                        \"letter\": [\n                            612,\n                            792\n                        ],\n                        \"government-letter\": [\n                            576,\n                            756\n                        ],\n                        \"legal\": [\n                            612,\n                            1008\n                        ],\n                        \"junior-legal\": [\n                            576,\n                            360\n                        ],\n                        \"ledger\": [\n                            1224,\n                            792\n                        ],\n                        \"tabloid\": [\n                            792,\n                            1224\n                        ],\n                        \"credit-card\": [\n                            153,\n                            243\n                        ]\n                    }; // Unit conversion\n                    switch(unit){\n                        case \"pt\":\n                            var k = 1;\n                            break;\n                        case \"mm\":\n                            var k = 72 / 25.4;\n                            break;\n                        case \"cm\":\n                            var k = 72 / 2.54;\n                            break;\n                        case \"in\":\n                            var k = 72;\n                            break;\n                        case \"px\":\n                            var k = 72 / 96;\n                            break;\n                        case \"pc\":\n                            var k = 12;\n                            break;\n                        case \"em\":\n                            var k = 12;\n                            break;\n                        case \"ex\":\n                            var k = 6;\n                            break;\n                        default:\n                            throw \"Invalid unit: \" + unit;\n                    } // Dimensions are stored as user units and converted to points on output\n                    if (pageFormats.hasOwnProperty(format_as_string)) {\n                        var pageHeight = pageFormats[format_as_string][1] / k;\n                        var pageWidth = pageFormats[format_as_string][0] / k;\n                    } else {\n                        try {\n                            var pageHeight = format[1];\n                            var pageWidth = format[0];\n                        } catch (err) {\n                            throw new Error(\"Invalid format: \" + format);\n                        }\n                    } // Handle page orientation\n                    if (orientation === \"p\" || orientation === \"portrait\") {\n                        orientation = \"p\";\n                        if (pageWidth > pageHeight) {\n                            var tmp = pageWidth;\n                            pageWidth = pageHeight;\n                            pageHeight = tmp;\n                        }\n                    } else if (orientation === \"l\" || orientation === \"landscape\") {\n                        orientation = \"l\";\n                        if (pageHeight > pageWidth) {\n                            var tmp = pageWidth;\n                            pageWidth = pageHeight;\n                            pageHeight = tmp;\n                        }\n                    } else {\n                        throw \"Invalid orientation: \" + orientation;\n                    } // Return information (k is the unit conversion ratio from pts)\n                    var info = {\n                        \"width\": pageWidth,\n                        \"height\": pageHeight,\n                        \"unit\": unit,\n                        \"k\": k\n                    };\n                    return info;\n                };\n                /* harmony default export */ __nested_webpack_exports__[\"default\"] = jspdf__WEBPACK_IMPORTED_MODULE_7__.jsPDF;\n            /***/ },\n            /***/ \"./src/plugin/pagebreaks.js\": /*!**********************************!*\\\n  !*** ./src/plugin/pagebreaks.js ***!\n  \\**********************************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_20111__) {\n                \"use strict\";\n                __nested_webpack_require_20111__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_20111__(/*! core-js/modules/es.array.concat.js */ \"./node_modules/core-js/modules/es.array.concat.js\");\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_20111__(/*! core-js/modules/es.array.slice.js */ \"./node_modules/core-js/modules/es.array.slice.js\");\n                /* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_20111__(/*! core-js/modules/es.array.join.js */ \"./node_modules/core-js/modules/es.array.join.js\");\n                /* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_20111__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_20111__(/*! core-js/modules/es.object.keys.js */ \"./node_modules/core-js/modules/es.object.keys.js\");\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_20111__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_20111__(/*! ../worker.js */ \"./src/worker.js\");\n                /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_20111__(/*! ../utils.js */ \"./src/utils.js\");\n                /* Pagebreak plugin:\n\n    Adds page-break functionality to the html2pdf library. Page-breaks can be\n    enabled by CSS styles, set on individual elements using selectors, or\n    avoided from breaking inside all elements.\n\n    Options on the `opt.pagebreak` object:\n\n    mode:   String or array of strings: 'avoid-all', 'css', and/or 'legacy'\n            Default: ['css', 'legacy']\n\n    before: String or array of CSS selectors for which to add page-breaks\n            before each element. Can be a specific element with an ID\n            ('#myID'), all elements of a type (e.g. 'img'), all of a class\n            ('.myClass'), or even '*' to match every element.\n\n    after:  Like 'before', but adds a page-break immediately after the element.\n\n    avoid:  Like 'before', but avoids page-breaks on these elements. You can\n            enable this feature on every element using the 'avoid-all' mode.\n*/ // Refs to original functions.\n                var orig = {\n                    toContainer: _worker_js__WEBPACK_IMPORTED_MODULE_5__.default.prototype.toContainer\n                }; // Add pagebreak default options to the Worker template.\n                _worker_js__WEBPACK_IMPORTED_MODULE_5__.default.template.opt.pagebreak = {\n                    mode: [\n                        \"css\",\n                        \"legacy\"\n                    ],\n                    before: [],\n                    after: [],\n                    avoid: []\n                };\n                _worker_js__WEBPACK_IMPORTED_MODULE_5__.default.prototype.toContainer = function toContainer() {\n                    return orig.toContainer.call(this).then(function toContainer_pagebreak() {\n                        // Setup root element and inner page height.\n                        var root = this.prop.container;\n                        var pxPageHeight = this.prop.pageSize.inner.px.height; // Check all requested modes.\n                        var modeSrc = [].concat(this.opt.pagebreak.mode);\n                        var mode = {\n                            avoidAll: modeSrc.indexOf(\"avoid-all\") !== -1,\n                            css: modeSrc.indexOf(\"css\") !== -1,\n                            legacy: modeSrc.indexOf(\"legacy\") !== -1\n                        }; // Get arrays of all explicitly requested elements.\n                        var select = {};\n                        var self1 = this;\n                        [\n                            \"before\",\n                            \"after\",\n                            \"avoid\"\n                        ].forEach(function(key) {\n                            var all = mode.avoidAll && key === \"avoid\";\n                            select[key] = all ? [] : [].concat(self1.opt.pagebreak[key] || []);\n                            if (select[key].length > 0) {\n                                select[key] = Array.prototype.slice.call(root.querySelectorAll(select[key].join(\", \")));\n                            }\n                        }); // Get all legacy page-break elements.\n                        var legacyEls = root.querySelectorAll(\".html2pdf__page-break\");\n                        legacyEls = Array.prototype.slice.call(legacyEls); // Loop through all elements.\n                        var els = root.querySelectorAll(\"*\");\n                        Array.prototype.forEach.call(els, function pagebreak_loop(el) {\n                            // Setup pagebreak rules based on legacy and avoidAll modes.\n                            var rules = {\n                                before: false,\n                                after: mode.legacy && legacyEls.indexOf(el) !== -1,\n                                avoid: mode.avoidAll\n                            }; // Add rules for css mode.\n                            if (mode.css) {\n                                // TODO: Check if this is valid with iFrames.\n                                var style = window.getComputedStyle(el); // TODO: Handle 'left' and 'right' correctly.\n                                // TODO: Add support for 'avoid' on breakBefore/After.\n                                var breakOpt = [\n                                    \"always\",\n                                    \"page\",\n                                    \"left\",\n                                    \"right\"\n                                ];\n                                var avoidOpt = [\n                                    \"avoid\",\n                                    \"avoid-page\"\n                                ];\n                                rules = {\n                                    before: rules.before || breakOpt.indexOf(style.breakBefore || style.pageBreakBefore) !== -1,\n                                    after: rules.after || breakOpt.indexOf(style.breakAfter || style.pageBreakAfter) !== -1,\n                                    avoid: rules.avoid || avoidOpt.indexOf(style.breakInside || style.pageBreakInside) !== -1\n                                };\n                            } // Add rules for explicit requests.\n                            Object.keys(rules).forEach(function(key) {\n                                rules[key] = rules[key] || select[key].indexOf(el) !== -1;\n                            }); // Get element position on the screen.\n                            // TODO: Subtract the top of the container from clientRect.top/bottom?\n                            var clientRect = el.getBoundingClientRect(); // Avoid: Check if a break happens mid-element.\n                            if (rules.avoid && !rules.before) {\n                                var startPage = Math.floor(clientRect.top / pxPageHeight);\n                                var endPage = Math.floor(clientRect.bottom / pxPageHeight);\n                                var nPages = Math.abs(clientRect.bottom - clientRect.top) / pxPageHeight; // Turn on rules.before if the el is broken and is at most one page long.\n                                if (endPage !== startPage && nPages <= 1) {\n                                    rules.before = true;\n                                }\n                            } // Before: Create a padding div to push the element to the next page.\n                            if (rules.before) {\n                                var pad = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.createElement)(\"div\", {\n                                    style: {\n                                        display: \"block\",\n                                        height: pxPageHeight - clientRect.top % pxPageHeight + \"px\"\n                                    }\n                                });\n                                el.parentNode.insertBefore(pad, el);\n                            } // After: Create a padding div to fill the remaining page.\n                            if (rules.after) {\n                                var pad = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.createElement)(\"div\", {\n                                    style: {\n                                        display: \"block\",\n                                        height: pxPageHeight - clientRect.bottom % pxPageHeight + \"px\"\n                                    }\n                                });\n                                el.parentNode.insertBefore(pad, el.nextSibling);\n                            }\n                        });\n                    });\n                };\n            /***/ },\n            /***/ \"./src/utils.js\": /*!**********************!*\\\n  !*** ./src/utils.js ***!\n  \\**********************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_30346__) {\n                \"use strict\";\n                __nested_webpack_require_30346__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_30346__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"objType\": function() {\n                        return /* binding */ objType;\n                    },\n                    /* harmony export */ \"createElement\": function() {\n                        return /* binding */ createElement;\n                    },\n                    /* harmony export */ \"cloneNode\": function() {\n                        return /* binding */ cloneNode;\n                    },\n                    /* harmony export */ \"unitConvert\": function() {\n                        return /* binding */ unitConvert;\n                    },\n                    /* harmony export */ \"toPx\": function() {\n                        return /* binding */ toPx;\n                    }\n                });\n                /* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_30346__(/*! core-js/modules/es.number.constructor.js */ \"./node_modules/core-js/modules/es.number.constructor.js\");\n                /* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_30346__(/*! core-js/modules/es.symbol.js */ \"./node_modules/core-js/modules/es.symbol.js\");\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_30346__(/*! core-js/modules/es.symbol.description.js */ \"./node_modules/core-js/modules/es.symbol.description.js\");\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_30346__(/*! core-js/modules/es.object.to-string.js */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_30346__(/*! core-js/modules/es.symbol.iterator.js */ \"./node_modules/core-js/modules/es.symbol.iterator.js\");\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_30346__(/*! core-js/modules/es.array.iterator.js */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__);\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_30346__(/*! core-js/modules/es.string.iterator.js */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_6__);\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_30346__(/*! core-js/modules/web.dom-collections.iterator.js */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_30346__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_7__);\n                function _typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        _typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        _typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return _typeof(obj);\n                }\n                // Determine the type of a variable/object.\n                var objType = function objType(obj) {\n                    var type = _typeof(obj);\n                    if (type === \"undefined\") return \"undefined\";\n                    else if (type === \"string\" || obj instanceof String) return \"string\";\n                    else if (type === \"number\" || obj instanceof Number) return \"number\";\n                    else if (type === \"function\" || obj instanceof Function) return \"function\";\n                    else if (!!obj && obj.constructor === Array) return \"array\";\n                    else if (obj && obj.nodeType === 1) return \"element\";\n                    else if (type === \"object\") return \"object\";\n                    else return \"unknown\";\n                }; // Create an HTML element with optional className, innerHTML, and style.\n                var createElement = function createElement(tagName, opt) {\n                    var el = document.createElement(tagName);\n                    if (opt.className) el.className = opt.className;\n                    if (opt.innerHTML) {\n                        el.innerHTML = opt.innerHTML;\n                        var scripts = el.getElementsByTagName(\"script\");\n                        for(var i = scripts.length; i-- > 0; null){\n                            scripts[i].parentNode.removeChild(scripts[i]);\n                        }\n                    }\n                    for(var key in opt.style){\n                        el.style[key] = opt.style[key];\n                    }\n                    return el;\n                }; // Deep-clone a node and preserve contents/properties.\n                var cloneNode = function cloneNode(node, javascriptEnabled) {\n                    // Recursively clone the node.\n                    var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);\n                    for(var child = node.firstChild; child; child = child.nextSibling){\n                        if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== \"SCRIPT\") {\n                            clone.appendChild(cloneNode(child, javascriptEnabled));\n                        }\n                    }\n                    if (node.nodeType === 1) {\n                        // Preserve contents/properties of special nodes.\n                        if (node.nodeName === \"CANVAS\") {\n                            clone.width = node.width;\n                            clone.height = node.height;\n                            clone.getContext(\"2d\").drawImage(node, 0, 0);\n                        } else if (node.nodeName === \"TEXTAREA\" || node.nodeName === \"SELECT\") {\n                            clone.value = node.value;\n                        } // Preserve the node's scroll position when it loads.\n                        clone.addEventListener(\"load\", function() {\n                            clone.scrollTop = node.scrollTop;\n                            clone.scrollLeft = node.scrollLeft;\n                        }, true);\n                    } // Return the cloned node.\n                    return clone;\n                }; // Convert units from px using the conversion value 'k' from jsPDF.\n                var unitConvert = function unitConvert(obj, k) {\n                    if (objType(obj) === \"number\") {\n                        return obj * 72 / 96 / k;\n                    } else {\n                        var newObj = {};\n                        for(var key in obj){\n                            newObj[key] = obj[key] * 72 / 96 / k;\n                        }\n                        return newObj;\n                    }\n                }; // Convert units to px using the conversion value 'k' from jsPDF.\n                var toPx = function toPx(val, k) {\n                    return Math.floor(val * k / 72 * 96);\n                };\n            /***/ },\n            /***/ \"./src/worker.js\": /*!***********************!*\\\n  !*** ./src/worker.js ***!\n  \\***********************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_39704__) {\n                \"use strict\";\n                __nested_webpack_require_39704__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_39704__(/*! core-js/modules/es.object.assign.js */ \"./node_modules/core-js/modules/es.object.assign.js\");\n                /* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_39704__(/*! core-js/modules/es.array.map.js */ \"./node_modules/core-js/modules/es.array.map.js\");\n                /* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_39704__(/*! core-js/modules/es.object.keys.js */ \"./node_modules/core-js/modules/es.object.keys.js\");\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_39704__(/*! core-js/modules/es.array.concat.js */ \"./node_modules/core-js/modules/es.array.concat.js\");\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_39704__(/*! core-js/modules/es.object.to-string.js */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_39704__(/*! core-js/modules/es.regexp.to-string.js */ \"./node_modules/core-js/modules/es.regexp.to-string.js\");\n                /* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5__);\n                /* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_39704__(/*! core-js/modules/es.function.name.js */ \"./node_modules/core-js/modules/es.function.name.js\");\n                /* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_6__);\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_39704__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7__);\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_39704__(/*! jspdf */ \"jspdf\");\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(jspdf__WEBPACK_IMPORTED_MODULE_8__);\n                /* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_39704__(/*! html2canvas */ \"html2canvas\");\n                /* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(html2canvas__WEBPACK_IMPORTED_MODULE_9__);\n                /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_39704__(/*! ./utils.js */ \"./src/utils.js\");\n                /* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_39704__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\");\n                /* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/ __nested_webpack_require_39704__.n(es6_promise__WEBPACK_IMPORTED_MODULE_11__);\n                var Promise = es6_promise__WEBPACK_IMPORTED_MODULE_11___default().Promise;\n                /* ----- CONSTRUCTOR ----- */ var Worker = function Worker(opt) {\n                    // Create the root parent for the proto chain, and the starting Worker.\n                    var root = Object.assign(Worker.convert(Promise.resolve()), JSON.parse(JSON.stringify(Worker.template)));\n                    var self1 = Worker.convert(Promise.resolve(), root); // Set progress, optional settings, and return.\n                    self1 = self1.setProgress(1, Worker, 1, [\n                        Worker\n                    ]);\n                    self1 = self1.set(opt);\n                    return self1;\n                }; // Boilerplate for subclassing Promise.\n                Worker.prototype = Object.create(Promise.prototype);\n                Worker.prototype.constructor = Worker; // Converts/casts promises into Workers.\n                Worker.convert = function convert(promise, inherit) {\n                    // Uses prototypal inheritance to receive changes made to ancestors' properties.\n                    promise.__proto__ = inherit || Worker.prototype;\n                    return promise;\n                };\n                Worker.template = {\n                    prop: {\n                        src: null,\n                        container: null,\n                        overlay: null,\n                        canvas: null,\n                        img: null,\n                        pdf: null,\n                        pageSize: null\n                    },\n                    progress: {\n                        val: 0,\n                        state: null,\n                        n: 0,\n                        stack: []\n                    },\n                    opt: {\n                        filename: \"file.pdf\",\n                        margin: [\n                            0,\n                            0,\n                            0,\n                            0\n                        ],\n                        image: {\n                            type: \"jpeg\",\n                            quality: 0.95\n                        },\n                        enableLinks: true,\n                        html2canvas: {},\n                        jsPDF: {}\n                    }\n                };\n                /* ----- FROM / TO ----- */ Worker.prototype.from = function from(src, type) {\n                    function getType(src) {\n                        switch((0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.objType)(src)){\n                            case \"string\":\n                                return \"string\";\n                            case \"element\":\n                                return src.nodeName.toLowerCase && src.nodeName.toLowerCase() === \"canvas\" ? \"canvas\" : \"element\";\n                            default:\n                                return \"unknown\";\n                        }\n                    }\n                    return this.then(function from_main() {\n                        type = type || getType(src);\n                        switch(type){\n                            case \"string\":\n                                return this.set({\n                                    src: (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.createElement)(\"div\", {\n                                        innerHTML: src\n                                    })\n                                });\n                            case \"element\":\n                                return this.set({\n                                    src: src\n                                });\n                            case \"canvas\":\n                                return this.set({\n                                    canvas: src\n                                });\n                            case \"img\":\n                                return this.set({\n                                    img: src\n                                });\n                            default:\n                                return this.error(\"Unknown source type.\");\n                        }\n                    });\n                };\n                Worker.prototype.to = function to(target) {\n                    // Route the 'to' request to the appropriate method.\n                    switch(target){\n                        case \"container\":\n                            return this.toContainer();\n                        case \"canvas\":\n                            return this.toCanvas();\n                        case \"img\":\n                            return this.toImg();\n                        case \"pdf\":\n                            return this.toPdf();\n                        default:\n                            return this.error(\"Invalid target.\");\n                    }\n                };\n                Worker.prototype.toContainer = function toContainer() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkSrc() {\n                            return this.prop.src || this.error(\"Cannot duplicate - no source HTML.\");\n                        },\n                        function checkPageSize() {\n                            return this.prop.pageSize || this.setPageSize();\n                        }\n                    ];\n                    return this.thenList(prereqs).then(function toContainer_main() {\n                        // Define the CSS styles for the container and its overlay parent.\n                        var overlayCSS = {\n                            position: \"fixed\",\n                            overflow: \"hidden\",\n                            zIndex: 1000,\n                            left: 0,\n                            right: 0,\n                            bottom: 0,\n                            top: 0,\n                            backgroundColor: \"rgba(0,0,0,0.8)\"\n                        };\n                        var containerCSS = {\n                            position: \"absolute\",\n                            width: this.prop.pageSize.inner.width + this.prop.pageSize.unit,\n                            left: 0,\n                            right: 0,\n                            top: 0,\n                            height: \"auto\",\n                            margin: \"auto\",\n                            backgroundColor: \"white\"\n                        }; // Set the overlay to hidden (could be changed in the future to provide a print preview).\n                        overlayCSS.opacity = 0; // Create and attach the elements.\n                        var source = (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.cloneNode)(this.prop.src, this.opt.html2canvas.javascriptEnabled);\n                        this.prop.overlay = (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.createElement)(\"div\", {\n                            className: \"html2pdf__overlay\",\n                            style: overlayCSS\n                        });\n                        this.prop.container = (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.createElement)(\"div\", {\n                            className: \"html2pdf__container\",\n                            style: containerCSS\n                        });\n                        this.prop.container.appendChild(source);\n                        this.prop.overlay.appendChild(this.prop.container);\n                        document.body.appendChild(this.prop.overlay);\n                    });\n                };\n                Worker.prototype.toCanvas = function toCanvas() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkContainer() {\n                            return document.body.contains(this.prop.container) || this.toContainer();\n                        }\n                    ]; // Fulfill prereqs then create the canvas.\n                    return this.thenList(prereqs).then(function toCanvas_main() {\n                        // Handle old-fashioned 'onrendered' argument.\n                        var options = Object.assign({}, this.opt.html2canvas);\n                        delete options.onrendered;\n                        return html2canvas__WEBPACK_IMPORTED_MODULE_9__(this.prop.container, options);\n                    }).then(function toCanvas_post(canvas) {\n                        // Handle old-fashioned 'onrendered' argument.\n                        var onRendered = this.opt.html2canvas.onrendered || function() {};\n                        onRendered(canvas);\n                        this.prop.canvas = canvas;\n                        document.body.removeChild(this.prop.overlay);\n                    });\n                };\n                Worker.prototype.toImg = function toImg() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkCanvas() {\n                            return this.prop.canvas || this.toCanvas();\n                        }\n                    ]; // Fulfill prereqs then create the image.\n                    return this.thenList(prereqs).then(function toImg_main() {\n                        var imgData = this.prop.canvas.toDataURL(\"image/\" + this.opt.image.type, this.opt.image.quality);\n                        this.prop.img = document.createElement(\"img\");\n                        this.prop.img.src = imgData;\n                    });\n                };\n                Worker.prototype.toPdf = function toPdf() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkCanvas() {\n                            return this.prop.canvas || this.toCanvas();\n                        },\n                        function checkPageSize() {\n                            return this.prop.pageSize || this.setPageSize();\n                        }\n                    ]; // Fulfill prereqs then create the image.\n                    return this.thenList(prereqs).then(function toPdf_main() {\n                        // Create local copies of frequently used properties.\n                        var canvas = this.prop.canvas;\n                        var opt = this.opt; // Calculate the number of pages.\n                        var pxFullHeight = canvas.height;\n                        var pxPageHeight = Math.floor(canvas.width * this.prop.pageSize.inner.ratio);\n                        var nPages = Math.ceil(pxFullHeight / pxPageHeight); // Define pageHeight separately so it can be trimmed on the final page.\n                        var pageHeight = this.prop.pageSize.inner.height; // Create a one-page canvas to split up the full image.\n                        var pageCanvas = document.createElement(\"canvas\");\n                        var pageCtx = pageCanvas.getContext(\"2d\");\n                        pageCanvas.width = canvas.width;\n                        pageCanvas.height = pxPageHeight; // Initialize the PDF.\n                        this.prop.pdf = this.prop.pdf || new jspdf__WEBPACK_IMPORTED_MODULE_8__.jsPDF(opt.jsPDF);\n                        for(var page = 0; page < nPages; page++){\n                            // Trim the final page to reduce file size.\n                            if (page === nPages - 1 && pxFullHeight % pxPageHeight !== 0) {\n                                pageCanvas.height = pxFullHeight % pxPageHeight;\n                                pageHeight = pageCanvas.height * this.prop.pageSize.inner.width / pageCanvas.width;\n                            } // Display the page.\n                            var w = pageCanvas.width;\n                            var h = pageCanvas.height;\n                            pageCtx.fillStyle = \"white\";\n                            pageCtx.fillRect(0, 0, w, h);\n                            pageCtx.drawImage(canvas, 0, page * pxPageHeight, w, h, 0, 0, w, h); // Add the page to the PDF.\n                            if (page) this.prop.pdf.addPage();\n                            var imgData = pageCanvas.toDataURL(\"image/\" + opt.image.type, opt.image.quality);\n                            this.prop.pdf.addImage(imgData, opt.image.type, opt.margin[1], opt.margin[0], this.prop.pageSize.inner.width, pageHeight);\n                        }\n                    });\n                };\n                /* ----- OUTPUT / SAVE ----- */ Worker.prototype.output = function output(type, options, src) {\n                    // Redirect requests to the correct function (outputPdf / outputImg).\n                    src = src || \"pdf\";\n                    if (src.toLowerCase() === \"img\" || src.toLowerCase() === \"image\") {\n                        return this.outputImg(type, options);\n                    } else {\n                        return this.outputPdf(type, options);\n                    }\n                };\n                Worker.prototype.outputPdf = function outputPdf(type, options) {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkPdf() {\n                            return this.prop.pdf || this.toPdf();\n                        }\n                    ]; // Fulfill prereqs then perform the appropriate output.\n                    return this.thenList(prereqs).then(function outputPdf_main() {\n                        /* Currently implemented output types:\n     *    https://rawgit.com/MrRio/jsPDF/master/docs/jspdf.js.html#line992\n     *  save(options), arraybuffer, blob, bloburi/bloburl,\n     *  datauristring/dataurlstring, dataurlnewwindow, datauri/dataurl\n     */ return this.prop.pdf.output(type, options);\n                    });\n                };\n                Worker.prototype.outputImg = function outputImg(type, options) {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkImg() {\n                            return this.prop.img || this.toImg();\n                        }\n                    ]; // Fulfill prereqs then perform the appropriate output.\n                    return this.thenList(prereqs).then(function outputImg_main() {\n                        switch(type){\n                            case undefined:\n                            case \"img\":\n                                return this.prop.img;\n                            case \"datauristring\":\n                            case \"dataurlstring\":\n                                return this.prop.img.src;\n                            case \"datauri\":\n                            case \"dataurl\":\n                                return document.location.href = this.prop.img.src;\n                            default:\n                                throw 'Image output type \"' + type + '\" is not supported.';\n                        }\n                    });\n                };\n                Worker.prototype.save = function save(filename) {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkPdf() {\n                            return this.prop.pdf || this.toPdf();\n                        }\n                    ]; // Fulfill prereqs, update the filename (if provided), and save the PDF.\n                    return this.thenList(prereqs).set(filename ? {\n                        filename: filename\n                    } : null).then(function save_main() {\n                        this.prop.pdf.save(this.opt.filename);\n                    });\n                };\n                /* ----- SET / GET ----- */ Worker.prototype.set = function set(opt) {\n                    // TODO: Implement ordered pairs?\n                    // Silently ignore invalid or empty input.\n                    if ((0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.objType)(opt) !== \"object\") {\n                        return this;\n                    } // Build an array of setter functions to queue.\n                    var fns = Object.keys(opt || {}).map(function(key) {\n                        switch(key){\n                            case \"margin\":\n                                return this.setMargin.bind(this, opt.margin);\n                            case \"jsPDF\":\n                                return function set_jsPDF() {\n                                    this.opt.jsPDF = opt.jsPDF;\n                                    return this.setPageSize();\n                                };\n                            case \"pageSize\":\n                                return this.setPageSize.bind(this, opt.pageSize);\n                            default:\n                                if (key in Worker.template.prop) {\n                                    // Set pre-defined properties in prop.\n                                    return function set_prop() {\n                                        this.prop[key] = opt[key];\n                                    };\n                                } else {\n                                    // Set any other properties in opt.\n                                    return function set_opt() {\n                                        this.opt[key] = opt[key];\n                                    };\n                                }\n                        }\n                    }, this); // Set properties within the promise chain.\n                    return this.then(function set_main() {\n                        return this.thenList(fns);\n                    });\n                };\n                Worker.prototype.get = function get(key, cbk) {\n                    return this.then(function get_main() {\n                        // Fetch the requested property, either as a predefined prop or in opt.\n                        var val = key in Worker.template.prop ? this.prop[key] : this.opt[key];\n                        return cbk ? cbk(val) : val;\n                    });\n                };\n                Worker.prototype.setMargin = function setMargin(margin) {\n                    return this.then(function setMargin_main() {\n                        // Parse the margin property: [top, left, bottom, right].\n                        switch((0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.objType)(margin)){\n                            case \"number\":\n                                margin = [\n                                    margin,\n                                    margin,\n                                    margin,\n                                    margin\n                                ];\n                            case \"array\":\n                                if (margin.length === 2) {\n                                    margin = [\n                                        margin[0],\n                                        margin[1],\n                                        margin[0],\n                                        margin[1]\n                                    ];\n                                }\n                                if (margin.length === 4) {\n                                    break;\n                                }\n                            default:\n                                return this.error(\"Invalid margin array.\");\n                        } // Set the margin property, then update pageSize.\n                        this.opt.margin = margin;\n                    }).then(this.setPageSize);\n                };\n                Worker.prototype.setPageSize = function setPageSize(pageSize) {\n                    return this.then(function setPageSize_main() {\n                        // Retrieve page-size based on jsPDF settings, if not explicitly provided.\n                        pageSize = pageSize || jspdf__WEBPACK_IMPORTED_MODULE_8__.jsPDF.getPageSize(this.opt.jsPDF); // Add 'inner' field if not present.\n                        if (!pageSize.hasOwnProperty(\"inner\")) {\n                            pageSize.inner = {\n                                width: pageSize.width - this.opt.margin[1] - this.opt.margin[3],\n                                height: pageSize.height - this.opt.margin[0] - this.opt.margin[2]\n                            };\n                            pageSize.inner.px = {\n                                width: (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.toPx)(pageSize.inner.width, pageSize.k),\n                                height: (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.toPx)(pageSize.inner.height, pageSize.k)\n                            };\n                            pageSize.inner.ratio = pageSize.inner.height / pageSize.inner.width;\n                        } // Attach pageSize to this.\n                        this.prop.pageSize = pageSize;\n                    });\n                };\n                Worker.prototype.setProgress = function setProgress(val, state, n, stack) {\n                    // Immediately update all progress values.\n                    if (val != null) this.progress.val = val;\n                    if (state != null) this.progress.state = state;\n                    if (n != null) this.progress.n = n;\n                    if (stack != null) this.progress.stack = stack;\n                    this.progress.ratio = this.progress.val / this.progress.state; // Return this for command chaining.\n                    return this;\n                };\n                Worker.prototype.updateProgress = function updateProgress(val, state, n, stack) {\n                    // Immediately update all progress values, using setProgress.\n                    return this.setProgress(val ? this.progress.val + val : null, state ? state : null, n ? this.progress.n + n : null, stack ? this.progress.stack.concat(stack) : null);\n                };\n                /* ----- PROMISE MAPPING ----- */ Worker.prototype.then = function then(onFulfilled, onRejected) {\n                    // Wrap `this` for encapsulation.\n                    var self1 = this;\n                    return this.thenCore(onFulfilled, onRejected, function then_main(onFulfilled, onRejected) {\n                        // Update progress while queuing, calling, and resolving `then`.\n                        self1.updateProgress(null, null, 1, [\n                            onFulfilled\n                        ]);\n                        return Promise.prototype.then.call(this, function then_pre(val) {\n                            self1.updateProgress(null, onFulfilled);\n                            return val;\n                        }).then(onFulfilled, onRejected).then(function then_post(val) {\n                            self1.updateProgress(1);\n                            return val;\n                        });\n                    });\n                };\n                Worker.prototype.thenCore = function thenCore(onFulfilled, onRejected, thenBase) {\n                    // Handle optional thenBase parameter.\n                    thenBase = thenBase || Promise.prototype.then; // Wrap `this` for encapsulation and bind it to the promise handlers.\n                    var self1 = this;\n                    if (onFulfilled) {\n                        onFulfilled = onFulfilled.bind(self1);\n                    }\n                    if (onRejected) {\n                        onRejected = onRejected.bind(self1);\n                    } // Cast self into a Promise to avoid polyfills recursively defining `then`.\n                    var isNative = Promise.toString().indexOf(\"[native code]\") !== -1 && Promise.name === \"Promise\";\n                    var selfPromise = isNative ? self1 : Worker.convert(Object.assign({}, self1), Promise.prototype); // Return the promise, after casting it into a Worker and preserving props.\n                    var returnVal = thenBase.call(selfPromise, onFulfilled, onRejected);\n                    return Worker.convert(returnVal, self1.__proto__);\n                };\n                Worker.prototype.thenExternal = function thenExternal(onFulfilled, onRejected) {\n                    // Call `then` and return a standard promise (exits the Worker chain).\n                    return Promise.prototype.then.call(this, onFulfilled, onRejected);\n                };\n                Worker.prototype.thenList = function thenList(fns) {\n                    // Queue a series of promise 'factories' into the promise chain.\n                    var self1 = this;\n                    fns.forEach(function thenList_forEach(fn) {\n                        self1 = self1.thenCore(fn);\n                    });\n                    return self1;\n                };\n                Worker.prototype[\"catch\"] = function(onRejected) {\n                    // Bind `this` to the promise handler, call `catch`, and return a Worker.\n                    if (onRejected) {\n                        onRejected = onRejected.bind(this);\n                    }\n                    var returnVal = Promise.prototype[\"catch\"].call(this, onRejected);\n                    return Worker.convert(returnVal, this);\n                };\n                Worker.prototype.catchExternal = function catchExternal(onRejected) {\n                    // Call `catch` and return a standard promise (exits the Worker chain).\n                    return Promise.prototype[\"catch\"].call(this, onRejected);\n                };\n                Worker.prototype.error = function error(msg) {\n                    // Throw the error in the Promise chain.\n                    return this.then(function error_main() {\n                        throw new Error(msg);\n                    });\n                };\n                /* ----- ALIASES ----- */ Worker.prototype.using = Worker.prototype.set;\n                Worker.prototype.saveAs = Worker.prototype.save;\n                Worker.prototype.export = Worker.prototype.output;\n                Worker.prototype.run = Worker.prototype.then;\n                /* ----- FINISHING ----- */ // Expose the Worker class.\n                /* harmony default export */ __nested_webpack_exports__[\"default\"] = Worker;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/a-function.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/a-function.js ***!\n  \\******************************************************/ /***/ function(module1) {\n                module1.exports = function(it) {\n                    if (typeof it != \"function\") {\n                        throw TypeError(String(it) + \" is not a function\");\n                    }\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/a-possible-prototype.js\": /*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!\n  \\****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_71246__) {\n                var isObject = __nested_webpack_require_71246__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                module1.exports = function(it) {\n                    if (!isObject(it) && it !== null) {\n                        throw TypeError(\"Can't set \" + String(it) + \" as a prototype\");\n                    }\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/add-to-unscopables.js\": /*!**************************************************************!*\\\n  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!\n  \\**************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_72015__) {\n                var wellKnownSymbol = __nested_webpack_require_72015__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var create = __nested_webpack_require_72015__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var definePropertyModule = __nested_webpack_require_72015__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var UNSCOPABLES = wellKnownSymbol(\"unscopables\");\n                var ArrayPrototype = Array.prototype;\n                // Array.prototype[@@unscopables]\n                // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n                if (ArrayPrototype[UNSCOPABLES] == undefined) {\n                    definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n                        configurable: true,\n                        value: create(null)\n                    });\n                }\n                // add a key to Array.prototype[@@unscopables]\n                module1.exports = function(key) {\n                    ArrayPrototype[UNSCOPABLES][key] = true;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/an-object.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/an-object.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_73521__) {\n                var isObject = __nested_webpack_require_73521__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                module1.exports = function(it) {\n                    if (!isObject(it)) {\n                        throw TypeError(String(it) + \" is not an object\");\n                    }\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-for-each.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-for-each.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_74246__) {\n                \"use strict\";\n                var $forEach = __nested_webpack_require_74246__(/*! ../internals/array-iteration */ \"./node_modules/core-js/internals/array-iteration.js\").forEach;\n                var arrayMethodIsStrict = __nested_webpack_require_74246__(/*! ../internals/array-method-is-strict */ \"./node_modules/core-js/internals/array-method-is-strict.js\");\n                var STRICT_METHOD = arrayMethodIsStrict(\"forEach\");\n                // `Array.prototype.forEach` method implementation\n                // https://tc39.es/ecma262/#sec-array.prototype.foreach\n                module1.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */ ) {\n                    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n                // eslint-disable-next-line es/no-array-prototype-foreach -- safe\n                } : [].forEach;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-includes.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-includes.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_75476__) {\n                var toIndexedObject = __nested_webpack_require_75476__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var toLength = __nested_webpack_require_75476__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var toAbsoluteIndex = __nested_webpack_require_75476__(/*! ../internals/to-absolute-index */ \"./node_modules/core-js/internals/to-absolute-index.js\");\n                // `Array.prototype.{ indexOf, includes }` methods implementation\n                var createMethod = function(IS_INCLUDES) {\n                    return function($this, el, fromIndex) {\n                        var O = toIndexedObject($this);\n                        var length = toLength(O.length);\n                        var index = toAbsoluteIndex(fromIndex, length);\n                        var value;\n                        // Array#includes uses SameValueZero equality algorithm\n                        // eslint-disable-next-line no-self-compare -- NaN check\n                        if (IS_INCLUDES && el != el) while(length > index){\n                            value = O[index++];\n                            // eslint-disable-next-line no-self-compare -- NaN check\n                            if (value != value) return true;\n                        // Array#indexOf ignores holes, Array#includes - not\n                        }\n                        else for(; length > index; index++){\n                            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n                        }\n                        return !IS_INCLUDES && -1;\n                    };\n                };\n                module1.exports = {\n                    // `Array.prototype.includes` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.includes\n                    includes: createMethod(true),\n                    // `Array.prototype.indexOf` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.indexof\n                    indexOf: createMethod(false)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-iteration.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-iteration.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_77945__) {\n                var bind = __nested_webpack_require_77945__(/*! ../internals/function-bind-context */ \"./node_modules/core-js/internals/function-bind-context.js\");\n                var IndexedObject = __nested_webpack_require_77945__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                var toObject = __nested_webpack_require_77945__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var toLength = __nested_webpack_require_77945__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var arraySpeciesCreate = __nested_webpack_require_77945__(/*! ../internals/array-species-create */ \"./node_modules/core-js/internals/array-species-create.js\");\n                var push = [].push;\n                // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\n                var createMethod = function(TYPE) {\n                    var IS_MAP = TYPE == 1;\n                    var IS_FILTER = TYPE == 2;\n                    var IS_SOME = TYPE == 3;\n                    var IS_EVERY = TYPE == 4;\n                    var IS_FIND_INDEX = TYPE == 6;\n                    var IS_FILTER_REJECT = TYPE == 7;\n                    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n                    return function($this, callbackfn, that, specificCreate) {\n                        var O = toObject($this);\n                        var self1 = IndexedObject(O);\n                        var boundFunction = bind(callbackfn, that, 3);\n                        var length = toLength(self1.length);\n                        var index = 0;\n                        var create = specificCreate || arraySpeciesCreate;\n                        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n                        var value, result;\n                        for(; length > index; index++)if (NO_HOLES || index in self1) {\n                            value = self1[index];\n                            result = boundFunction(value, index, O);\n                            if (TYPE) {\n                                if (IS_MAP) target[index] = result; // map\n                                else if (result) switch(TYPE){\n                                    case 3:\n                                        return true; // some\n                                    case 5:\n                                        return value; // find\n                                    case 6:\n                                        return index; // findIndex\n                                    case 2:\n                                        push.call(target, value); // filter\n                                }\n                                else switch(TYPE){\n                                    case 4:\n                                        return false; // every\n                                    case 7:\n                                        push.call(target, value); // filterReject\n                                }\n                            }\n                        }\n                        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n                    };\n                };\n                module1.exports = {\n                    // `Array.prototype.forEach` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.foreach\n                    forEach: createMethod(0),\n                    // `Array.prototype.map` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.map\n                    map: createMethod(1),\n                    // `Array.prototype.filter` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.filter\n                    filter: createMethod(2),\n                    // `Array.prototype.some` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.some\n                    some: createMethod(3),\n                    // `Array.prototype.every` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.every\n                    every: createMethod(4),\n                    // `Array.prototype.find` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.find\n                    find: createMethod(5),\n                    // `Array.prototype.findIndex` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n                    findIndex: createMethod(6),\n                    // `Array.prototype.filterReject` method\n                    // https://github.com/tc39/proposal-array-filtering\n                    filterReject: createMethod(7)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-method-has-species-support.js\": /*!****************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!\n  \\****************************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_83087__) {\n                var fails = __nested_webpack_require_83087__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var wellKnownSymbol = __nested_webpack_require_83087__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var V8_VERSION = __nested_webpack_require_83087__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\n                var SPECIES = wellKnownSymbol(\"species\");\n                module1.exports = function(METHOD_NAME) {\n                    // We can't use this feature detection in V8 since it causes\n                    // deoptimization and serious performance degradation\n                    // https://github.com/zloirock/core-js/issues/677\n                    return V8_VERSION >= 51 || !fails(function() {\n                        var array = [];\n                        var constructor = array.constructor = {};\n                        constructor[SPECIES] = function() {\n                            return {\n                                foo: 1\n                            };\n                        };\n                        return array[METHOD_NAME](Boolean).foo !== 1;\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-method-is-strict.js\": /*!******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-method-is-strict.js ***!\n  \\******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_84720__) {\n                \"use strict\";\n                var fails = __nested_webpack_require_84720__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                module1.exports = function(METHOD_NAME, argument) {\n                    var method = [][METHOD_NAME];\n                    return !!method && fails(function() {\n                        // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing\n                        method.call(null, argument || function() {\n                            throw 1;\n                        }, 1);\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-species-constructor.js\": /*!*********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!\n  \\*********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_85734__) {\n                var isObject = __nested_webpack_require_85734__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isArray = __nested_webpack_require_85734__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var wellKnownSymbol = __nested_webpack_require_85734__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var SPECIES = wellKnownSymbol(\"species\");\n                // a part of `ArraySpeciesCreate` abstract operation\n                // https://tc39.es/ecma262/#sec-arrayspeciescreate\n                module1.exports = function(originalArray) {\n                    var C;\n                    if (isArray(originalArray)) {\n                        C = originalArray.constructor;\n                        // cross-realm fallback\n                        if (typeof C == \"function\" && (C === Array || isArray(C.prototype))) C = undefined;\n                        else if (isObject(C)) {\n                            C = C[SPECIES];\n                            if (C === null) C = undefined;\n                        }\n                    }\n                    return C === undefined ? Array : C;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-species-create.js\": /*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-species-create.js ***!\n  \\****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_87344__) {\n                var arraySpeciesConstructor = __nested_webpack_require_87344__(/*! ../internals/array-species-constructor */ \"./node_modules/core-js/internals/array-species-constructor.js\");\n                // `ArraySpeciesCreate` abstract operation\n                // https://tc39.es/ecma262/#sec-arrayspeciescreate\n                module1.exports = function(originalArray, length) {\n                    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/classof-raw.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof-raw.js ***!\n  \\*******************************************************/ /***/ function(module1) {\n                var toString = {}.toString;\n                module1.exports = function(it) {\n                    return toString.call(it).slice(8, -1);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/classof.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof.js ***!\n  \\***************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_88633__) {\n                var TO_STRING_TAG_SUPPORT = __nested_webpack_require_88633__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\n                var classofRaw = __nested_webpack_require_88633__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                var wellKnownSymbol = __nested_webpack_require_88633__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                // ES3 wrong here\n                var CORRECT_ARGUMENTS = classofRaw(function() {\n                    return arguments;\n                }()) == \"Arguments\";\n                // fallback for IE11 Script Access Denied error\n                var tryGet = function(it, key) {\n                    try {\n                        return it[key];\n                    } catch (error) {}\n                };\n                // getting tag from ES6+ `Object.prototype.toString`\n                module1.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n                    var O, tag, result;\n                    return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && typeof O.callee == \"function\" ? \"Arguments\" : result;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/copy-constructor-properties.js\": /*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!\n  \\***********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_90479__) {\n                var has = __nested_webpack_require_90479__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var ownKeys = __nested_webpack_require_90479__(/*! ../internals/own-keys */ \"./node_modules/core-js/internals/own-keys.js\");\n                var getOwnPropertyDescriptorModule = __nested_webpack_require_90479__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\");\n                var definePropertyModule = __nested_webpack_require_90479__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                module1.exports = function(target, source) {\n                    var keys = ownKeys(source);\n                    var defineProperty = definePropertyModule.f;\n                    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n                    for(var i = 0; i < keys.length; i++){\n                        var key = keys[i];\n                        if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/correct-prototype-getter.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!\n  \\********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_92006__) {\n                var fails = __nested_webpack_require_92006__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                module1.exports = !fails(function() {\n                    function F() {}\n                    F.prototype.constructor = null;\n                    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n                    return Object.getPrototypeOf(new F()) !== F.prototype;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-html.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-html.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_92808__) {\n                var requireObjectCoercible = __nested_webpack_require_92808__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                var toString = __nested_webpack_require_92808__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var quot = /\"/g;\n                // `CreateHTML` abstract operation\n                // https://tc39.es/ecma262/#sec-createhtml\n                module1.exports = function(string, tag, attribute, value) {\n                    var S = toString(requireObjectCoercible(string));\n                    var p1 = \"<\" + tag;\n                    if (attribute !== \"\") p1 += \" \" + attribute + '=\"' + toString(value).replace(quot, \"&quot;\") + '\"';\n                    return p1 + \">\" + S + \"</\" + tag + \">\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-iterator-constructor.js\": /*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!\n  \\***********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_94051__) {\n                \"use strict\";\n                var IteratorPrototype = __nested_webpack_require_94051__(/*! ../internals/iterators-core */ \"./node_modules/core-js/internals/iterators-core.js\").IteratorPrototype;\n                var create = __nested_webpack_require_94051__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var createPropertyDescriptor = __nested_webpack_require_94051__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                var setToStringTag = __nested_webpack_require_94051__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\n                var Iterators = __nested_webpack_require_94051__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n                var returnThis = function() {\n                    return this;\n                };\n                module1.exports = function(IteratorConstructor, NAME, next) {\n                    var TO_STRING_TAG = NAME + \" Iterator\";\n                    IteratorConstructor.prototype = create(IteratorPrototype, {\n                        next: createPropertyDescriptor(1, next)\n                    });\n                    setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n                    Iterators[TO_STRING_TAG] = returnThis;\n                    return IteratorConstructor;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-non-enumerable-property.js\": /*!**************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!\n  \\**************************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_95888__) {\n                var DESCRIPTORS = __nested_webpack_require_95888__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var definePropertyModule = __nested_webpack_require_95888__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var createPropertyDescriptor = __nested_webpack_require_95888__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                module1.exports = DESCRIPTORS ? function(object, key, value) {\n                    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n                } : function(object, key, value) {\n                    object[key] = value;\n                    return object;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-property-descriptor.js\": /*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!\n  \\**********************************************************************/ /***/ function(module1) {\n                module1.exports = function(bitmap, value) {\n                    return {\n                        enumerable: !(bitmap & 1),\n                        configurable: !(bitmap & 2),\n                        writable: !(bitmap & 4),\n                        value: value\n                    };\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-property.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_97741__) {\n                \"use strict\";\n                var toPropertyKey = __nested_webpack_require_97741__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                var definePropertyModule = __nested_webpack_require_97741__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var createPropertyDescriptor = __nested_webpack_require_97741__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                module1.exports = function(object, key, value) {\n                    var propertyKey = toPropertyKey(key);\n                    if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n                    else object[propertyKey] = value;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/define-iterator.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/define-iterator.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_98954__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_98954__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var createIteratorConstructor = __nested_webpack_require_98954__(/*! ../internals/create-iterator-constructor */ \"./node_modules/core-js/internals/create-iterator-constructor.js\");\n                var getPrototypeOf = __nested_webpack_require_98954__(/*! ../internals/object-get-prototype-of */ \"./node_modules/core-js/internals/object-get-prototype-of.js\");\n                var setPrototypeOf = __nested_webpack_require_98954__(/*! ../internals/object-set-prototype-of */ \"./node_modules/core-js/internals/object-set-prototype-of.js\");\n                var setToStringTag = __nested_webpack_require_98954__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_98954__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var redefine = __nested_webpack_require_98954__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var wellKnownSymbol = __nested_webpack_require_98954__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var IS_PURE = __nested_webpack_require_98954__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var Iterators = __nested_webpack_require_98954__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n                var IteratorsCore = __nested_webpack_require_98954__(/*! ../internals/iterators-core */ \"./node_modules/core-js/internals/iterators-core.js\");\n                var IteratorPrototype = IteratorsCore.IteratorPrototype;\n                var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\n                var ITERATOR = wellKnownSymbol(\"iterator\");\n                var KEYS = \"keys\";\n                var VALUES = \"values\";\n                var ENTRIES = \"entries\";\n                var returnThis = function() {\n                    return this;\n                };\n                module1.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n                    createIteratorConstructor(IteratorConstructor, NAME, next);\n                    var getIterationMethod = function(KIND) {\n                        if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n                        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n                        switch(KIND){\n                            case KEYS:\n                                return function keys() {\n                                    return new IteratorConstructor(this, KIND);\n                                };\n                            case VALUES:\n                                return function values() {\n                                    return new IteratorConstructor(this, KIND);\n                                };\n                            case ENTRIES:\n                                return function entries() {\n                                    return new IteratorConstructor(this, KIND);\n                                };\n                        }\n                        return function() {\n                            return new IteratorConstructor(this);\n                        };\n                    };\n                    var TO_STRING_TAG = NAME + \" Iterator\";\n                    var INCORRECT_VALUES_NAME = false;\n                    var IterablePrototype = Iterable.prototype;\n                    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n                    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n                    var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n                    var CurrentIteratorPrototype, methods, KEY;\n                    // fix native\n                    if (anyNativeIterator) {\n                        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n                        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n                            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n                                if (setPrototypeOf) {\n                                    setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n                                } else if (typeof CurrentIteratorPrototype[ITERATOR] != \"function\") {\n                                    createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\n                                }\n                            }\n                            // Set @@toStringTag to native iterators\n                            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n                            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n                        }\n                    }\n                    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n                    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n                        INCORRECT_VALUES_NAME = true;\n                        defaultIterator = function values() {\n                            return nativeIterator.call(this);\n                        };\n                    }\n                    // define iterator\n                    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n                        createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\n                    }\n                    Iterators[NAME] = defaultIterator;\n                    // export additional methods\n                    if (DEFAULT) {\n                        methods = {\n                            values: getIterationMethod(VALUES),\n                            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n                            entries: getIterationMethod(ENTRIES)\n                        };\n                        if (FORCED) for(KEY in methods){\n                            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n                                redefine(IterablePrototype, KEY, methods[KEY]);\n                            }\n                        }\n                        else $({\n                            target: NAME,\n                            proto: true,\n                            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n                        }, methods);\n                    }\n                    return methods;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/define-well-known-symbol.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!\n  \\********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_106255__) {\n                var path = __nested_webpack_require_106255__(/*! ../internals/path */ \"./node_modules/core-js/internals/path.js\");\n                var has = __nested_webpack_require_106255__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var wrappedWellKnownSymbolModule = __nested_webpack_require_106255__(/*! ../internals/well-known-symbol-wrapped */ \"./node_modules/core-js/internals/well-known-symbol-wrapped.js\");\n                var defineProperty = __nested_webpack_require_106255__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                module1.exports = function(NAME) {\n                    var Symbol1 = path.Symbol || (path.Symbol = {});\n                    if (!has(Symbol1, NAME)) defineProperty(Symbol1, NAME, {\n                        value: wrappedWellKnownSymbolModule.f(NAME)\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/descriptors.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/descriptors.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_107487__) {\n                var fails = __nested_webpack_require_107487__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                // Detect IE8's incomplete defineProperty implementation\n                module1.exports = !fails(function() {\n                    // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n                    return Object.defineProperty({}, 1, {\n                        get: function() {\n                            return 7;\n                        }\n                    })[1] != 7;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/document-create-element.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/document-create-element.js ***!\n  \\*******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_108443__) {\n                var global1 = __nested_webpack_require_108443__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var isObject = __nested_webpack_require_108443__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var document1 = global1.document;\n                // typeof document.createElement is 'object' in old IE\n                var EXISTS = isObject(document1) && isObject(document1.createElement);\n                module1.exports = function(it) {\n                    return EXISTS ? document1.createElement(it) : {};\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/dom-iterables.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/dom-iterables.js ***!\n  \\*********************************************************/ /***/ function(module1) {\n                // iterable DOM collections\n                // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\n                module1.exports = {\n                    CSSRuleList: 0,\n                    CSSStyleDeclaration: 0,\n                    CSSValueList: 0,\n                    ClientRectList: 0,\n                    DOMRectList: 0,\n                    DOMStringList: 0,\n                    DOMTokenList: 1,\n                    DataTransferItemList: 0,\n                    FileList: 0,\n                    HTMLAllCollection: 0,\n                    HTMLCollection: 0,\n                    HTMLFormElement: 0,\n                    HTMLSelectElement: 0,\n                    MediaList: 0,\n                    MimeTypeArray: 0,\n                    NamedNodeMap: 0,\n                    NodeList: 1,\n                    PaintRequestList: 0,\n                    Plugin: 0,\n                    PluginArray: 0,\n                    SVGLengthList: 0,\n                    SVGNumberList: 0,\n                    SVGPathSegList: 0,\n                    SVGPointList: 0,\n                    SVGStringList: 0,\n                    SVGTransformList: 0,\n                    SourceBufferList: 0,\n                    StyleSheetList: 0,\n                    TextTrackCueList: 0,\n                    TextTrackList: 0,\n                    TouchList: 0\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/engine-user-agent.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_111095__) {\n                var getBuiltIn = __nested_webpack_require_111095__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                module1.exports = getBuiltIn(\"navigator\", \"userAgent\") || \"\";\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/engine-v8-version.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_111681__) {\n                var global1 = __nested_webpack_require_111681__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var userAgent = __nested_webpack_require_111681__(/*! ../internals/engine-user-agent */ \"./node_modules/core-js/internals/engine-user-agent.js\");\n                var process1 = global1.process;\n                var Deno = global1.Deno;\n                var versions = process1 && process1.versions || Deno && Deno.version;\n                var v8 = versions && versions.v8;\n                var match, version;\n                if (v8) {\n                    match = v8.split(\".\");\n                    version = match[0] < 4 ? 1 : match[0] + match[1];\n                } else if (userAgent) {\n                    match = userAgent.match(/Edge\\/(\\d+)/);\n                    if (!match || match[1] >= 74) {\n                        match = userAgent.match(/Chrome\\/(\\d+)/);\n                        if (match) version = match[1];\n                    }\n                }\n                module1.exports = version && +version;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/enum-bug-keys.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!\n  \\*********************************************************/ /***/ function(module1) {\n                // IE8- don't enum bug keys\n                module1.exports = [\n                    \"constructor\",\n                    \"hasOwnProperty\",\n                    \"isPrototypeOf\",\n                    \"propertyIsEnumerable\",\n                    \"toLocaleString\",\n                    \"toString\",\n                    \"valueOf\"\n                ];\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/export.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/export.js ***!\n  \\**************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_113705__) {\n                var global1 = __nested_webpack_require_113705__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var getOwnPropertyDescriptor = __nested_webpack_require_113705__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\").f;\n                var createNonEnumerableProperty = __nested_webpack_require_113705__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var redefine = __nested_webpack_require_113705__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var setGlobal = __nested_webpack_require_113705__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\n                var copyConstructorProperties = __nested_webpack_require_113705__(/*! ../internals/copy-constructor-properties */ \"./node_modules/core-js/internals/copy-constructor-properties.js\");\n                var isForced = __nested_webpack_require_113705__(/*! ../internals/is-forced */ \"./node_modules/core-js/internals/is-forced.js\");\n                /*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/ module1.exports = function(options, source) {\n                    var TARGET = options.target;\n                    var GLOBAL = options.global;\n                    var STATIC = options.stat;\n                    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n                    if (GLOBAL) {\n                        target = global1;\n                    } else if (STATIC) {\n                        target = global1[TARGET] || setGlobal(TARGET, {});\n                    } else {\n                        target = (global1[TARGET] || {}).prototype;\n                    }\n                    if (target) for(key in source){\n                        sourceProperty = source[key];\n                        if (options.noTargetGet) {\n                            descriptor = getOwnPropertyDescriptor(target, key);\n                            targetProperty = descriptor && descriptor.value;\n                        } else targetProperty = target[key];\n                        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n                        // contained in target\n                        if (!FORCED && targetProperty !== undefined) {\n                            if (typeof sourceProperty === typeof targetProperty) continue;\n                            copyConstructorProperties(sourceProperty, targetProperty);\n                        }\n                        // add a flag to not completely full polyfills\n                        if (options.sham || targetProperty && targetProperty.sham) {\n                            createNonEnumerableProperty(sourceProperty, \"sham\", true);\n                        }\n                        // extend global\n                        redefine(target, key, sourceProperty, options);\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/fails.js\": /*!*************************************************!*\\\n  !*** ./node_modules/core-js/internals/fails.js ***!\n  \\*************************************************/ /***/ function(module1) {\n                module1.exports = function(exec) {\n                    try {\n                        return !!exec();\n                    } catch (error) {\n                        return true;\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/function-bind-context.js\": /*!*****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/function-bind-context.js ***!\n  \\*****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_118366__) {\n                var aFunction = __nested_webpack_require_118366__(/*! ../internals/a-function */ \"./node_modules/core-js/internals/a-function.js\");\n                // optional / simple context binding\n                module1.exports = function(fn, that, length) {\n                    aFunction(fn);\n                    if (that === undefined) return fn;\n                    switch(length){\n                        case 0:\n                            return function() {\n                                return fn.call(that);\n                            };\n                        case 1:\n                            return function(a) {\n                                return fn.call(that, a);\n                            };\n                        case 2:\n                            return function(a, b) {\n                                return fn.call(that, a, b);\n                            };\n                        case 3:\n                            return function(a, b, c) {\n                                return fn.call(that, a, b, c);\n                            };\n                    }\n                    return function() {\n                        return fn.apply(that, arguments);\n                    };\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/get-built-in.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/get-built-in.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_119943__) {\n                var global1 = __nested_webpack_require_119943__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var aFunction = function(variable) {\n                    return typeof variable == \"function\" ? variable : undefined;\n                };\n                module1.exports = function(namespace, method) {\n                    return arguments.length < 2 ? aFunction(global1[namespace]) : global1[namespace] && global1[namespace][method];\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/global.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/global.js ***!\n  \\**************************************************/ /***/ function(module1) {\n                var check = function(it) {\n                    return it && it.Math == Math && it;\n                };\n                // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n                module1.exports = // eslint-disable-next-line es/no-global-this -- safe\n                check(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\n                check(typeof self == \"object\" && self) || check(typeof global == \"object\" && global) || // eslint-disable-next-line no-new-func -- fallback\n                function() {\n                    return this;\n                }() || Function(\"return this\")();\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/has.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/has.js ***!\n  \\***********************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_121760__) {\n                var toObject = __nested_webpack_require_121760__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var hasOwnProperty = {}.hasOwnProperty;\n                module1.exports = Object.hasOwn || function hasOwn(it, key) {\n                    return hasOwnProperty.call(toObject(it), key);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/hidden-keys.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/hidden-keys.js ***!\n  \\*******************************************************/ /***/ function(module1) {\n                module1.exports = {};\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/html.js\": /*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/html.js ***!\n  \\************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_122764__) {\n                var getBuiltIn = __nested_webpack_require_122764__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                module1.exports = getBuiltIn(\"document\", \"documentElement\");\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/ie8-dom-define.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_123337__) {\n                var DESCRIPTORS = __nested_webpack_require_123337__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var fails = __nested_webpack_require_123337__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var createElement = __nested_webpack_require_123337__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\n                // Thank's IE8 for his funny defineProperty\n                module1.exports = !DESCRIPTORS && !fails(function() {\n                    // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n                    return Object.defineProperty(createElement(\"div\"), \"a\", {\n                        get: function() {\n                            return 7;\n                        }\n                    }).a != 7;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/indexed-object.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/indexed-object.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_124580__) {\n                var fails = __nested_webpack_require_124580__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var classof = __nested_webpack_require_124580__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                var split = \"\".split;\n                // fallback for non-array-like ES3 and non-enumerable old V8 strings\n                module1.exports = fails(function() {\n                    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n                    // eslint-disable-next-line no-prototype-builtins -- safe\n                    return !Object(\"z\").propertyIsEnumerable(0);\n                }) ? function(it) {\n                    return classof(it) == \"String\" ? split.call(it, \"\") : Object(it);\n                } : Object;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/inherit-if-required.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!\n  \\***************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_125777__) {\n                var isObject = __nested_webpack_require_125777__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var setPrototypeOf = __nested_webpack_require_125777__(/*! ../internals/object-set-prototype-of */ \"./node_modules/core-js/internals/object-set-prototype-of.js\");\n                // makes subclassing work correct for wrapped built-ins\n                module1.exports = function($this, dummy, Wrapper) {\n                    var NewTarget, NewTargetPrototype;\n                    if (// it can work only with native `setPrototypeOf`\n                    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n                    typeof (NewTarget = dummy.constructor) == \"function\" && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);\n                    return $this;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/inspect-source.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/inspect-source.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_127112__) {\n                var store = __nested_webpack_require_127112__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n                var functionToString = Function.toString;\n                // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\n                if (typeof store.inspectSource != \"function\") {\n                    store.inspectSource = function(it) {\n                        return functionToString.call(it);\n                    };\n                }\n                module1.exports = store.inspectSource;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/internal-state.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/internal-state.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_128032__) {\n                var NATIVE_WEAK_MAP = __nested_webpack_require_128032__(/*! ../internals/native-weak-map */ \"./node_modules/core-js/internals/native-weak-map.js\");\n                var global1 = __nested_webpack_require_128032__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var isObject = __nested_webpack_require_128032__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_128032__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var objectHas = __nested_webpack_require_128032__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var shared = __nested_webpack_require_128032__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n                var sharedKey = __nested_webpack_require_128032__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var hiddenKeys = __nested_webpack_require_128032__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                var OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\n                var WeakMap = global1.WeakMap;\n                var set, get, has;\n                var enforce = function(it) {\n                    return has(it) ? get(it) : set(it, {});\n                };\n                var getterFor = function(TYPE) {\n                    return function(it) {\n                        var state;\n                        if (!isObject(it) || (state = get(it)).type !== TYPE) {\n                            throw TypeError(\"Incompatible receiver, \" + TYPE + \" required\");\n                        }\n                        return state;\n                    };\n                };\n                if (NATIVE_WEAK_MAP || shared.state) {\n                    var store = shared.state || (shared.state = new WeakMap());\n                    var wmget = store.get;\n                    var wmhas = store.has;\n                    var wmset = store.set;\n                    set = function(it, metadata) {\n                        if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n                        metadata.facade = it;\n                        wmset.call(store, it, metadata);\n                        return metadata;\n                    };\n                    get = function(it) {\n                        return wmget.call(store, it) || {};\n                    };\n                    has = function(it) {\n                        return wmhas.call(store, it);\n                    };\n                } else {\n                    var STATE = sharedKey(\"state\");\n                    hiddenKeys[STATE] = true;\n                    set = function(it, metadata) {\n                        if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n                        metadata.facade = it;\n                        createNonEnumerableProperty(it, STATE, metadata);\n                        return metadata;\n                    };\n                    get = function(it) {\n                        return objectHas(it, STATE) ? it[STATE] : {};\n                    };\n                    has = function(it) {\n                        return objectHas(it, STATE);\n                    };\n                }\n                module1.exports = {\n                    set: set,\n                    get: get,\n                    has: has,\n                    enforce: enforce,\n                    getterFor: getterFor\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-array.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-array.js ***!\n  \\****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_131952__) {\n                var classof = __nested_webpack_require_131952__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                // `IsArray` abstract operation\n                // https://tc39.es/ecma262/#sec-isarray\n                // eslint-disable-next-line es/no-array-isarray -- safe\n                module1.exports = Array.isArray || function isArray(arg) {\n                    return classof(arg) == \"Array\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-forced.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-forced.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_132745__) {\n                var fails = __nested_webpack_require_132745__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var replacement = /#|\\.prototype\\./;\n                var isForced = function(feature, detection) {\n                    var value = data[normalize(feature)];\n                    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == \"function\" ? fails(detection) : !!detection;\n                };\n                var normalize = isForced.normalize = function(string) {\n                    return String(string).replace(replacement, \".\").toLowerCase();\n                };\n                var data = isForced.data = {};\n                var NATIVE = isForced.NATIVE = \"N\";\n                var POLYFILL = isForced.POLYFILL = \"P\";\n                module1.exports = isForced;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-object.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-object.js ***!\n  \\*****************************************************/ /***/ function(module1) {\n                module1.exports = function(it) {\n                    return typeof it === \"object\" ? it !== null : typeof it === \"function\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-pure.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-pure.js ***!\n  \\***************************************************/ /***/ function(module1) {\n                module1.exports = false;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-symbol.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-symbol.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_134685__) {\n                var getBuiltIn = __nested_webpack_require_134685__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                var USE_SYMBOL_AS_UID = __nested_webpack_require_134685__(/*! ../internals/use-symbol-as-uid */ \"./node_modules/core-js/internals/use-symbol-as-uid.js\");\n                module1.exports = USE_SYMBOL_AS_UID ? function(it) {\n                    return typeof it == \"symbol\";\n                } : function(it) {\n                    var $Symbol = getBuiltIn(\"Symbol\");\n                    return typeof $Symbol == \"function\" && Object(it) instanceof $Symbol;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/iterators-core.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators-core.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_135656__) {\n                \"use strict\";\n                var fails = __nested_webpack_require_135656__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var getPrototypeOf = __nested_webpack_require_135656__(/*! ../internals/object-get-prototype-of */ \"./node_modules/core-js/internals/object-get-prototype-of.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_135656__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var has = __nested_webpack_require_135656__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var wellKnownSymbol = __nested_webpack_require_135656__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var IS_PURE = __nested_webpack_require_135656__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var ITERATOR = wellKnownSymbol(\"iterator\");\n                var BUGGY_SAFARI_ITERATORS = false;\n                var returnThis = function() {\n                    return this;\n                };\n                // `%IteratorPrototype%` object\n                // https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n                var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n                /* eslint-disable es/no-array-prototype-keys -- safe */ if ([].keys) {\n                    arrayIterator = [].keys();\n                    // Safari 8 has buggy iterators w/o `next`\n                    if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n                    else {\n                        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n                        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n                    }\n                }\n                var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function() {\n                    var test = {};\n                    // FF44- legacy iterators case\n                    return IteratorPrototype[ITERATOR].call(test) !== test;\n                });\n                if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n                // `%IteratorPrototype%[@@iterator]()` method\n                // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\n                if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {\n                    createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n                }\n                module1.exports = {\n                    IteratorPrototype: IteratorPrototype,\n                    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/iterators.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators.js ***!\n  \\*****************************************************/ /***/ function(module1) {\n                module1.exports = {};\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/native-symbol.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-symbol.js ***!\n  \\*********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_139127__) {\n                /* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = __nested_webpack_require_139127__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\n                var fails = __nested_webpack_require_139127__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\n                module1.exports = !!Object.getOwnPropertySymbols && !fails(function() {\n                    var symbol = Symbol();\n                    // Chrome 38 Symbol has incorrect toString conversion\n                    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n                    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n                    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/native-weak-map.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-weak-map.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_140494__) {\n                var global1 = __nested_webpack_require_140494__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var inspectSource = __nested_webpack_require_140494__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\n                var WeakMap = global1.WeakMap;\n                module1.exports = typeof WeakMap === \"function\" && /native code/.test(inspectSource(WeakMap));\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-assign.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-assign.js ***!\n  \\*********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_141275__) {\n                \"use strict\";\n                var DESCRIPTORS = __nested_webpack_require_141275__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var fails = __nested_webpack_require_141275__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var objectKeys = __nested_webpack_require_141275__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                var getOwnPropertySymbolsModule = __nested_webpack_require_141275__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\n                var propertyIsEnumerableModule = __nested_webpack_require_141275__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\n                var toObject = __nested_webpack_require_141275__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var IndexedObject = __nested_webpack_require_141275__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                // eslint-disable-next-line es/no-object-assign -- safe\n                var $assign = Object.assign;\n                // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n                var defineProperty = Object.defineProperty;\n                // `Object.assign` method\n                // https://tc39.es/ecma262/#sec-object.assign\n                module1.exports = !$assign || fails(function() {\n                    // should have correct order of operations (Edge bug)\n                    if (DESCRIPTORS && $assign({\n                        b: 1\n                    }, $assign(defineProperty({}, \"a\", {\n                        enumerable: true,\n                        get: function() {\n                            defineProperty(this, \"b\", {\n                                value: 3,\n                                enumerable: false\n                            });\n                        }\n                    }), {\n                        b: 2\n                    })).b !== 1) return true;\n                    // should work with symbols and should have deterministic property order (V8 bug)\n                    var A = {};\n                    var B = {};\n                    // eslint-disable-next-line es/no-symbol -- safe\n                    var symbol = Symbol();\n                    var alphabet = \"abcdefghijklmnopqrst\";\n                    A[symbol] = 7;\n                    alphabet.split(\"\").forEach(function(chr) {\n                        B[chr] = chr;\n                    });\n                    return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join(\"\") != alphabet;\n                }) ? function assign(target, source) {\n                    var T = toObject(target);\n                    var argumentsLength = arguments.length;\n                    var index = 1;\n                    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n                    var propertyIsEnumerable = propertyIsEnumerableModule.f;\n                    while(argumentsLength > index){\n                        var S = IndexedObject(arguments[index++]);\n                        var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n                        var length = keys.length;\n                        var j = 0;\n                        var key;\n                        while(length > j){\n                            key = keys[j++];\n                            if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n                        }\n                    }\n                    return T;\n                } : $assign;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-create.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-create.js ***!\n  \\*********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_145366__) {\n                /* global ActiveXObject -- old IE, WSH */ var anObject = __nested_webpack_require_145366__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var defineProperties = __nested_webpack_require_145366__(/*! ../internals/object-define-properties */ \"./node_modules/core-js/internals/object-define-properties.js\");\n                var enumBugKeys = __nested_webpack_require_145366__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n                var hiddenKeys = __nested_webpack_require_145366__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                var html = __nested_webpack_require_145366__(/*! ../internals/html */ \"./node_modules/core-js/internals/html.js\");\n                var documentCreateElement = __nested_webpack_require_145366__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\n                var sharedKey = __nested_webpack_require_145366__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var GT = \">\";\n                var LT = \"<\";\n                var PROTOTYPE = \"prototype\";\n                var SCRIPT = \"script\";\n                var IE_PROTO = sharedKey(\"IE_PROTO\");\n                var EmptyConstructor = function() {};\n                var scriptTag = function(content) {\n                    return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n                };\n                // Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n                var NullProtoObjectViaActiveX = function(activeXDocument) {\n                    activeXDocument.write(scriptTag(\"\"));\n                    activeXDocument.close();\n                    var temp = activeXDocument.parentWindow.Object;\n                    activeXDocument = null; // avoid memory leak\n                    return temp;\n                };\n                // Create object with fake `null` prototype: use iframe Object with cleared prototype\n                var NullProtoObjectViaIFrame = function() {\n                    // Thrash, waste and sodomy: IE GC bug\n                    var iframe = documentCreateElement(\"iframe\");\n                    var JS = \"java\" + SCRIPT + \":\";\n                    var iframeDocument;\n                    if (iframe.style) {\n                        iframe.style.display = \"none\";\n                        html.appendChild(iframe);\n                        // https://github.com/zloirock/core-js/issues/475\n                        iframe.src = String(JS);\n                        iframeDocument = iframe.contentWindow.document;\n                        iframeDocument.open();\n                        iframeDocument.write(scriptTag(\"document.F=Object\"));\n                        iframeDocument.close();\n                        return iframeDocument.F;\n                    }\n                };\n                // Check for document.domain and active x support\n                // No need to use active x approach when document.domain is not set\n                // see https://github.com/es-shims/es5-shim/issues/150\n                // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n                // avoid IE GC bug\n                var activeXDocument;\n                var NullProtoObject = function() {\n                    try {\n                        activeXDocument = new ActiveXObject(\"htmlfile\");\n                    } catch (error) {}\n                    NullProtoObject = document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() || NullProtoObjectViaActiveX(activeXDocument); // WSH\n                    var length = enumBugKeys.length;\n                    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n                    return NullProtoObject();\n                };\n                hiddenKeys[IE_PROTO] = true;\n                // `Object.create` method\n                // https://tc39.es/ecma262/#sec-object.create\n                module1.exports = Object.create || function create(O, Properties) {\n                    var result;\n                    if (O !== null) {\n                        EmptyConstructor[PROTOTYPE] = anObject(O);\n                        result = new EmptyConstructor();\n                        EmptyConstructor[PROTOTYPE] = null;\n                        // add \"__proto__\" for Object.getPrototypeOf polyfill\n                        result[IE_PROTO] = O;\n                    } else result = NullProtoObject();\n                    return Properties === undefined ? result : defineProperties(result, Properties);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-define-properties.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-properties.js ***!\n  \\********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_150431__) {\n                var DESCRIPTORS = __nested_webpack_require_150431__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var definePropertyModule = __nested_webpack_require_150431__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var anObject = __nested_webpack_require_150431__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var objectKeys = __nested_webpack_require_150431__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                // `Object.defineProperties` method\n                // https://tc39.es/ecma262/#sec-object.defineproperties\n                // eslint-disable-next-line es/no-object-defineproperties -- safe\n                module1.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n                    anObject(O);\n                    var keys = objectKeys(Properties);\n                    var length = keys.length;\n                    var index = 0;\n                    var key;\n                    while(length > index)definePropertyModule.f(O, key = keys[index++], Properties[key]);\n                    return O;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-define-property.js\": /*!******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-property.js ***!\n  \\******************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_152071__) {\n                var DESCRIPTORS = __nested_webpack_require_152071__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var IE8_DOM_DEFINE = __nested_webpack_require_152071__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\n                var anObject = __nested_webpack_require_152071__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var toPropertyKey = __nested_webpack_require_152071__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                // eslint-disable-next-line es/no-object-defineproperty -- safe\n                var $defineProperty = Object.defineProperty;\n                // `Object.defineProperty` method\n                // https://tc39.es/ecma262/#sec-object.defineproperty\n                exports1.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n                    anObject(O);\n                    P = toPropertyKey(P);\n                    anObject(Attributes);\n                    if (IE8_DOM_DEFINE) try {\n                        return $defineProperty(O, P, Attributes);\n                    } catch (error) {}\n                    if (\"get\" in Attributes || \"set\" in Attributes) throw TypeError(\"Accessors not supported\");\n                    if (\"value\" in Attributes) O[P] = Attributes.value;\n                    return O;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\": /*!******************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!\n  \\******************************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_153939__) {\n                var DESCRIPTORS = __nested_webpack_require_153939__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var propertyIsEnumerableModule = __nested_webpack_require_153939__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\n                var createPropertyDescriptor = __nested_webpack_require_153939__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                var toIndexedObject = __nested_webpack_require_153939__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var toPropertyKey = __nested_webpack_require_153939__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                var has = __nested_webpack_require_153939__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var IE8_DOM_DEFINE = __nested_webpack_require_153939__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\n                // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n                // `Object.getOwnPropertyDescriptor` method\n                // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n                exports1.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n                    O = toIndexedObject(O);\n                    P = toPropertyKey(P);\n                    if (IE8_DOM_DEFINE) try {\n                        return $getOwnPropertyDescriptor(O, P);\n                    } catch (error) {}\n                    if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-names-external.js\": /*!**********************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!\n  \\**********************************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_156257__) {\n                /* eslint-disable es/no-object-getownpropertynames -- safe */ var toIndexedObject = __nested_webpack_require_156257__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var $getOwnPropertyNames = __nested_webpack_require_156257__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\").f;\n                var toString = {}.toString;\n                var windowNames =  false ? 0 : [];\n                var getWindowNames = function(it) {\n                    try {\n                        return $getOwnPropertyNames(it);\n                    } catch (error) {\n                        return windowNames.slice();\n                    }\n                };\n                // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n                module1.exports.f = function getOwnPropertyNames(it) {\n                    return windowNames && toString.call(it) == \"[object Window]\" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-names.js\": /*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!\n  \\*************************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_157856__) {\n                var internalObjectKeys = __nested_webpack_require_157856__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\n                var enumBugKeys = __nested_webpack_require_157856__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n                var hiddenKeys = enumBugKeys.concat(\"length\", \"prototype\");\n                // `Object.getOwnPropertyNames` method\n                // https://tc39.es/ecma262/#sec-object.getownpropertynames\n                // eslint-disable-next-line es/no-object-getownpropertynames -- safe\n                exports1.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n                    return internalObjectKeys(O, hiddenKeys);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\": /*!***************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!\n  \\***************************************************************************/ /***/ function(__unused_webpack_module, exports1) {\n                // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\n                exports1.f = Object.getOwnPropertySymbols;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-prototype-of.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!\n  \\*******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_159569__) {\n                var has = __nested_webpack_require_159569__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var toObject = __nested_webpack_require_159569__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var sharedKey = __nested_webpack_require_159569__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var CORRECT_PROTOTYPE_GETTER = __nested_webpack_require_159569__(/*! ../internals/correct-prototype-getter */ \"./node_modules/core-js/internals/correct-prototype-getter.js\");\n                var IE_PROTO = sharedKey(\"IE_PROTO\");\n                var ObjectPrototype = Object.prototype;\n                // `Object.getPrototypeOf` method\n                // https://tc39.es/ecma262/#sec-object.getprototypeof\n                // eslint-disable-next-line es/no-object-getprototypeof -- safe\n                module1.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {\n                    O = toObject(O);\n                    if (has(O, IE_PROTO)) return O[IE_PROTO];\n                    if (typeof O.constructor == \"function\" && O instanceof O.constructor) {\n                        return O.constructor.prototype;\n                    }\n                    return O instanceof Object ? ObjectPrototype : null;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-keys-internal.js\": /*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!\n  \\****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_161276__) {\n                var has = __nested_webpack_require_161276__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var toIndexedObject = __nested_webpack_require_161276__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var indexOf = __nested_webpack_require_161276__(/*! ../internals/array-includes */ \"./node_modules/core-js/internals/array-includes.js\").indexOf;\n                var hiddenKeys = __nested_webpack_require_161276__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                module1.exports = function(object, names) {\n                    var O = toIndexedObject(object);\n                    var i = 0;\n                    var result = [];\n                    var key;\n                    for(key in O)!has(hiddenKeys, key) && has(O, key) && result.push(key);\n                    // Don't enum bug & hidden keys\n                    while(names.length > i)if (has(O, key = names[i++])) {\n                        ~indexOf(result, key) || result.push(key);\n                    }\n                    return result;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-keys.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_162745__) {\n                var internalObjectKeys = __nested_webpack_require_162745__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\n                var enumBugKeys = __nested_webpack_require_162745__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n                // `Object.keys` method\n                // https://tc39.es/ecma262/#sec-object.keys\n                // eslint-disable-next-line es/no-object-keys -- safe\n                module1.exports = Object.keys || function keys(O) {\n                    return internalObjectKeys(O, enumBugKeys);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-property-is-enumerable.js\": /*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!\n  \\*************************************************************************/ /***/ function(__unused_webpack_module, exports1) {\n                \"use strict\";\n                var $propertyIsEnumerable = {}.propertyIsEnumerable;\n                // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n                // Nashorn ~ JDK8 bug\n                var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({\n                    1: 2\n                }, 1);\n                // `Object.prototype.propertyIsEnumerable` method implementation\n                // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n                exports1.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n                    var descriptor = getOwnPropertyDescriptor(this, V);\n                    return !!descriptor && descriptor.enumerable;\n                } : $propertyIsEnumerable;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-set-prototype-of.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!\n  \\*******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_165032__) {\n                /* eslint-disable no-proto -- safe */ var anObject = __nested_webpack_require_165032__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var aPossiblePrototype = __nested_webpack_require_165032__(/*! ../internals/a-possible-prototype */ \"./node_modules/core-js/internals/a-possible-prototype.js\");\n                // `Object.setPrototypeOf` method\n                // https://tc39.es/ecma262/#sec-object.setprototypeof\n                // Works with __proto__ only. Old v8 can't work with null proto objects.\n                // eslint-disable-next-line es/no-object-setprototypeof -- safe\n                module1.exports = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n                    var CORRECT_SETTER = false;\n                    var test = {};\n                    var setter;\n                    try {\n                        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                        setter = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set;\n                        setter.call(test, []);\n                        CORRECT_SETTER = test instanceof Array;\n                    } catch (error) {}\n                    return function setPrototypeOf(O, proto) {\n                        anObject(O);\n                        aPossiblePrototype(proto);\n                        if (CORRECT_SETTER) setter.call(O, proto);\n                        else O.__proto__ = proto;\n                        return O;\n                    };\n                }() : undefined);\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-to-string.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-to-string.js ***!\n  \\************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_166960__) {\n                \"use strict\";\n                var TO_STRING_TAG_SUPPORT = __nested_webpack_require_166960__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\n                var classof = __nested_webpack_require_166960__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\n                // `Object.prototype.toString` method implementation\n                // https://tc39.es/ecma262/#sec-object.prototype.tostring\n                module1.exports = TO_STRING_TAG_SUPPORT ? ({}).toString : function toString() {\n                    return \"[object \" + classof(this) + \"]\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/ordinary-to-primitive.js\": /*!*****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!\n  \\*****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_167988__) {\n                var isObject = __nested_webpack_require_167988__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                // `OrdinaryToPrimitive` abstract operation\n                // https://tc39.es/ecma262/#sec-ordinarytoprimitive\n                module1.exports = function(input, pref) {\n                    var fn, val;\n                    if (pref === \"string\" && typeof (fn = input.toString) == \"function\" && !isObject(val = fn.call(input))) return val;\n                    if (typeof (fn = input.valueOf) == \"function\" && !isObject(val = fn.call(input))) return val;\n                    if (pref !== \"string\" && typeof (fn = input.toString) == \"function\" && !isObject(val = fn.call(input))) return val;\n                    throw TypeError(\"Can't convert object to primitive value\");\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/own-keys.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/own-keys.js ***!\n  \\****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_169156__) {\n                var getBuiltIn = __nested_webpack_require_169156__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                var getOwnPropertyNamesModule = __nested_webpack_require_169156__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\");\n                var getOwnPropertySymbolsModule = __nested_webpack_require_169156__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\n                var anObject = __nested_webpack_require_169156__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                // all object keys, includes non-enumerable and symbols\n                module1.exports = getBuiltIn(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n                    var keys = getOwnPropertyNamesModule.f(anObject(it));\n                    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n                    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/path.js\": /*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/path.js ***!\n  \\************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_170560__) {\n                var global1 = __nested_webpack_require_170560__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                module1.exports = global1;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/redefine.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/redefine.js ***!\n  \\****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_171060__) {\n                var global1 = __nested_webpack_require_171060__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_171060__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var has = __nested_webpack_require_171060__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var setGlobal = __nested_webpack_require_171060__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\n                var inspectSource = __nested_webpack_require_171060__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\n                var InternalStateModule = __nested_webpack_require_171060__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var getInternalState = InternalStateModule.get;\n                var enforceInternalState = InternalStateModule.enforce;\n                var TEMPLATE = String(String).split(\"String\");\n                (module1.exports = function(O, key, value, options) {\n                    var unsafe = options ? !!options.unsafe : false;\n                    var simple = options ? !!options.enumerable : false;\n                    var noTargetGet = options ? !!options.noTargetGet : false;\n                    var state;\n                    if (typeof value == \"function\") {\n                        if (typeof key == \"string\" && !has(value, \"name\")) {\n                            createNonEnumerableProperty(value, \"name\", key);\n                        }\n                        state = enforceInternalState(value);\n                        if (!state.source) {\n                            state.source = TEMPLATE.join(typeof key == \"string\" ? key : \"\");\n                        }\n                    }\n                    if (O === global1) {\n                        if (simple) O[key] = value;\n                        else setGlobal(key, value);\n                        return;\n                    } else if (!unsafe) {\n                        delete O[key];\n                    } else if (!noTargetGet && O[key]) {\n                        simple = true;\n                    }\n                    if (simple) O[key] = value;\n                    else createNonEnumerableProperty(O, key, value);\n                // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n                })(Function.prototype, \"toString\", function toString() {\n                    return typeof this == \"function\" && getInternalState(this).source || inspectSource(this);\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/regexp-flags.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/regexp-flags.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_174097__) {\n                \"use strict\";\n                var anObject = __nested_webpack_require_174097__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                // `RegExp.prototype.flags` getter implementation\n                // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\n                module1.exports = function() {\n                    var that = anObject(this);\n                    var result = \"\";\n                    if (that.global) result += \"g\";\n                    if (that.ignoreCase) result += \"i\";\n                    if (that.multiline) result += \"m\";\n                    if (that.dotAll) result += \"s\";\n                    if (that.unicode) result += \"u\";\n                    if (that.sticky) result += \"y\";\n                    return result;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/require-object-coercible.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!\n  \\********************************************************************/ /***/ function(module1) {\n                // `RequireObjectCoercible` abstract operation\n                // https://tc39.es/ecma262/#sec-requireobjectcoercible\n                module1.exports = function(it) {\n                    if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/set-global.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-global.js ***!\n  \\******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_175916__) {\n                var global1 = __nested_webpack_require_175916__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                module1.exports = function(key, value) {\n                    try {\n                        // eslint-disable-next-line es/no-object-defineproperty -- safe\n                        Object.defineProperty(global1, key, {\n                            value: value,\n                            configurable: true,\n                            writable: true\n                        });\n                    } catch (error) {\n                        global1[key] = value;\n                    }\n                    return value;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/set-to-string-tag.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_176962__) {\n                var defineProperty = __nested_webpack_require_176962__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var has = __nested_webpack_require_176962__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var wellKnownSymbol = __nested_webpack_require_176962__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                module1.exports = function(it, TAG, STATIC) {\n                    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n                        defineProperty(it, TO_STRING_TAG, {\n                            configurable: true,\n                            value: TAG\n                        });\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/shared-key.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared-key.js ***!\n  \\******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_178168__) {\n                var shared = __nested_webpack_require_178168__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n                var uid = __nested_webpack_require_178168__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n                var keys = shared(\"keys\");\n                module1.exports = function(key) {\n                    return keys[key] || (keys[key] = uid(key));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/shared-store.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared-store.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_178930__) {\n                var global1 = __nested_webpack_require_178930__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var setGlobal = __nested_webpack_require_178930__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\n                var SHARED = \"__core-js_shared__\";\n                var store = global1[SHARED] || setGlobal(SHARED, {});\n                module1.exports = store;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/shared.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared.js ***!\n  \\**************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_179675__) {\n                var IS_PURE = __nested_webpack_require_179675__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var store = __nested_webpack_require_179675__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n                (module1.exports = function(key, value) {\n                    return store[key] || (store[key] = value !== undefined ? value : {});\n                })(\"versions\", []).push({\n                    version: \"3.16.0\",\n                    mode: IS_PURE ? \"pure\" : \"global\",\n                    copyright: \"\\xa9 2021 Denis Pushkarev (zloirock.ru)\"\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/string-html-forced.js\": /*!**************************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-html-forced.js ***!\n  \\**************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_180685__) {\n                var fails = __nested_webpack_require_180685__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                // check the existence of a method, lowercase\n                // of a tag and escaping quotes in arguments\n                module1.exports = function(METHOD_NAME) {\n                    return fails(function() {\n                        var test = \"\"[METHOD_NAME]('\"');\n                        return test !== test.toLowerCase() || test.split('\"').length > 3;\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/string-multibyte.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-multibyte.js ***!\n  \\************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_181587__) {\n                var toInteger = __nested_webpack_require_181587__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n                var toString = __nested_webpack_require_181587__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var requireObjectCoercible = __nested_webpack_require_181587__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                // `String.prototype.codePointAt` methods implementation\n                var createMethod = function(CONVERT_TO_STRING) {\n                    return function($this, pos) {\n                        var S = toString(requireObjectCoercible($this));\n                        var position = toInteger(pos);\n                        var size = S.length;\n                        var first, second;\n                        if (position < 0 || position >= size) return CONVERT_TO_STRING ? \"\" : undefined;\n                        first = S.charCodeAt(position);\n                        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n                    };\n                };\n                module1.exports = {\n                    // `String.prototype.codePointAt` method\n                    // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n                    codeAt: createMethod(false),\n                    // `String.prototype.at` method\n                    // https://github.com/mathiasbynens/String.prototype.at\n                    charAt: createMethod(true)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/string-trim.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-trim.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_183717__) {\n                var requireObjectCoercible = __nested_webpack_require_183717__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                var toString = __nested_webpack_require_183717__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var whitespaces = __nested_webpack_require_183717__(/*! ../internals/whitespaces */ \"./node_modules/core-js/internals/whitespaces.js\");\n                var whitespace = \"[\" + whitespaces + \"]\";\n                var ltrim = RegExp(\"^\" + whitespace + whitespace + \"*\");\n                var rtrim = RegExp(whitespace + whitespace + \"*$\");\n                // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\n                var createMethod = function(TYPE) {\n                    return function($this) {\n                        var string = toString(requireObjectCoercible($this));\n                        if (TYPE & 1) string = string.replace(ltrim, \"\");\n                        if (TYPE & 2) string = string.replace(rtrim, \"\");\n                        return string;\n                    };\n                };\n                module1.exports = {\n                    // `String.prototype.{ trimLeft, trimStart }` methods\n                    // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n                    start: createMethod(1),\n                    // `String.prototype.{ trimRight, trimEnd }` methods\n                    // https://tc39.es/ecma262/#sec-string.prototype.trimend\n                    end: createMethod(2),\n                    // `String.prototype.trim` method\n                    // https://tc39.es/ecma262/#sec-string.prototype.trim\n                    trim: createMethod(3)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-absolute-index.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_185858__) {\n                var toInteger = __nested_webpack_require_185858__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n                var max = Math.max;\n                var min = Math.min;\n                // Helper for a popular repeating case of the spec:\n                // Let integer be ? ToInteger(index).\n                // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n                module1.exports = function(index, length) {\n                    var integer = toInteger(index);\n                    return integer < 0 ? max(integer + length, 0) : min(integer, length);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-indexed-object.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_186894__) {\n                // toObject with fallback for non-array-like ES3 strings\n                var IndexedObject = __nested_webpack_require_186894__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                var requireObjectCoercible = __nested_webpack_require_186894__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                module1.exports = function(it) {\n                    return IndexedObject(requireObjectCoercible(it));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-integer.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-integer.js ***!\n  \\******************************************************/ /***/ function(module1) {\n                var ceil = Math.ceil;\n                var floor = Math.floor;\n                // `ToInteger` abstract operation\n                // https://tc39.es/ecma262/#sec-tointeger\n                module1.exports = function(argument) {\n                    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-length.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-length.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_188419__) {\n                var toInteger = __nested_webpack_require_188419__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n                var min = Math.min;\n                // `ToLength` abstract operation\n                // https://tc39.es/ecma262/#sec-tolength\n                module1.exports = function(argument) {\n                    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-object.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-object.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_189231__) {\n                var requireObjectCoercible = __nested_webpack_require_189231__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                // `ToObject` abstract operation\n                // https://tc39.es/ecma262/#sec-toobject\n                module1.exports = function(argument) {\n                    return Object(requireObjectCoercible(argument));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-primitive.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-primitive.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_190004__) {\n                var isObject = __nested_webpack_require_190004__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isSymbol = __nested_webpack_require_190004__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                var ordinaryToPrimitive = __nested_webpack_require_190004__(/*! ../internals/ordinary-to-primitive */ \"./node_modules/core-js/internals/ordinary-to-primitive.js\");\n                var wellKnownSymbol = __nested_webpack_require_190004__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n                // `ToPrimitive` abstract operation\n                // https://tc39.es/ecma262/#sec-toprimitive\n                module1.exports = function(input, pref) {\n                    if (!isObject(input) || isSymbol(input)) return input;\n                    var exoticToPrim = input[TO_PRIMITIVE];\n                    var result;\n                    if (exoticToPrim !== undefined) {\n                        if (pref === undefined) pref = \"default\";\n                        result = exoticToPrim.call(input, pref);\n                        if (!isObject(result) || isSymbol(result)) return result;\n                        throw TypeError(\"Can't convert object to primitive value\");\n                    }\n                    if (pref === undefined) pref = \"number\";\n                    return ordinaryToPrimitive(input, pref);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-property-key.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-property-key.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_191865__) {\n                var toPrimitive = __nested_webpack_require_191865__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\n                var isSymbol = __nested_webpack_require_191865__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                // `ToPropertyKey` abstract operation\n                // https://tc39.es/ecma262/#sec-topropertykey\n                module1.exports = function(argument) {\n                    var key = toPrimitive(argument, \"string\");\n                    return isSymbol(key) ? key : String(key);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-string-tag-support.js\": /*!*****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!\n  \\*****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_192836__) {\n                var wellKnownSymbol = __nested_webpack_require_192836__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                var test = {};\n                test[TO_STRING_TAG] = \"z\";\n                module1.exports = String(test) === \"[object z]\";\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-string.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-string.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_193534__) {\n                var isSymbol = __nested_webpack_require_193534__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                module1.exports = function(argument) {\n                    if (isSymbol(argument)) throw TypeError(\"Cannot convert a Symbol value to a string\");\n                    return String(argument);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/uid.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/uid.js ***!\n  \\***********************************************/ /***/ function(module1) {\n                var id = 0;\n                var postfix = Math.random();\n                module1.exports = function(key) {\n                    return \"Symbol(\" + String(key === undefined ? \"\" : key) + \")_\" + (++id + postfix).toString(36);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/use-symbol-as-uid.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_194783__) {\n                /* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = __nested_webpack_require_194783__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n                module1.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/well-known-symbol-wrapped.js\": /*!*********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!\n  \\*********************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_195489__) {\n                var wellKnownSymbol = __nested_webpack_require_195489__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                exports1.f = wellKnownSymbol;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/well-known-symbol.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_196058__) {\n                var global1 = __nested_webpack_require_196058__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var shared = __nested_webpack_require_196058__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n                var has = __nested_webpack_require_196058__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var uid = __nested_webpack_require_196058__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n                var NATIVE_SYMBOL = __nested_webpack_require_196058__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n                var USE_SYMBOL_AS_UID = __nested_webpack_require_196058__(/*! ../internals/use-symbol-as-uid */ \"./node_modules/core-js/internals/use-symbol-as-uid.js\");\n                var WellKnownSymbolsStore = shared(\"wks\");\n                var Symbol1 = global1.Symbol;\n                var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol1 : Symbol1 && Symbol1.withoutSetter || uid;\n                module1.exports = function(name) {\n                    if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \"string\")) {\n                        if (NATIVE_SYMBOL && has(Symbol1, name)) {\n                            WellKnownSymbolsStore[name] = Symbol1[name];\n                        } else {\n                            WellKnownSymbolsStore[name] = createWellKnownSymbol(\"Symbol.\" + name);\n                        }\n                    }\n                    return WellKnownSymbolsStore[name];\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/whitespaces.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/whitespaces.js ***!\n  \\*******************************************************/ /***/ function(module1) {\n                // a string of all valid unicode whitespaces\n                module1.exports = \"\t\\n\\v\\f\\r \\xa0    \" + \"          　\\u2028\\u2029\\uFEFF\";\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.concat.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.concat.js ***!\n  \\*********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_198448__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_198448__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var fails = __nested_webpack_require_198448__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var isArray = __nested_webpack_require_198448__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var isObject = __nested_webpack_require_198448__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var toObject = __nested_webpack_require_198448__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var toLength = __nested_webpack_require_198448__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var createProperty = __nested_webpack_require_198448__(/*! ../internals/create-property */ \"./node_modules/core-js/internals/create-property.js\");\n                var arraySpeciesCreate = __nested_webpack_require_198448__(/*! ../internals/array-species-create */ \"./node_modules/core-js/internals/array-species-create.js\");\n                var arrayMethodHasSpeciesSupport = __nested_webpack_require_198448__(/*! ../internals/array-method-has-species-support */ \"./node_modules/core-js/internals/array-method-has-species-support.js\");\n                var wellKnownSymbol = __nested_webpack_require_198448__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var V8_VERSION = __nested_webpack_require_198448__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\n                var IS_CONCAT_SPREADABLE = wellKnownSymbol(\"isConcatSpreadable\");\n                var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\n                var MAXIMUM_ALLOWED_INDEX_EXCEEDED = \"Maximum allowed index exceeded\";\n                // We can't use this feature detection in V8 since it causes\n                // deoptimization and serious performance degradation\n                // https://github.com/zloirock/core-js/issues/679\n                var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {\n                    var array = [];\n                    array[IS_CONCAT_SPREADABLE] = false;\n                    return array.concat()[0] !== array;\n                });\n                var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"concat\");\n                var isConcatSpreadable = function(O) {\n                    if (!isObject(O)) return false;\n                    var spreadable = O[IS_CONCAT_SPREADABLE];\n                    return spreadable !== undefined ? !!spreadable : isArray(O);\n                };\n                var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;\n                // `Array.prototype.concat` method\n                // https://tc39.es/ecma262/#sec-array.prototype.concat\n                // with adding support of @@isConcatSpreadable and @@species\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: FORCED\n                }, {\n                    // eslint-disable-next-line no-unused-vars -- required for `.length`\n                    concat: function concat(arg) {\n                        var O = toObject(this);\n                        var A = arraySpeciesCreate(O, 0);\n                        var n = 0;\n                        var i, k, length, len, E;\n                        for(i = -1, length = arguments.length; i < length; i++){\n                            E = i === -1 ? O : arguments[i];\n                            if (isConcatSpreadable(E)) {\n                                len = toLength(E.length);\n                                if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n                                for(k = 0; k < len; k++, n++)if (k in E) createProperty(A, n, E[k]);\n                            } else {\n                                if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n                                createProperty(A, n++, E);\n                            }\n                        }\n                        A.length = n;\n                        return A;\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.iterator.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_203057__) {\n                \"use strict\";\n                var toIndexedObject = __nested_webpack_require_203057__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var addToUnscopables = __nested_webpack_require_203057__(/*! ../internals/add-to-unscopables */ \"./node_modules/core-js/internals/add-to-unscopables.js\");\n                var Iterators = __nested_webpack_require_203057__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n                var InternalStateModule = __nested_webpack_require_203057__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var defineIterator = __nested_webpack_require_203057__(/*! ../internals/define-iterator */ \"./node_modules/core-js/internals/define-iterator.js\");\n                var ARRAY_ITERATOR = \"Array Iterator\";\n                var setInternalState = InternalStateModule.set;\n                var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n                // `Array.prototype.entries` method\n                // https://tc39.es/ecma262/#sec-array.prototype.entries\n                // `Array.prototype.keys` method\n                // https://tc39.es/ecma262/#sec-array.prototype.keys\n                // `Array.prototype.values` method\n                // https://tc39.es/ecma262/#sec-array.prototype.values\n                // `Array.prototype[@@iterator]` method\n                // https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n                // `CreateArrayIterator` internal method\n                // https://tc39.es/ecma262/#sec-createarrayiterator\n                module1.exports = defineIterator(Array, \"Array\", function(iterated, kind) {\n                    setInternalState(this, {\n                        type: ARRAY_ITERATOR,\n                        target: toIndexedObject(iterated),\n                        index: 0,\n                        kind: kind // kind\n                    });\n                // `%ArrayIteratorPrototype%.next` method\n                // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n                }, function() {\n                    var state = getInternalState(this);\n                    var target = state.target;\n                    var kind = state.kind;\n                    var index = state.index++;\n                    if (!target || index >= target.length) {\n                        state.target = undefined;\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                    if (kind == \"keys\") return {\n                        value: index,\n                        done: false\n                    };\n                    if (kind == \"values\") return {\n                        value: target[index],\n                        done: false\n                    };\n                    return {\n                        value: [\n                            index,\n                            target[index]\n                        ],\n                        done: false\n                    };\n                }, \"values\");\n                // argumentsList[@@iterator] is %ArrayProto_values%\n                // https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n                // https://tc39.es/ecma262/#sec-createmappedargumentsobject\n                Iterators.Arguments = Iterators.Array;\n                // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n                addToUnscopables(\"keys\");\n                addToUnscopables(\"values\");\n                addToUnscopables(\"entries\");\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.join.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.join.js ***!\n  \\*******************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_207042__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_207042__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var IndexedObject = __nested_webpack_require_207042__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                var toIndexedObject = __nested_webpack_require_207042__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var arrayMethodIsStrict = __nested_webpack_require_207042__(/*! ../internals/array-method-is-strict */ \"./node_modules/core-js/internals/array-method-is-strict.js\");\n                var nativeJoin = [].join;\n                var ES3_STRINGS = IndexedObject != Object;\n                var STRICT_METHOD = arrayMethodIsStrict(\"join\", \",\");\n                // `Array.prototype.join` method\n                // https://tc39.es/ecma262/#sec-array.prototype.join\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: ES3_STRINGS || !STRICT_METHOD\n                }, {\n                    join: function join(separator) {\n                        return nativeJoin.call(toIndexedObject(this), separator === undefined ? \",\" : separator);\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.map.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.map.js ***!\n  \\******************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_208682__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_208682__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var $map = __nested_webpack_require_208682__(/*! ../internals/array-iteration */ \"./node_modules/core-js/internals/array-iteration.js\").map;\n                var arrayMethodHasSpeciesSupport = __nested_webpack_require_208682__(/*! ../internals/array-method-has-species-support */ \"./node_modules/core-js/internals/array-method-has-species-support.js\");\n                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"map\");\n                // `Array.prototype.map` method\n                // https://tc39.es/ecma262/#sec-array.prototype.map\n                // with adding support of @@species\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: !HAS_SPECIES_SUPPORT\n                }, {\n                    map: function map(callbackfn /* , thisArg */ ) {\n                        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.slice.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.slice.js ***!\n  \\********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_210157__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_210157__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var isObject = __nested_webpack_require_210157__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isArray = __nested_webpack_require_210157__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var toAbsoluteIndex = __nested_webpack_require_210157__(/*! ../internals/to-absolute-index */ \"./node_modules/core-js/internals/to-absolute-index.js\");\n                var toLength = __nested_webpack_require_210157__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var toIndexedObject = __nested_webpack_require_210157__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var createProperty = __nested_webpack_require_210157__(/*! ../internals/create-property */ \"./node_modules/core-js/internals/create-property.js\");\n                var wellKnownSymbol = __nested_webpack_require_210157__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var arrayMethodHasSpeciesSupport = __nested_webpack_require_210157__(/*! ../internals/array-method-has-species-support */ \"./node_modules/core-js/internals/array-method-has-species-support.js\");\n                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"slice\");\n                var SPECIES = wellKnownSymbol(\"species\");\n                var nativeSlice = [].slice;\n                var max = Math.max;\n                // `Array.prototype.slice` method\n                // https://tc39.es/ecma262/#sec-array.prototype.slice\n                // fallback for not array-like ES3 strings and DOM objects\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: !HAS_SPECIES_SUPPORT\n                }, {\n                    slice: function slice(start, end) {\n                        var O = toIndexedObject(this);\n                        var length = toLength(O.length);\n                        var k = toAbsoluteIndex(start, length);\n                        var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n                        // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n                        var Constructor, result, n;\n                        if (isArray(O)) {\n                            Constructor = O.constructor;\n                            // cross-realm fallback\n                            if (typeof Constructor == \"function\" && (Constructor === Array || isArray(Constructor.prototype))) {\n                                Constructor = undefined;\n                            } else if (isObject(Constructor)) {\n                                Constructor = Constructor[SPECIES];\n                                if (Constructor === null) Constructor = undefined;\n                            }\n                            if (Constructor === Array || Constructor === undefined) {\n                                return nativeSlice.call(O, k, fin);\n                            }\n                        }\n                        result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));\n                        for(n = 0; k < fin; k++, n++)if (k in O) createProperty(result, n, O[k]);\n                        result.length = n;\n                        return result;\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.function.name.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.function.name.js ***!\n  \\**********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_214052__) {\n                var DESCRIPTORS = __nested_webpack_require_214052__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var defineProperty = __nested_webpack_require_214052__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var FunctionPrototype = Function.prototype;\n                var FunctionPrototypeToString = FunctionPrototype.toString;\n                var nameRE = /^\\s*function ([^ (]*)/;\n                var NAME = \"name\";\n                // Function instances `.name` property\n                // https://tc39.es/ecma262/#sec-function-instances-name\n                if (DESCRIPTORS && !(NAME in FunctionPrototype)) {\n                    defineProperty(FunctionPrototype, NAME, {\n                        configurable: true,\n                        get: function() {\n                            try {\n                                return FunctionPrototypeToString.call(this).match(nameRE)[1];\n                            } catch (error) {\n                                return \"\";\n                            }\n                        }\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.number.constructor.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.number.constructor.js ***!\n  \\***************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_215630__) {\n                \"use strict\";\n                var DESCRIPTORS = __nested_webpack_require_215630__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var global1 = __nested_webpack_require_215630__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var isForced = __nested_webpack_require_215630__(/*! ../internals/is-forced */ \"./node_modules/core-js/internals/is-forced.js\");\n                var redefine = __nested_webpack_require_215630__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var has = __nested_webpack_require_215630__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var classof = __nested_webpack_require_215630__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                var inheritIfRequired = __nested_webpack_require_215630__(/*! ../internals/inherit-if-required */ \"./node_modules/core-js/internals/inherit-if-required.js\");\n                var isSymbol = __nested_webpack_require_215630__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                var toPrimitive = __nested_webpack_require_215630__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\n                var fails = __nested_webpack_require_215630__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var create = __nested_webpack_require_215630__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var getOwnPropertyNames = __nested_webpack_require_215630__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\").f;\n                var getOwnPropertyDescriptor = __nested_webpack_require_215630__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\").f;\n                var defineProperty = __nested_webpack_require_215630__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var trim = __nested_webpack_require_215630__(/*! ../internals/string-trim */ \"./node_modules/core-js/internals/string-trim.js\").trim;\n                var NUMBER = \"Number\";\n                var NativeNumber = global1[NUMBER];\n                var NumberPrototype = NativeNumber.prototype;\n                // Opera ~12 has broken Object#toString\n                var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;\n                // `ToNumber` abstract operation\n                // https://tc39.es/ecma262/#sec-tonumber\n                var toNumber = function(argument) {\n                    if (isSymbol(argument)) throw TypeError(\"Cannot convert a Symbol value to a number\");\n                    var it = toPrimitive(argument, \"number\");\n                    var first, third, radix, maxCode, digits, length, index, code;\n                    if (typeof it == \"string\" && it.length > 2) {\n                        it = trim(it);\n                        first = it.charCodeAt(0);\n                        if (first === 43 || first === 45) {\n                            third = it.charCodeAt(2);\n                            if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n                        } else if (first === 48) {\n                            switch(it.charCodeAt(1)){\n                                case 66:\n                                case 98:\n                                    radix = 2;\n                                    maxCode = 49;\n                                    break; // fast equal of /^0b[01]+$/i\n                                case 79:\n                                case 111:\n                                    radix = 8;\n                                    maxCode = 55;\n                                    break; // fast equal of /^0o[0-7]+$/i\n                                default:\n                                    return +it;\n                            }\n                            digits = it.slice(2);\n                            length = digits.length;\n                            for(index = 0; index < length; index++){\n                                code = digits.charCodeAt(index);\n                                // parseInt parses a string to a first unavailable symbol\n                                // but ToNumber should return NaN if a string contains unavailable symbols\n                                if (code < 48 || code > maxCode) return NaN;\n                            }\n                            return parseInt(digits, radix);\n                        }\n                    }\n                    return +it;\n                };\n                // `Number` constructor\n                // https://tc39.es/ecma262/#sec-number-constructor\n                if (isForced(NUMBER, !NativeNumber(\" 0o1\") || !NativeNumber(\"0b1\") || NativeNumber(\"+0x1\"))) {\n                    var NumberWrapper = function Number1(value) {\n                        var it = arguments.length < 1 ? 0 : value;\n                        var dummy = this;\n                        return dummy instanceof NumberWrapper && (BROKEN_CLASSOF ? fails(function() {\n                            NumberPrototype.valueOf.call(dummy);\n                        }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);\n                    };\n                    for(var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : // ES3:\n                    (\"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,\" + // ES2015 (in case, if modules with ES2015 Number statics required before):\n                    \"EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,\" + \"MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,\" + // ESNext\n                    \"fromString,range\").split(\",\"), j = 0, key; keys.length > j; j++){\n                        if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {\n                            defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));\n                        }\n                    }\n                    NumberWrapper.prototype = NumberPrototype;\n                    NumberPrototype.constructor = NumberWrapper;\n                    redefine(global1, NUMBER, NumberWrapper);\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.object.assign.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.object.assign.js ***!\n  \\**********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_222369__) {\n                var $ = __nested_webpack_require_222369__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var assign = __nested_webpack_require_222369__(/*! ../internals/object-assign */ \"./node_modules/core-js/internals/object-assign.js\");\n                // `Object.assign` method\n                // https://tc39.es/ecma262/#sec-object.assign\n                // eslint-disable-next-line es/no-object-assign -- required for testing\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: Object.assign !== assign\n                }, {\n                    assign: assign\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.object.keys.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.object.keys.js ***!\n  \\********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_223400__) {\n                var $ = __nested_webpack_require_223400__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var toObject = __nested_webpack_require_223400__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var nativeKeys = __nested_webpack_require_223400__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                var fails = __nested_webpack_require_223400__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var FAILS_ON_PRIMITIVES = fails(function() {\n                    nativeKeys(1);\n                });\n                // `Object.keys` method\n                // https://tc39.es/ecma262/#sec-object.keys\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: FAILS_ON_PRIMITIVES\n                }, {\n                    keys: function keys(it) {\n                        return nativeKeys(toObject(it));\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.object.to-string.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!\n  \\*************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_224811__) {\n                var TO_STRING_TAG_SUPPORT = __nested_webpack_require_224811__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\n                var redefine = __nested_webpack_require_224811__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var toString = __nested_webpack_require_224811__(/*! ../internals/object-to-string */ \"./node_modules/core-js/internals/object-to-string.js\");\n                // `Object.prototype.toString` method\n                // https://tc39.es/ecma262/#sec-object.prototype.tostring\n                if (!TO_STRING_TAG_SUPPORT) {\n                    redefine(Object.prototype, \"toString\", toString, {\n                        unsafe: true\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.regexp.to-string.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.regexp.to-string.js ***!\n  \\*************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_225962__) {\n                \"use strict\";\n                var redefine = __nested_webpack_require_225962__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var anObject = __nested_webpack_require_225962__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var $toString = __nested_webpack_require_225962__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var fails = __nested_webpack_require_225962__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var flags = __nested_webpack_require_225962__(/*! ../internals/regexp-flags */ \"./node_modules/core-js/internals/regexp-flags.js\");\n                var TO_STRING = \"toString\";\n                var RegExpPrototype = RegExp.prototype;\n                var nativeToString = RegExpPrototype[TO_STRING];\n                var NOT_GENERIC = fails(function() {\n                    return nativeToString.call({\n                        source: \"a\",\n                        flags: \"b\"\n                    }) != \"/a/b\";\n                });\n                // FF44- RegExp#toString has a wrong name\n                var INCORRECT_NAME = nativeToString.name != TO_STRING;\n                // `RegExp.prototype.toString` method\n                // https://tc39.es/ecma262/#sec-regexp.prototype.tostring\n                if (NOT_GENERIC || INCORRECT_NAME) {\n                    redefine(RegExp.prototype, TO_STRING, function toString() {\n                        var R = anObject(this);\n                        var p = $toString(R.source);\n                        var rf = R.flags;\n                        var f = $toString(rf === undefined && R instanceof RegExp && !(\"flags\" in RegExpPrototype) ? flags.call(R) : rf);\n                        return \"/\" + p + \"/\" + f;\n                    }, {\n                        unsafe: true\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.string.iterator.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!\n  \\************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_228237__) {\n                \"use strict\";\n                var charAt = __nested_webpack_require_228237__(/*! ../internals/string-multibyte */ \"./node_modules/core-js/internals/string-multibyte.js\").charAt;\n                var toString = __nested_webpack_require_228237__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var InternalStateModule = __nested_webpack_require_228237__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var defineIterator = __nested_webpack_require_228237__(/*! ../internals/define-iterator */ \"./node_modules/core-js/internals/define-iterator.js\");\n                var STRING_ITERATOR = \"String Iterator\";\n                var setInternalState = InternalStateModule.set;\n                var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n                // `String.prototype[@@iterator]` method\n                // https://tc39.es/ecma262/#sec-string.prototype-@@iterator\n                defineIterator(String, \"String\", function(iterated) {\n                    setInternalState(this, {\n                        type: STRING_ITERATOR,\n                        string: toString(iterated),\n                        index: 0\n                    });\n                // `%StringIteratorPrototype%.next` method\n                // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n                }, function next() {\n                    var state = getInternalState(this);\n                    var string = state.string;\n                    var index = state.index;\n                    var point;\n                    if (index >= string.length) return {\n                        value: undefined,\n                        done: true\n                    };\n                    point = charAt(string, index);\n                    state.index += point.length;\n                    return {\n                        value: point,\n                        done: false\n                    };\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.string.link.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.string.link.js ***!\n  \\********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_230583__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_230583__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var createHTML = __nested_webpack_require_230583__(/*! ../internals/create-html */ \"./node_modules/core-js/internals/create-html.js\");\n                var forcedStringHTMLMethod = __nested_webpack_require_230583__(/*! ../internals/string-html-forced */ \"./node_modules/core-js/internals/string-html-forced.js\");\n                // `String.prototype.link` method\n                // https://tc39.es/ecma262/#sec-string.prototype.link\n                $({\n                    target: \"String\",\n                    proto: true,\n                    forced: forcedStringHTMLMethod(\"link\")\n                }, {\n                    link: function link(url) {\n                        return createHTML(this, \"a\", \"href\", url);\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.symbol.description.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!\n  \\***************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_231871__) {\n                \"use strict\";\n                // `Symbol.prototype.description` getter\n                // https://tc39.es/ecma262/#sec-symbol.prototype.description\n                var $ = __nested_webpack_require_231871__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var DESCRIPTORS = __nested_webpack_require_231871__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var global1 = __nested_webpack_require_231871__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var has = __nested_webpack_require_231871__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var isObject = __nested_webpack_require_231871__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var defineProperty = __nested_webpack_require_231871__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var copyConstructorProperties = __nested_webpack_require_231871__(/*! ../internals/copy-constructor-properties */ \"./node_modules/core-js/internals/copy-constructor-properties.js\");\n                var NativeSymbol = global1.Symbol;\n                if (DESCRIPTORS && typeof NativeSymbol == \"function\" && (!(\"description\" in NativeSymbol.prototype) || // Safari 12 bug\n                NativeSymbol().description !== undefined)) {\n                    var EmptyStringDescriptionStore = {};\n                    // wrap Symbol constructor for correct work with undefined description\n                    var SymbolWrapper = function Symbol1() {\n                        var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);\n                        var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description);\n                        if (description === \"\") EmptyStringDescriptionStore[result] = true;\n                        return result;\n                    };\n                    copyConstructorProperties(SymbolWrapper, NativeSymbol);\n                    var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;\n                    symbolPrototype.constructor = SymbolWrapper;\n                    var symbolToString = symbolPrototype.toString;\n                    var native = String(NativeSymbol(\"test\")) == \"Symbol(test)\";\n                    var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n                    defineProperty(symbolPrototype, \"description\", {\n                        configurable: true,\n                        get: function description() {\n                            var symbol = isObject(this) ? this.valueOf() : this;\n                            var string = symbolToString.call(symbol);\n                            if (has(EmptyStringDescriptionStore, symbol)) return \"\";\n                            var desc = native ? string.slice(7, -1) : string.replace(regexp, \"$1\");\n                            return desc === \"\" ? undefined : desc;\n                        }\n                    });\n                    $({\n                        global: true,\n                        forced: true\n                    }, {\n                        Symbol: SymbolWrapper\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.symbol.iterator.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!\n  \\************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_235575__) {\n                var defineWellKnownSymbol = __nested_webpack_require_235575__(/*! ../internals/define-well-known-symbol */ \"./node_modules/core-js/internals/define-well-known-symbol.js\");\n                // `Symbol.iterator` well-known symbol\n                // https://tc39.es/ecma262/#sec-symbol.iterator\n                defineWellKnownSymbol(\"iterator\");\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.symbol.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.symbol.js ***!\n  \\***************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_236264__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_236264__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var global1 = __nested_webpack_require_236264__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var getBuiltIn = __nested_webpack_require_236264__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                var IS_PURE = __nested_webpack_require_236264__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var DESCRIPTORS = __nested_webpack_require_236264__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var NATIVE_SYMBOL = __nested_webpack_require_236264__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n                var fails = __nested_webpack_require_236264__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var has = __nested_webpack_require_236264__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var isArray = __nested_webpack_require_236264__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var isObject = __nested_webpack_require_236264__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isSymbol = __nested_webpack_require_236264__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                var anObject = __nested_webpack_require_236264__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var toObject = __nested_webpack_require_236264__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var toIndexedObject = __nested_webpack_require_236264__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var toPropertyKey = __nested_webpack_require_236264__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                var $toString = __nested_webpack_require_236264__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var createPropertyDescriptor = __nested_webpack_require_236264__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                var nativeObjectCreate = __nested_webpack_require_236264__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var objectKeys = __nested_webpack_require_236264__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                var getOwnPropertyNamesModule = __nested_webpack_require_236264__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\");\n                var getOwnPropertyNamesExternal = __nested_webpack_require_236264__(/*! ../internals/object-get-own-property-names-external */ \"./node_modules/core-js/internals/object-get-own-property-names-external.js\");\n                var getOwnPropertySymbolsModule = __nested_webpack_require_236264__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\n                var getOwnPropertyDescriptorModule = __nested_webpack_require_236264__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\");\n                var definePropertyModule = __nested_webpack_require_236264__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var propertyIsEnumerableModule = __nested_webpack_require_236264__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_236264__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var redefine = __nested_webpack_require_236264__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var shared = __nested_webpack_require_236264__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n                var sharedKey = __nested_webpack_require_236264__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var hiddenKeys = __nested_webpack_require_236264__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                var uid = __nested_webpack_require_236264__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n                var wellKnownSymbol = __nested_webpack_require_236264__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var wrappedWellKnownSymbolModule = __nested_webpack_require_236264__(/*! ../internals/well-known-symbol-wrapped */ \"./node_modules/core-js/internals/well-known-symbol-wrapped.js\");\n                var defineWellKnownSymbol = __nested_webpack_require_236264__(/*! ../internals/define-well-known-symbol */ \"./node_modules/core-js/internals/define-well-known-symbol.js\");\n                var setToStringTag = __nested_webpack_require_236264__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\n                var InternalStateModule = __nested_webpack_require_236264__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var $forEach = __nested_webpack_require_236264__(/*! ../internals/array-iteration */ \"./node_modules/core-js/internals/array-iteration.js\").forEach;\n                var HIDDEN = sharedKey(\"hidden\");\n                var SYMBOL = \"Symbol\";\n                var PROTOTYPE = \"prototype\";\n                var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n                var setInternalState = InternalStateModule.set;\n                var getInternalState = InternalStateModule.getterFor(SYMBOL);\n                var ObjectPrototype = Object[PROTOTYPE];\n                var $Symbol = global1.Symbol;\n                var $stringify = getBuiltIn(\"JSON\", \"stringify\");\n                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n                var nativeDefineProperty = definePropertyModule.f;\n                var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;\n                var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;\n                var AllSymbols = shared(\"symbols\");\n                var ObjectPrototypeSymbols = shared(\"op-symbols\");\n                var StringToSymbolRegistry = shared(\"string-to-symbol-registry\");\n                var SymbolToStringRegistry = shared(\"symbol-to-string-registry\");\n                var WellKnownSymbolsStore = shared(\"wks\");\n                var QObject = global1.QObject;\n                // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n                var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n                // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n                var setSymbolDescriptor = DESCRIPTORS && fails(function() {\n                    return nativeObjectCreate(nativeDefineProperty({}, \"a\", {\n                        get: function() {\n                            return nativeDefineProperty(this, \"a\", {\n                                value: 7\n                            }).a;\n                        }\n                    })).a != 7;\n                }) ? function(O, P, Attributes) {\n                    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);\n                    if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];\n                    nativeDefineProperty(O, P, Attributes);\n                    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {\n                        nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);\n                    }\n                } : nativeDefineProperty;\n                var wrap = function(tag, description) {\n                    var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);\n                    setInternalState(symbol, {\n                        type: SYMBOL,\n                        tag: tag,\n                        description: description\n                    });\n                    if (!DESCRIPTORS) symbol.description = description;\n                    return symbol;\n                };\n                var $defineProperty = function defineProperty(O, P, Attributes) {\n                    if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n                    anObject(O);\n                    var key = toPropertyKey(P);\n                    anObject(Attributes);\n                    if (has(AllSymbols, key)) {\n                        if (!Attributes.enumerable) {\n                            if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));\n                            O[HIDDEN][key] = true;\n                        } else {\n                            if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n                            Attributes = nativeObjectCreate(Attributes, {\n                                enumerable: createPropertyDescriptor(0, false)\n                            });\n                        }\n                        return setSymbolDescriptor(O, key, Attributes);\n                    }\n                    return nativeDefineProperty(O, key, Attributes);\n                };\n                var $defineProperties = function defineProperties(O, Properties) {\n                    anObject(O);\n                    var properties = toIndexedObject(Properties);\n                    var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n                    $forEach(keys, function(key) {\n                        if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);\n                    });\n                    return O;\n                };\n                var $create = function create(O, Properties) {\n                    return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);\n                };\n                var $propertyIsEnumerable = function propertyIsEnumerable(V) {\n                    var P = toPropertyKey(V);\n                    var enumerable = nativePropertyIsEnumerable.call(this, P);\n                    if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;\n                    return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n                };\n                var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n                    var it = toIndexedObject(O);\n                    var key = toPropertyKey(P);\n                    if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;\n                    var descriptor = nativeGetOwnPropertyDescriptor(it, key);\n                    if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n                        descriptor.enumerable = true;\n                    }\n                    return descriptor;\n                };\n                var $getOwnPropertyNames = function getOwnPropertyNames(O) {\n                    var names = nativeGetOwnPropertyNames(toIndexedObject(O));\n                    var result = [];\n                    $forEach(names, function(key) {\n                        if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);\n                    });\n                    return result;\n                };\n                var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n                    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;\n                    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n                    var result = [];\n                    $forEach(names, function(key) {\n                        if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {\n                            result.push(AllSymbols[key]);\n                        }\n                    });\n                    return result;\n                };\n                // `Symbol` constructor\n                // https://tc39.es/ecma262/#sec-symbol-constructor\n                if (!NATIVE_SYMBOL) {\n                    $Symbol = function Symbol1() {\n                        if (this instanceof $Symbol) throw TypeError(\"Symbol is not a constructor\");\n                        var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);\n                        var tag = uid(description);\n                        var setter = function(value) {\n                            if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);\n                            if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n                            setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n                        };\n                        if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {\n                            configurable: true,\n                            set: setter\n                        });\n                        return wrap(tag, description);\n                    };\n                    redefine($Symbol[PROTOTYPE], \"toString\", function toString() {\n                        return getInternalState(this).tag;\n                    });\n                    redefine($Symbol, \"withoutSetter\", function(description) {\n                        return wrap(uid(description), description);\n                    });\n                    propertyIsEnumerableModule.f = $propertyIsEnumerable;\n                    definePropertyModule.f = $defineProperty;\n                    getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;\n                    getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n                    getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;\n                    wrappedWellKnownSymbolModule.f = function(name) {\n                        return wrap(wellKnownSymbol(name), name);\n                    };\n                    if (DESCRIPTORS) {\n                        // https://github.com/tc39/proposal-Symbol-description\n                        nativeDefineProperty($Symbol[PROTOTYPE], \"description\", {\n                            configurable: true,\n                            get: function description() {\n                                return getInternalState(this).description;\n                            }\n                        });\n                        if (!IS_PURE) {\n                            redefine(ObjectPrototype, \"propertyIsEnumerable\", $propertyIsEnumerable, {\n                                unsafe: true\n                            });\n                        }\n                    }\n                }\n                $({\n                    global: true,\n                    wrap: true,\n                    forced: !NATIVE_SYMBOL,\n                    sham: !NATIVE_SYMBOL\n                }, {\n                    Symbol: $Symbol\n                });\n                $forEach(objectKeys(WellKnownSymbolsStore), function(name) {\n                    defineWellKnownSymbol(name);\n                });\n                $({\n                    target: SYMBOL,\n                    stat: true,\n                    forced: !NATIVE_SYMBOL\n                }, {\n                    // `Symbol.for` method\n                    // https://tc39.es/ecma262/#sec-symbol.for\n                    \"for\": function(key) {\n                        var string = $toString(key);\n                        if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n                        var symbol = $Symbol(string);\n                        StringToSymbolRegistry[string] = symbol;\n                        SymbolToStringRegistry[symbol] = string;\n                        return symbol;\n                    },\n                    // `Symbol.keyFor` method\n                    // https://tc39.es/ecma262/#sec-symbol.keyfor\n                    keyFor: function keyFor(sym) {\n                        if (!isSymbol(sym)) throw TypeError(sym + \" is not a symbol\");\n                        if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n                    },\n                    useSetter: function() {\n                        USE_SETTER = true;\n                    },\n                    useSimple: function() {\n                        USE_SETTER = false;\n                    }\n                });\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: !NATIVE_SYMBOL,\n                    sham: !DESCRIPTORS\n                }, {\n                    // `Object.create` method\n                    // https://tc39.es/ecma262/#sec-object.create\n                    create: $create,\n                    // `Object.defineProperty` method\n                    // https://tc39.es/ecma262/#sec-object.defineproperty\n                    defineProperty: $defineProperty,\n                    // `Object.defineProperties` method\n                    // https://tc39.es/ecma262/#sec-object.defineproperties\n                    defineProperties: $defineProperties,\n                    // `Object.getOwnPropertyDescriptor` method\n                    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n                    getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n                });\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: !NATIVE_SYMBOL\n                }, {\n                    // `Object.getOwnPropertyNames` method\n                    // https://tc39.es/ecma262/#sec-object.getownpropertynames\n                    getOwnPropertyNames: $getOwnPropertyNames,\n                    // `Object.getOwnPropertySymbols` method\n                    // https://tc39.es/ecma262/#sec-object.getownpropertysymbols\n                    getOwnPropertySymbols: $getOwnPropertySymbols\n                });\n                // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n                // https://bugs.chromium.org/p/v8/issues/detail?id=3443\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: fails(function() {\n                        getOwnPropertySymbolsModule.f(1);\n                    })\n                }, {\n                    getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n                        return getOwnPropertySymbolsModule.f(toObject(it));\n                    }\n                });\n                // `JSON.stringify` method behavior with symbols\n                // https://tc39.es/ecma262/#sec-json.stringify\n                if ($stringify) {\n                    var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {\n                        var symbol = $Symbol();\n                        // MS Edge converts symbol values to JSON as {}\n                        return $stringify([\n                            symbol\n                        ]) != \"[null]\" || $stringify({\n                            a: symbol\n                        }) != \"{}\" || $stringify(Object(symbol)) != \"{}\";\n                    });\n                    $({\n                        target: \"JSON\",\n                        stat: true,\n                        forced: FORCED_JSON_STRINGIFY\n                    }, {\n                        // eslint-disable-next-line no-unused-vars -- required for `.length`\n                        stringify: function stringify(it, replacer, space) {\n                            var args = [\n                                it\n                            ];\n                            var index = 1;\n                            var $replacer;\n                            while(arguments.length > index)args.push(arguments[index++]);\n                            $replacer = replacer;\n                            if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n                            if (!isArray(replacer)) replacer = function(key, value) {\n                                if (typeof $replacer == \"function\") value = $replacer.call(this, key, value);\n                                if (!isSymbol(value)) return value;\n                            };\n                            args[1] = replacer;\n                            return $stringify.apply(null, args);\n                        }\n                    });\n                }\n                // `Symbol.prototype[@@toPrimitive]` method\n                // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\n                if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {\n                    createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n                }\n                // `Symbol.prototype[@@toStringTag]` property\n                // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\n                setToStringTag($Symbol, SYMBOL);\n                hiddenKeys[HIDDEN] = true;\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\": /*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!\n  \\**********************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_258228__) {\n                var global1 = __nested_webpack_require_258228__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var DOMIterables = __nested_webpack_require_258228__(/*! ../internals/dom-iterables */ \"./node_modules/core-js/internals/dom-iterables.js\");\n                var forEach = __nested_webpack_require_258228__(/*! ../internals/array-for-each */ \"./node_modules/core-js/internals/array-for-each.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_258228__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                for(var COLLECTION_NAME in DOMIterables){\n                    var Collection = global1[COLLECTION_NAME];\n                    var CollectionPrototype = Collection && Collection.prototype;\n                    // some Chrome versions have non-configurable methods on DOMTokenList\n                    if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {\n                        createNonEnumerableProperty(CollectionPrototype, \"forEach\", forEach);\n                    } catch (error) {\n                        CollectionPrototype.forEach = forEach;\n                    }\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\": /*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!\n  \\**********************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_259870__) {\n                var global1 = __nested_webpack_require_259870__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var DOMIterables = __nested_webpack_require_259870__(/*! ../internals/dom-iterables */ \"./node_modules/core-js/internals/dom-iterables.js\");\n                var ArrayIteratorMethods = __nested_webpack_require_259870__(/*! ../modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_259870__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var wellKnownSymbol = __nested_webpack_require_259870__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var ITERATOR = wellKnownSymbol(\"iterator\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                var ArrayValues = ArrayIteratorMethods.values;\n                for(var COLLECTION_NAME in DOMIterables){\n                    var Collection = global1[COLLECTION_NAME];\n                    var CollectionPrototype = Collection && Collection.prototype;\n                    if (CollectionPrototype) {\n                        // some Chrome versions have non-configurable methods on DOMTokenList\n                        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n                            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n                        } catch (error) {\n                            CollectionPrototype[ITERATOR] = ArrayValues;\n                        }\n                        if (!CollectionPrototype[TO_STRING_TAG]) {\n                            createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n                        }\n                        if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){\n                            // some Chrome versions have non-configurable methods on DOMTokenList\n                            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n                                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n                            } catch (error) {\n                                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n                            }\n                        }\n                    }\n                }\n            /***/ },\n            /***/ \"./node_modules/es6-promise/dist/es6-promise.js\": /*!******************************************************!*\\\n  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!\n  \\******************************************************/ /***/ function(module1) {\n                /*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */ (function(global1, factory) {\n                     true ? module1.exports = factory() : 0;\n                })(this, function() {\n                    \"use strict\";\n                    function objectOrFunction(x) {\n                        var type = typeof x;\n                        return x !== null && (type === \"object\" || type === \"function\");\n                    }\n                    function isFunction(x) {\n                        return typeof x === \"function\";\n                    }\n                    var _isArray = void 0;\n                    if (Array.isArray) {\n                        _isArray = Array.isArray;\n                    } else {\n                        _isArray = function(x) {\n                            return Object.prototype.toString.call(x) === \"[object Array]\";\n                        };\n                    }\n                    var isArray = _isArray;\n                    var len = 0;\n                    var vertxNext = void 0;\n                    var customSchedulerFn = void 0;\n                    var asap = function asap(callback, arg) {\n                        queue[len] = callback;\n                        queue[len + 1] = arg;\n                        len += 2;\n                        if (len === 2) {\n                            // If len is 2, that means that we need to schedule an async flush.\n                            // If additional callbacks are queued before the queue is flushed, they\n                            // will be processed by this flush that we are scheduling.\n                            if (customSchedulerFn) {\n                                customSchedulerFn(flush);\n                            } else {\n                                scheduleFlush();\n                            }\n                        }\n                    };\n                    function setScheduler(scheduleFn) {\n                        customSchedulerFn = scheduleFn;\n                    }\n                    function setAsap(asapFn) {\n                        asap = asapFn;\n                    }\n                    var browserWindow =  false ? 0 : undefined;\n                    var browserGlobal = browserWindow || {};\n                    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n                    var isNode = typeof self === \"undefined\" && typeof process !== \"undefined\" && ({}).toString.call(process) === \"[object process]\";\n                    // test for web worker but not in IE10\n                    var isWorker = typeof Uint8ClampedArray !== \"undefined\" && typeof importScripts !== \"undefined\" && typeof MessageChannel !== \"undefined\";\n                    // node\n                    function useNextTick() {\n                        // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n                        // see https://github.com/cujojs/when/issues/410 for details\n                        return function() {\n                            return process.nextTick(flush);\n                        };\n                    }\n                    // vertx\n                    function useVertxTimer() {\n                        if (typeof vertxNext !== \"undefined\") {\n                            return function() {\n                                vertxNext(flush);\n                            };\n                        }\n                        return useSetTimeout();\n                    }\n                    function useMutationObserver() {\n                        var iterations = 0;\n                        var observer = new BrowserMutationObserver(flush);\n                        var node = document.createTextNode(\"\");\n                        observer.observe(node, {\n                            characterData: true\n                        });\n                        return function() {\n                            node.data = iterations = ++iterations % 2;\n                        };\n                    }\n                    // web worker\n                    function useMessageChannel() {\n                        var channel = new MessageChannel();\n                        channel.port1.onmessage = flush;\n                        return function() {\n                            return channel.port2.postMessage(0);\n                        };\n                    }\n                    function useSetTimeout() {\n                        // Store setTimeout reference so es6-promise will be unaffected by\n                        // other code modifying setTimeout (like sinon.useFakeTimers())\n                        var globalSetTimeout = setTimeout;\n                        return function() {\n                            return globalSetTimeout(flush, 1);\n                        };\n                    }\n                    var queue = new Array(1000);\n                    function flush() {\n                        for(var i = 0; i < len; i += 2){\n                            var callback = queue[i];\n                            var arg = queue[i + 1];\n                            callback(arg);\n                            queue[i] = undefined;\n                            queue[i + 1] = undefined;\n                        }\n                        len = 0;\n                    }\n                    function attemptVertx() {\n                        try {\n                            var vertx = Function(\"return this\")().require(\"vertx\");\n                            vertxNext = vertx.runOnLoop || vertx.runOnContext;\n                            return useVertxTimer();\n                        } catch (e) {\n                            return useSetTimeout();\n                        }\n                    }\n                    var scheduleFlush = void 0;\n                    // Decide what async method to use to triggering processing of queued callbacks:\n                    if (isNode) {\n                        scheduleFlush = useNextTick();\n                    } else if (BrowserMutationObserver) {\n                        scheduleFlush = useMutationObserver();\n                    } else if (isWorker) {\n                        scheduleFlush = useMessageChannel();\n                    } else if (browserWindow === undefined && \"function\" === \"function\") {\n                        scheduleFlush = attemptVertx();\n                    } else {\n                        scheduleFlush = useSetTimeout();\n                    }\n                    function then(onFulfillment, onRejection) {\n                        var parent = this;\n                        var child = new this.constructor(noop);\n                        if (child[PROMISE_ID] === undefined) {\n                            makePromise(child);\n                        }\n                        var _state = parent._state;\n                        if (_state) {\n                            var callback = arguments[_state - 1];\n                            asap(function() {\n                                return invokeCallback(_state, child, callback, parent._result);\n                            });\n                        } else {\n                            subscribe(parent, child, onFulfillment, onRejection);\n                        }\n                        return child;\n                    }\n                    /**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/ function resolve$1(object) {\n                        /*jshint validthis:true */ var Constructor = this;\n                        if (object && typeof object === \"object\" && object.constructor === Constructor) {\n                            return object;\n                        }\n                        var promise = new Constructor(noop);\n                        resolve(promise, object);\n                        return promise;\n                    }\n                    var PROMISE_ID = Math.random().toString(36).substring(2);\n                    function noop() {}\n                    var PENDING = void 0;\n                    var FULFILLED = 1;\n                    var REJECTED = 2;\n                    function selfFulfillment() {\n                        return new TypeError(\"You cannot resolve a promise with itself\");\n                    }\n                    function cannotReturnOwn() {\n                        return new TypeError(\"A promises callback cannot return that same promise.\");\n                    }\n                    function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n                        try {\n                            then$$1.call(value, fulfillmentHandler, rejectionHandler);\n                        } catch (e) {\n                            return e;\n                        }\n                    }\n                    function handleForeignThenable(promise, thenable, then$$1) {\n                        asap(function(promise) {\n                            var sealed = false;\n                            var error = tryThen(then$$1, thenable, function(value) {\n                                if (sealed) {\n                                    return;\n                                }\n                                sealed = true;\n                                if (thenable !== value) {\n                                    resolve(promise, value);\n                                } else {\n                                    fulfill(promise, value);\n                                }\n                            }, function(reason) {\n                                if (sealed) {\n                                    return;\n                                }\n                                sealed = true;\n                                reject(promise, reason);\n                            }, \"Settle: \" + (promise._label || \" unknown promise\"));\n                            if (!sealed && error) {\n                                sealed = true;\n                                reject(promise, error);\n                            }\n                        }, promise);\n                    }\n                    function handleOwnThenable(promise, thenable) {\n                        if (thenable._state === FULFILLED) {\n                            fulfill(promise, thenable._result);\n                        } else if (thenable._state === REJECTED) {\n                            reject(promise, thenable._result);\n                        } else {\n                            subscribe(thenable, undefined, function(value) {\n                                return resolve(promise, value);\n                            }, function(reason) {\n                                return reject(promise, reason);\n                            });\n                        }\n                    }\n                    function handleMaybeThenable(promise, maybeThenable, then$$1) {\n                        if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n                            handleOwnThenable(promise, maybeThenable);\n                        } else {\n                            if (then$$1 === undefined) {\n                                fulfill(promise, maybeThenable);\n                            } else if (isFunction(then$$1)) {\n                                handleForeignThenable(promise, maybeThenable, then$$1);\n                            } else {\n                                fulfill(promise, maybeThenable);\n                            }\n                        }\n                    }\n                    function resolve(promise, value) {\n                        if (promise === value) {\n                            reject(promise, selfFulfillment());\n                        } else if (objectOrFunction(value)) {\n                            var then$$1 = void 0;\n                            try {\n                                then$$1 = value.then;\n                            } catch (error) {\n                                reject(promise, error);\n                                return;\n                            }\n                            handleMaybeThenable(promise, value, then$$1);\n                        } else {\n                            fulfill(promise, value);\n                        }\n                    }\n                    function publishRejection(promise) {\n                        if (promise._onerror) {\n                            promise._onerror(promise._result);\n                        }\n                        publish(promise);\n                    }\n                    function fulfill(promise, value) {\n                        if (promise._state !== PENDING) {\n                            return;\n                        }\n                        promise._result = value;\n                        promise._state = FULFILLED;\n                        if (promise._subscribers.length !== 0) {\n                            asap(publish, promise);\n                        }\n                    }\n                    function reject(promise, reason) {\n                        if (promise._state !== PENDING) {\n                            return;\n                        }\n                        promise._state = REJECTED;\n                        promise._result = reason;\n                        asap(publishRejection, promise);\n                    }\n                    function subscribe(parent, child, onFulfillment, onRejection) {\n                        var _subscribers = parent._subscribers;\n                        var length = _subscribers.length;\n                        parent._onerror = null;\n                        _subscribers[length] = child;\n                        _subscribers[length + FULFILLED] = onFulfillment;\n                        _subscribers[length + REJECTED] = onRejection;\n                        if (length === 0 && parent._state) {\n                            asap(publish, parent);\n                        }\n                    }\n                    function publish(promise) {\n                        var subscribers = promise._subscribers;\n                        var settled = promise._state;\n                        if (subscribers.length === 0) {\n                            return;\n                        }\n                        var child = void 0, callback = void 0, detail = promise._result;\n                        for(var i = 0; i < subscribers.length; i += 3){\n                            child = subscribers[i];\n                            callback = subscribers[i + settled];\n                            if (child) {\n                                invokeCallback(settled, child, callback, detail);\n                            } else {\n                                callback(detail);\n                            }\n                        }\n                        promise._subscribers.length = 0;\n                    }\n                    function invokeCallback(settled, promise, callback, detail) {\n                        var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = true;\n                        if (hasCallback) {\n                            try {\n                                value = callback(detail);\n                            } catch (e) {\n                                succeeded = false;\n                                error = e;\n                            }\n                            if (promise === value) {\n                                reject(promise, cannotReturnOwn());\n                                return;\n                            }\n                        } else {\n                            value = detail;\n                        }\n                        if (promise._state !== PENDING) {\n                        // noop\n                        } else if (hasCallback && succeeded) {\n                            resolve(promise, value);\n                        } else if (succeeded === false) {\n                            reject(promise, error);\n                        } else if (settled === FULFILLED) {\n                            fulfill(promise, value);\n                        } else if (settled === REJECTED) {\n                            reject(promise, value);\n                        }\n                    }\n                    function initializePromise(promise, resolver) {\n                        try {\n                            resolver(function resolvePromise(value) {\n                                resolve(promise, value);\n                            }, function rejectPromise(reason) {\n                                reject(promise, reason);\n                            });\n                        } catch (e) {\n                            reject(promise, e);\n                        }\n                    }\n                    var id = 0;\n                    function nextId() {\n                        return id++;\n                    }\n                    function makePromise(promise) {\n                        promise[PROMISE_ID] = id++;\n                        promise._state = undefined;\n                        promise._result = undefined;\n                        promise._subscribers = [];\n                    }\n                    function validationError() {\n                        return new Error(\"Array Methods must be provided an Array\");\n                    }\n                    var Enumerator = function() {\n                        function Enumerator(Constructor, input) {\n                            this._instanceConstructor = Constructor;\n                            this.promise = new Constructor(noop);\n                            if (!this.promise[PROMISE_ID]) {\n                                makePromise(this.promise);\n                            }\n                            if (isArray(input)) {\n                                this.length = input.length;\n                                this._remaining = input.length;\n                                this._result = new Array(this.length);\n                                if (this.length === 0) {\n                                    fulfill(this.promise, this._result);\n                                } else {\n                                    this.length = this.length || 0;\n                                    this._enumerate(input);\n                                    if (this._remaining === 0) {\n                                        fulfill(this.promise, this._result);\n                                    }\n                                }\n                            } else {\n                                reject(this.promise, validationError());\n                            }\n                        }\n                        Enumerator.prototype._enumerate = function _enumerate(input) {\n                            for(var i = 0; this._state === PENDING && i < input.length; i++){\n                                this._eachEntry(input[i], i);\n                            }\n                        };\n                        Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n                            var c = this._instanceConstructor;\n                            var resolve$$1 = c.resolve;\n                            if (resolve$$1 === resolve$1) {\n                                var _then = void 0;\n                                var error = void 0;\n                                var didError = false;\n                                try {\n                                    _then = entry.then;\n                                } catch (e) {\n                                    didError = true;\n                                    error = e;\n                                }\n                                if (_then === then && entry._state !== PENDING) {\n                                    this._settledAt(entry._state, i, entry._result);\n                                } else if (typeof _then !== \"function\") {\n                                    this._remaining--;\n                                    this._result[i] = entry;\n                                } else if (c === Promise$1) {\n                                    var promise = new c(noop);\n                                    if (didError) {\n                                        reject(promise, error);\n                                    } else {\n                                        handleMaybeThenable(promise, entry, _then);\n                                    }\n                                    this._willSettleAt(promise, i);\n                                } else {\n                                    this._willSettleAt(new c(function(resolve$$1) {\n                                        return resolve$$1(entry);\n                                    }), i);\n                                }\n                            } else {\n                                this._willSettleAt(resolve$$1(entry), i);\n                            }\n                        };\n                        Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n                            var promise = this.promise;\n                            if (promise._state === PENDING) {\n                                this._remaining--;\n                                if (state === REJECTED) {\n                                    reject(promise, value);\n                                } else {\n                                    this._result[i] = value;\n                                }\n                            }\n                            if (this._remaining === 0) {\n                                fulfill(promise, this._result);\n                            }\n                        };\n                        Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n                            var enumerator = this;\n                            subscribe(promise, undefined, function(value) {\n                                return enumerator._settledAt(FULFILLED, i, value);\n                            }, function(reason) {\n                                return enumerator._settledAt(REJECTED, i, reason);\n                            });\n                        };\n                        return Enumerator;\n                    }();\n                    /**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/ function all(entries) {\n                        return new Enumerator(this, entries).promise;\n                    }\n                    /**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/ function race(entries) {\n                        /*jshint validthis:true */ var Constructor = this;\n                        if (!isArray(entries)) {\n                            return new Constructor(function(_, reject) {\n                                return reject(new TypeError(\"You must pass an array to race.\"));\n                            });\n                        } else {\n                            return new Constructor(function(resolve, reject) {\n                                var length = entries.length;\n                                for(var i = 0; i < length; i++){\n                                    Constructor.resolve(entries[i]).then(resolve, reject);\n                                }\n                            });\n                        }\n                    }\n                    /**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/ function reject$1(reason) {\n                        /*jshint validthis:true */ var Constructor = this;\n                        var promise = new Constructor(noop);\n                        reject(promise, reason);\n                        return promise;\n                    }\n                    function needsResolver() {\n                        throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\");\n                    }\n                    function needsNew() {\n                        throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n                    }\n                    /**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/ var Promise$1 = function() {\n                        function Promise(resolver) {\n                            this[PROMISE_ID] = nextId();\n                            this._result = this._state = undefined;\n                            this._subscribers = [];\n                            if (noop !== resolver) {\n                                typeof resolver !== \"function\" && needsResolver();\n                                this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n                            }\n                        }\n                        /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */ /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */ Promise.prototype.catch = function _catch(onRejection) {\n                            return this.then(null, onRejection);\n                        };\n                        /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */ Promise.prototype.finally = function _finally(callback) {\n                            var promise = this;\n                            var constructor = promise.constructor;\n                            if (isFunction(callback)) {\n                                return promise.then(function(value) {\n                                    return constructor.resolve(callback()).then(function() {\n                                        return value;\n                                    });\n                                }, function(reason) {\n                                    return constructor.resolve(callback()).then(function() {\n                                        throw reason;\n                                    });\n                                });\n                            }\n                            return promise.then(callback, callback);\n                        };\n                        return Promise;\n                    }();\n                    Promise$1.prototype.then = then;\n                    Promise$1.all = all;\n                    Promise$1.race = race;\n                    Promise$1.resolve = resolve$1;\n                    Promise$1.reject = reject$1;\n                    Promise$1._setScheduler = setScheduler;\n                    Promise$1._setAsap = setAsap;\n                    Promise$1._asap = asap;\n                    /*global self*/ function polyfill() {\n                        var local = void 0;\n                        if (typeof global !== \"undefined\") {\n                            local = global;\n                        } else if (typeof self !== \"undefined\") {\n                            local = self;\n                        } else {\n                            try {\n                                local = Function(\"return this\")();\n                            } catch (e) {\n                                throw new Error(\"polyfill failed because global object is unavailable in this environment\");\n                            }\n                        }\n                        var P = local.Promise;\n                        if (P) {\n                            var promiseToString = null;\n                            try {\n                                promiseToString = Object.prototype.toString.call(P.resolve());\n                            } catch (e) {\n                            // silently ignored\n                            }\n                            if (promiseToString === \"[object Promise]\" && !P.cast) {\n                                return;\n                            }\n                        }\n                        local.Promise = Promise$1;\n                    }\n                    // Strange compat..\n                    Promise$1.polyfill = polyfill;\n                    Promise$1.Promise = Promise$1;\n                    return Promise$1;\n                });\n            //# sourceMappingURL=es6-promise.map\n            /***/ },\n            /***/ \"html2canvas\": /*!******************************!*\\\n  !*** external \"html2canvas\" ***!\n  \\******************************/ /***/ function(module1) {\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_html2canvas__;\n            /***/ },\n            /***/ \"jspdf\": /*!************************!*\\\n  !*** external \"jspdf\" ***!\n  \\************************/ /***/ function(module1) {\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_jspdf__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_304581__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_304581__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ !function() {\n            /******/ // getDefaultExport function for compatibility with non-harmony modules\n            /******/ __nested_webpack_require_304581__.n = function(module1) {\n                /******/ var getter = module1 && module1.__esModule ? /******/ function() {\n                    return module1[\"default\"];\n                } : /******/ function() {\n                    return module1;\n                };\n                /******/ __nested_webpack_require_304581__.d(getter, {\n                    a: getter\n                });\n                /******/ return getter;\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/define property getters */ /******/ !function() {\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_304581__.d = function(exports1, definition) {\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_304581__.o(definition, key) && !__nested_webpack_require_304581__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ !function() {\n            /******/ __nested_webpack_require_304581__.o = function(obj, prop) {\n                return Object.prototype.hasOwnProperty.call(obj, prop);\n            };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ !function() {\n            /******/ // define __esModule on exports\n            /******/ __nested_webpack_require_304581__.r = function(exports1) {\n                /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                        value: \"Module\"\n                    });\n                /******/ }\n                /******/ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /******/ };\n        /******/ }();\n        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};\n        // This entry need to be wrapped in an IIFE because it need to be in strict mode.\n        !function() {\n            \"use strict\";\n            /*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/ __nested_webpack_require_304581__.r(__nested_webpack_exports__);\n            /* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_304581__(/*! ./worker.js */ \"./src/worker.js\");\n            /* harmony import */ var _plugin_jspdf_plugin_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_304581__(/*! ./plugin/jspdf-plugin.js */ \"./src/plugin/jspdf-plugin.js\");\n            /* harmony import */ var _plugin_pagebreaks_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_304581__(/*! ./plugin/pagebreaks.js */ \"./src/plugin/pagebreaks.js\");\n            /* harmony import */ var _plugin_hyperlinks_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_304581__(/*! ./plugin/hyperlinks.js */ \"./src/plugin/hyperlinks.js\");\n            /**\n * Generate a PDF from an HTML element or string using html2canvas and jsPDF.\n *\n * @param {Element|string} source The source element or HTML string.\n * @param {Object=} opt An object of optional settings: 'margin', 'filename',\n *    'image' ('type' and 'quality'), and 'html2canvas' / 'jspdf', which are\n *    sent as settings to their corresponding functions.\n */ var html2pdf = function html2pdf(src, opt) {\n                // Create a new worker with the given options.\n                var worker = new html2pdf.Worker(opt);\n                if (src) {\n                    // If src is specified, perform the traditional 'simple' operation.\n                    return worker.from(src).save();\n                } else {\n                    // Otherwise, return the worker for new Promise-based operation.\n                    return worker;\n                }\n            };\n            html2pdf.Worker = _worker_js__WEBPACK_IMPORTED_MODULE_0__.default; // Expose the html2pdf function.\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = html2pdf;\n        }();\n        __nested_webpack_exports__ = __nested_webpack_exports__.default;\n        /******/ return __nested_webpack_exports__;\n    /******/ }();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDJwZGYuanMvZGlzdC9odG1sMnBkZi5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Q0FJQyxHQUNBLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsOERBQU8sR0FBR0EsbUJBQU9BLENBQUMsNkVBQWE7U0FDNUQsRUFLMkQ7QUFDakUsR0FBR0csTUFBTSxTQUFTQyxpQ0FBaUMsRUFBRUMsdUNBQXVDO0lBQzVGLE9BQWdCLE1BQUgsR0FBSTtRQUNqQixNQUFNLEdBQUksSUFBSUMsc0JBQXVCO1lBRXJDLEdBQUcsR0FBRyw4QkFDTjs7b0NBRW9DLEdBQ3BDLEdBQUcsR0FBSSxTQUFTQyx1QkFBdUIsRUFBRUMsMEJBQW1CLEVBQUVDLCtCQUFtQjtnQkFFakY7Z0JBQ0FBLCtCQUFtQkEsQ0FBQ0MsQ0FBQyxDQUFDRiwwQkFBbUJBO2dCQUN6QyxrQkFBa0IsR0FBRyxJQUFJRywrRUFBK0VGLCtCQUFtQkEsQ0FBQyxvREFBb0QsR0FBRztnQkFDbkwsa0JBQWtCLEdBQUcsSUFBSUcsdUZBQXVGLFdBQVcsR0FBRUgsK0JBQW1CQSxDQUFDSSxDQUFDLENBQUNGO2dCQUNuSixrQkFBa0IsR0FBRyxJQUFJRyxpRUFBaUVMLCtCQUFtQkEsQ0FBQyxzQ0FBc0MsR0FBRztnQkFDdkosa0JBQWtCLEdBQUcsSUFBSU0seUVBQXlFLFdBQVcsR0FBRU4sK0JBQW1CQSxDQUFDSSxDQUFDLENBQUNDO2dCQUNySSxrQkFBa0IsR0FBRyxJQUFJRSwwQ0FBMENQLCtCQUFtQkEsQ0FBQyxpQkFBaUIsR0FBRztnQkFDM0csa0JBQWtCLEdBQUcsSUFBSVEseUNBQXlDUiwrQkFBbUJBLENBQUMsZ0JBQWdCLEdBQUc7Z0JBSXhHLG1EQUFtRDtnQkFDcEQsbURBQW1EO2dCQUVuRCxJQUFJUyxXQUFXLEVBQUU7Z0JBQ2pCLElBQUlDLE9BQU87b0JB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O1lBRUFELFNBQVMvckIsTUFBTSxHQUFHMnJCLHdDQUF3Q2o1QixPQUFPLEVBQUUsZ0NBQWdDO1lBRW5HLDBCQUEwQixHQUFHYiwwQkFBbUIsQ0FBQyxVQUFVLEdBQUlrNkI7UUFDL0Q7UUFDQWw2QiwwQkFBbUJBLEdBQUdBLDBCQUFtQkEsQ0FBQ2EsT0FBTztRQUNqRCxNQUFNLEdBQUksT0FBT2IsMEJBQW1CQTtJQUNwQyxNQUFNLEdBQUc7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvaHRtbDJwZGYuanMvZGlzdC9odG1sMnBkZi5qcz84NTMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogaHRtbDJwZGYuanMgdjAuMTAuM1xuICogQ29weXJpZ2h0IChjKSAyMDI1IEVyaWsgS29vcG1hbnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwianNwZGZcIiksIHJlcXVpcmUoXCJodG1sMmNhbnZhc1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcImh0bWwycGRmXCIsIFtcImpzcGRmXCIsIFwiaHRtbDJjYW52YXNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiaHRtbDJwZGZcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJqc3BkZlwiKSwgcmVxdWlyZShcImh0bWwyY2FudmFzXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJodG1sMnBkZlwiXSA9IGZhY3Rvcnkocm9vdFtcImpzcGRmXCJdLCByb290W1wiaHRtbDJjYW52YXNcIl0pO1xufSkoc2VsZiwgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9qc3BkZl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2h0bWwyY2FudmFzX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vc3JjL3BsdWdpbi9oeXBlcmxpbmtzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BsdWdpbi9oeXBlcmxpbmtzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19saW5rX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmxpbmsuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmxpbmsuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19saW5rX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19saW5rX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3dvcmtlci5qcyAqLyBcIi4vc3JjL3dvcmtlci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG5cblxuXG4gLy8gQWRkIGh5cGVybGluayBmdW5jdGlvbmFsaXR5IHRvIHRoZSBQREYgY3JlYXRpb24uXG4vLyBNYWluIGxpbmsgYXJyYXksIGFuZCByZWZzIHRvIG9yaWdpbmFsIGZ1bmN0aW9ucy5cblxudmFyIGxpbmtJbmZvID0gW107XG52YXIgb3JpZyA9IHtcbiAgdG9Db250YWluZXI6IF93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5kZWZhdWx0LnByb3RvdHlwZS50b0NvbnRhaW5lcixcbiAgdG9QZGY6IF93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5kZWZhdWx0LnByb3RvdHlwZS50b1BkZlxufTtcblxuX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQucHJvdG90eXBlLnRvQ29udGFpbmVyID0gZnVuY3Rpb24gdG9Db250YWluZXIoKSB7XG4gIHJldHVybiBvcmlnLnRvQ29udGFpbmVyLmNhbGwodGhpcykudGhlbihmdW5jdGlvbiB0b0NvbnRhaW5lcl9oeXBlcmxpbmsoKSB7XG4gICAgLy8gUmV0cmlldmUgaHlwZXJsaW5rIGluZm8gaWYgdGhlIG9wdGlvbiBpcyBlbmFibGVkLlxuICAgIGlmICh0aGlzLm9wdC5lbmFibGVMaW5rcykge1xuICAgICAgLy8gRmluZCBhbGwgYW5jaG9yIHRhZ3MgYW5kIGdldCB0aGUgY29udGFpbmVyJ3MgYm91bmRzIGZvciByZWZlcmVuY2UuXG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5wcm9wLmNvbnRhaW5lcjtcbiAgICAgIHZhciBsaW5rcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdhJyk7XG4gICAgICB2YXIgY29udGFpbmVyUmVjdCA9ICgwLF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLnVuaXRDb252ZXJ0KShjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRoaXMucHJvcC5wYWdlU2l6ZS5rKTtcbiAgICAgIGxpbmtJbmZvID0gW107IC8vIExvb3AgdGhyb3VnaCBlYWNoIGFuY2hvciB0YWcuXG5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobGlua3MsIGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgIC8vIFRyZWF0IGVhY2ggY2xpZW50IHJlY3QgYXMgYSBzZXBhcmF0ZSBsaW5rIChmb3IgdGV4dC13cmFwcGluZykuXG4gICAgICAgIHZhciBjbGllbnRSZWN0cyA9IGxpbmsuZ2V0Q2xpZW50UmVjdHMoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaWVudFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNsaWVudFJlY3QgPSAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy51bml0Q29udmVydCkoY2xpZW50UmVjdHNbaV0sIHRoaXMucHJvcC5wYWdlU2l6ZS5rKTtcbiAgICAgICAgICBjbGllbnRSZWN0LmxlZnQgLT0gY29udGFpbmVyUmVjdC5sZWZ0O1xuICAgICAgICAgIGNsaWVudFJlY3QudG9wIC09IGNvbnRhaW5lclJlY3QudG9wO1xuICAgICAgICAgIHZhciBwYWdlID0gTWF0aC5mbG9vcihjbGllbnRSZWN0LnRvcCAvIHRoaXMucHJvcC5wYWdlU2l6ZS5pbm5lci5oZWlnaHQpICsgMTtcbiAgICAgICAgICB2YXIgdG9wID0gdGhpcy5vcHQubWFyZ2luWzBdICsgY2xpZW50UmVjdC50b3AgJSB0aGlzLnByb3AucGFnZVNpemUuaW5uZXIuaGVpZ2h0O1xuICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5vcHQubWFyZ2luWzFdICsgY2xpZW50UmVjdC5sZWZ0O1xuICAgICAgICAgIGxpbmtJbmZvLnB1c2goe1xuICAgICAgICAgICAgcGFnZTogcGFnZSxcbiAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIGNsaWVudFJlY3Q6IGNsaWVudFJlY3QsXG4gICAgICAgICAgICBsaW5rOiBsaW5rXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5fd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uZGVmYXVsdC5wcm90b3R5cGUudG9QZGYgPSBmdW5jdGlvbiB0b1BkZigpIHtcbiAgcmV0dXJuIG9yaWcudG9QZGYuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIHRvUGRmX2h5cGVybGluaygpIHtcbiAgICAvLyBBZGQgaHlwZXJsaW5rcyBpZiB0aGUgb3B0aW9uIGlzIGVuYWJsZWQuXG4gICAgaWYgKHRoaXMub3B0LmVuYWJsZUxpbmtzKSB7XG4gICAgICAvLyBBdHRhY2ggZWFjaCBhbmNob3IgdGFnIGJhc2VkIG9uIGluZm8gZnJvbSB0b0NvbnRhaW5lcigpLlxuICAgICAgbGlua0luZm8uZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICB0aGlzLnByb3AucGRmLnNldFBhZ2UobC5wYWdlKTtcbiAgICAgICAgdGhpcy5wcm9wLnBkZi5saW5rKGwubGVmdCwgbC50b3AsIGwuY2xpZW50UmVjdC53aWR0aCwgbC5jbGllbnRSZWN0LmhlaWdodCwge1xuICAgICAgICAgIHVybDogbC5saW5rLmhyZWZcbiAgICAgICAgfSk7XG4gICAgICB9LCB0aGlzKTsgLy8gUmVzZXQgdGhlIGFjdGl2ZSBwYWdlIG9mIHRoZSBQREYgdG8gdGhlIGZpbmFsIHBhZ2UuXG5cbiAgICAgIHZhciBuUGFnZXMgPSB0aGlzLnByb3AucGRmLmludGVybmFsLmdldE51bWJlck9mUGFnZXMoKTtcbiAgICAgIHRoaXMucHJvcC5wZGYuc2V0UGFnZShuUGFnZXMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wbHVnaW4vanNwZGYtcGx1Z2luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGx1Z2luL2pzcGRmLXBsdWdpbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpzcGRmICovIFwianNwZGZcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fKTtcblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8vIEltcG9ydCBkZXBlbmRlbmNpZXMuXG4gLy8gR2V0IGRpbWVuc2lvbnMgb2YgYSBQREYgcGFnZSwgYXMgZGV0ZXJtaW5lZCBieSBqc1BERi5cblxuanNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5qc1BERi5nZXRQYWdlU2l6ZSA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbiwgdW5pdCwgZm9ybWF0KSB7XG4gIC8vIERlY29kZSBvcHRpb25zIG9iamVjdFxuICBpZiAoX3R5cGVvZihvcmllbnRhdGlvbikgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcmllbnRhdGlvbjtcbiAgICBvcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb247XG4gICAgdW5pdCA9IG9wdGlvbnMudW5pdCB8fCB1bml0O1xuICAgIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGZvcm1hdDtcbiAgfSAvLyBEZWZhdWx0IG9wdGlvbnNcblxuXG4gIHVuaXQgPSB1bml0IHx8ICdtbSc7XG4gIGZvcm1hdCA9IGZvcm1hdCB8fCAnYTQnO1xuICBvcmllbnRhdGlvbiA9ICgnJyArIChvcmllbnRhdGlvbiB8fCAnUCcpKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgZm9ybWF0X2FzX3N0cmluZyA9ICgnJyArIGZvcm1hdCkudG9Mb3dlckNhc2UoKTsgLy8gU2l6ZSBpbiBwdCBvZiB2YXJpb3VzIHBhcGVyIGZvcm1hdHNcblxuICB2YXIgcGFnZUZvcm1hdHMgPSB7XG4gICAgJ2EwJzogWzIzODMuOTQsIDMzNzAuMzldLFxuICAgICdhMSc6IFsxNjgzLjc4LCAyMzgzLjk0XSxcbiAgICAnYTInOiBbMTE5MC41NSwgMTY4My43OF0sXG4gICAgJ2EzJzogWzg0MS44OSwgMTE5MC41NV0sXG4gICAgJ2E0JzogWzU5NS4yOCwgODQxLjg5XSxcbiAgICAnYTUnOiBbNDE5LjUzLCA1OTUuMjhdLFxuICAgICdhNic6IFsyOTcuNjQsIDQxOS41M10sXG4gICAgJ2E3JzogWzIwOS43NiwgMjk3LjY0XSxcbiAgICAnYTgnOiBbMTQ3LjQwLCAyMDkuNzZdLFxuICAgICdhOSc6IFsxMDQuODgsIDE0Ny40MF0sXG4gICAgJ2ExMCc6IFs3My43MCwgMTA0Ljg4XSxcbiAgICAnYjAnOiBbMjgzNC42NSwgNDAwOC4xOV0sXG4gICAgJ2IxJzogWzIwMDQuMDksIDI4MzQuNjVdLFxuICAgICdiMic6IFsxNDE3LjMyLCAyMDA0LjA5XSxcbiAgICAnYjMnOiBbMTAwMC42MywgMTQxNy4zMl0sXG4gICAgJ2I0JzogWzcwOC42NiwgMTAwMC42M10sXG4gICAgJ2I1JzogWzQ5OC45MCwgNzA4LjY2XSxcbiAgICAnYjYnOiBbMzU0LjMzLCA0OTguOTBdLFxuICAgICdiNyc6IFsyNDkuNDUsIDM1NC4zM10sXG4gICAgJ2I4JzogWzE3NS43NSwgMjQ5LjQ1XSxcbiAgICAnYjknOiBbMTI0LjcyLCAxNzUuNzVdLFxuICAgICdiMTAnOiBbODcuODcsIDEyNC43Ml0sXG4gICAgJ2MwJzogWzI1OTkuMzcsIDM2NzYuNTRdLFxuICAgICdjMSc6IFsxODM2Ljg1LCAyNTk5LjM3XSxcbiAgICAnYzInOiBbMTI5OC4yNywgMTgzNi44NV0sXG4gICAgJ2MzJzogWzkxOC40MywgMTI5OC4yN10sXG4gICAgJ2M0JzogWzY0OS4xMywgOTE4LjQzXSxcbiAgICAnYzUnOiBbNDU5LjIxLCA2NDkuMTNdLFxuICAgICdjNic6IFszMjMuMTUsIDQ1OS4yMV0sXG4gICAgJ2M3JzogWzIyOS42MSwgMzIzLjE1XSxcbiAgICAnYzgnOiBbMTYxLjU3LCAyMjkuNjFdLFxuICAgICdjOSc6IFsxMTMuMzksIDE2MS41N10sXG4gICAgJ2MxMCc6IFs3OS4zNywgMTEzLjM5XSxcbiAgICAnZGwnOiBbMzExLjgxLCA2MjMuNjJdLFxuICAgICdsZXR0ZXInOiBbNjEyLCA3OTJdLFxuICAgICdnb3Zlcm5tZW50LWxldHRlcic6IFs1NzYsIDc1Nl0sXG4gICAgJ2xlZ2FsJzogWzYxMiwgMTAwOF0sXG4gICAgJ2p1bmlvci1sZWdhbCc6IFs1NzYsIDM2MF0sXG4gICAgJ2xlZGdlcic6IFsxMjI0LCA3OTJdLFxuICAgICd0YWJsb2lkJzogWzc5MiwgMTIyNF0sXG4gICAgJ2NyZWRpdC1jYXJkJzogWzE1MywgMjQzXVxuICB9OyAvLyBVbml0IGNvbnZlcnNpb25cblxuICBzd2l0Y2ggKHVuaXQpIHtcbiAgICBjYXNlICdwdCc6XG4gICAgICB2YXIgayA9IDE7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21tJzpcbiAgICAgIHZhciBrID0gNzIgLyAyNS40O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjbSc6XG4gICAgICB2YXIgayA9IDcyIC8gMi41NDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW4nOlxuICAgICAgdmFyIGsgPSA3MjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHgnOlxuICAgICAgdmFyIGsgPSA3MiAvIDk2O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYyc6XG4gICAgICB2YXIgayA9IDEyO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdlbSc6XG4gICAgICB2YXIgayA9IDEyO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdleCc6XG4gICAgICB2YXIgayA9IDY7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyAnSW52YWxpZCB1bml0OiAnICsgdW5pdDtcbiAgfSAvLyBEaW1lbnNpb25zIGFyZSBzdG9yZWQgYXMgdXNlciB1bml0cyBhbmQgY29udmVydGVkIHRvIHBvaW50cyBvbiBvdXRwdXRcblxuXG4gIGlmIChwYWdlRm9ybWF0cy5oYXNPd25Qcm9wZXJ0eShmb3JtYXRfYXNfc3RyaW5nKSkge1xuICAgIHZhciBwYWdlSGVpZ2h0ID0gcGFnZUZvcm1hdHNbZm9ybWF0X2FzX3N0cmluZ11bMV0gLyBrO1xuICAgIHZhciBwYWdlV2lkdGggPSBwYWdlRm9ybWF0c1tmb3JtYXRfYXNfc3RyaW5nXVswXSAvIGs7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwYWdlSGVpZ2h0ID0gZm9ybWF0WzFdO1xuICAgICAgdmFyIHBhZ2VXaWR0aCA9IGZvcm1hdFswXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQ6ICcgKyBmb3JtYXQpO1xuICAgIH1cbiAgfSAvLyBIYW5kbGUgcGFnZSBvcmllbnRhdGlvblxuXG5cbiAgaWYgKG9yaWVudGF0aW9uID09PSAncCcgfHwgb3JpZW50YXRpb24gPT09ICdwb3J0cmFpdCcpIHtcbiAgICBvcmllbnRhdGlvbiA9ICdwJztcblxuICAgIGlmIChwYWdlV2lkdGggPiBwYWdlSGVpZ2h0KSB7XG4gICAgICB2YXIgdG1wID0gcGFnZVdpZHRoO1xuICAgICAgcGFnZVdpZHRoID0gcGFnZUhlaWdodDtcbiAgICAgIHBhZ2VIZWlnaHQgPSB0bXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSAnbCcgfHwgb3JpZW50YXRpb24gPT09ICdsYW5kc2NhcGUnKSB7XG4gICAgb3JpZW50YXRpb24gPSAnbCc7XG5cbiAgICBpZiAocGFnZUhlaWdodCA+IHBhZ2VXaWR0aCkge1xuICAgICAgdmFyIHRtcCA9IHBhZ2VXaWR0aDtcbiAgICAgIHBhZ2VXaWR0aCA9IHBhZ2VIZWlnaHQ7XG4gICAgICBwYWdlSGVpZ2h0ID0gdG1wO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyAnSW52YWxpZCBvcmllbnRhdGlvbjogJyArIG9yaWVudGF0aW9uO1xuICB9IC8vIFJldHVybiBpbmZvcm1hdGlvbiAoayBpcyB0aGUgdW5pdCBjb252ZXJzaW9uIHJhdGlvIGZyb20gcHRzKVxuXG5cbiAgdmFyIGluZm8gPSB7XG4gICAgJ3dpZHRoJzogcGFnZVdpZHRoLFxuICAgICdoZWlnaHQnOiBwYWdlSGVpZ2h0LFxuICAgICd1bml0JzogdW5pdCxcbiAgICAnayc6IGtcbiAgfTtcbiAgcmV0dXJuIGluZm87XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGpzcGRmX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18uanNQREYpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wbHVnaW4vcGFnZWJyZWFrcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9wbHVnaW4vcGFnZWJyZWFrcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfc2xpY2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfc2xpY2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfc2xpY2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2pvaW5fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2pvaW5fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfam9pbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3Rfa2V5c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3Rfa2V5c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19vYmplY3Rfa2V5c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi93b3JrZXIuanMgKi8gXCIuL3NyYy93b3JrZXIuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy5qcyAqLyBcIi4vc3JjL3V0aWxzLmpzXCIpO1xuXG5cblxuXG5cblxuXG4vKiBQYWdlYnJlYWsgcGx1Z2luOlxuXG4gICAgQWRkcyBwYWdlLWJyZWFrIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIGh0bWwycGRmIGxpYnJhcnkuIFBhZ2UtYnJlYWtzIGNhbiBiZVxuICAgIGVuYWJsZWQgYnkgQ1NTIHN0eWxlcywgc2V0IG9uIGluZGl2aWR1YWwgZWxlbWVudHMgdXNpbmcgc2VsZWN0b3JzLCBvclxuICAgIGF2b2lkZWQgZnJvbSBicmVha2luZyBpbnNpZGUgYWxsIGVsZW1lbnRzLlxuXG4gICAgT3B0aW9ucyBvbiB0aGUgYG9wdC5wYWdlYnJlYWtgIG9iamVjdDpcblxuICAgIG1vZGU6ICAgU3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3M6ICdhdm9pZC1hbGwnLCAnY3NzJywgYW5kL29yICdsZWdhY3knXG4gICAgICAgICAgICBEZWZhdWx0OiBbJ2NzcycsICdsZWdhY3knXVxuXG4gICAgYmVmb3JlOiBTdHJpbmcgb3IgYXJyYXkgb2YgQ1NTIHNlbGVjdG9ycyBmb3Igd2hpY2ggdG8gYWRkIHBhZ2UtYnJlYWtzXG4gICAgICAgICAgICBiZWZvcmUgZWFjaCBlbGVtZW50LiBDYW4gYmUgYSBzcGVjaWZpYyBlbGVtZW50IHdpdGggYW4gSURcbiAgICAgICAgICAgICgnI215SUQnKSwgYWxsIGVsZW1lbnRzIG9mIGEgdHlwZSAoZS5nLiAnaW1nJyksIGFsbCBvZiBhIGNsYXNzXG4gICAgICAgICAgICAoJy5teUNsYXNzJyksIG9yIGV2ZW4gJyonIHRvIG1hdGNoIGV2ZXJ5IGVsZW1lbnQuXG5cbiAgICBhZnRlcjogIExpa2UgJ2JlZm9yZScsIGJ1dCBhZGRzIGEgcGFnZS1icmVhayBpbW1lZGlhdGVseSBhZnRlciB0aGUgZWxlbWVudC5cblxuICAgIGF2b2lkOiAgTGlrZSAnYmVmb3JlJywgYnV0IGF2b2lkcyBwYWdlLWJyZWFrcyBvbiB0aGVzZSBlbGVtZW50cy4gWW91IGNhblxuICAgICAgICAgICAgZW5hYmxlIHRoaXMgZmVhdHVyZSBvbiBldmVyeSBlbGVtZW50IHVzaW5nIHRoZSAnYXZvaWQtYWxsJyBtb2RlLlxuKi9cbi8vIFJlZnMgdG8gb3JpZ2luYWwgZnVuY3Rpb25zLlxuXG52YXIgb3JpZyA9IHtcbiAgdG9Db250YWluZXI6IF93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5kZWZhdWx0LnByb3RvdHlwZS50b0NvbnRhaW5lclxufTsgLy8gQWRkIHBhZ2VicmVhayBkZWZhdWx0IG9wdGlvbnMgdG8gdGhlIFdvcmtlciB0ZW1wbGF0ZS5cblxuX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmRlZmF1bHQudGVtcGxhdGUub3B0LnBhZ2VicmVhayA9IHtcbiAgbW9kZTogWydjc3MnLCAnbGVnYWN5J10sXG4gIGJlZm9yZTogW10sXG4gIGFmdGVyOiBbXSxcbiAgYXZvaWQ6IFtdXG59O1xuXG5fd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uZGVmYXVsdC5wcm90b3R5cGUudG9Db250YWluZXIgPSBmdW5jdGlvbiB0b0NvbnRhaW5lcigpIHtcbiAgcmV0dXJuIG9yaWcudG9Db250YWluZXIuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIHRvQ29udGFpbmVyX3BhZ2VicmVhaygpIHtcbiAgICAvLyBTZXR1cCByb290IGVsZW1lbnQgYW5kIGlubmVyIHBhZ2UgaGVpZ2h0LlxuICAgIHZhciByb290ID0gdGhpcy5wcm9wLmNvbnRhaW5lcjtcbiAgICB2YXIgcHhQYWdlSGVpZ2h0ID0gdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLnB4LmhlaWdodDsgLy8gQ2hlY2sgYWxsIHJlcXVlc3RlZCBtb2Rlcy5cblxuICAgIHZhciBtb2RlU3JjID0gW10uY29uY2F0KHRoaXMub3B0LnBhZ2VicmVhay5tb2RlKTtcbiAgICB2YXIgbW9kZSA9IHtcbiAgICAgIGF2b2lkQWxsOiBtb2RlU3JjLmluZGV4T2YoJ2F2b2lkLWFsbCcpICE9PSAtMSxcbiAgICAgIGNzczogbW9kZVNyYy5pbmRleE9mKCdjc3MnKSAhPT0gLTEsXG4gICAgICBsZWdhY3k6IG1vZGVTcmMuaW5kZXhPZignbGVnYWN5JykgIT09IC0xXG4gICAgfTsgLy8gR2V0IGFycmF5cyBvZiBhbGwgZXhwbGljaXRseSByZXF1ZXN0ZWQgZWxlbWVudHMuXG5cbiAgICB2YXIgc2VsZWN0ID0ge307XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFsnYmVmb3JlJywgJ2FmdGVyJywgJ2F2b2lkJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgYWxsID0gbW9kZS5hdm9pZEFsbCAmJiBrZXkgPT09ICdhdm9pZCc7XG4gICAgICBzZWxlY3Rba2V5XSA9IGFsbCA/IFtdIDogW10uY29uY2F0KHNlbGYub3B0LnBhZ2VicmVha1trZXldIHx8IFtdKTtcblxuICAgICAgaWYgKHNlbGVjdFtrZXldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VsZWN0W2tleV0gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChyb290LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0W2tleV0uam9pbignLCAnKSkpO1xuICAgICAgfVxuICAgIH0pOyAvLyBHZXQgYWxsIGxlZ2FjeSBwYWdlLWJyZWFrIGVsZW1lbnRzLlxuXG4gICAgdmFyIGxlZ2FjeUVscyA9IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnLmh0bWwycGRmX19wYWdlLWJyZWFrJyk7XG4gICAgbGVnYWN5RWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGVnYWN5RWxzKTsgLy8gTG9vcCB0aHJvdWdoIGFsbCBlbGVtZW50cy5cblxuICAgIHZhciBlbHMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKTtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVscywgZnVuY3Rpb24gcGFnZWJyZWFrX2xvb3AoZWwpIHtcbiAgICAgIC8vIFNldHVwIHBhZ2VicmVhayBydWxlcyBiYXNlZCBvbiBsZWdhY3kgYW5kIGF2b2lkQWxsIG1vZGVzLlxuICAgICAgdmFyIHJ1bGVzID0ge1xuICAgICAgICBiZWZvcmU6IGZhbHNlLFxuICAgICAgICBhZnRlcjogbW9kZS5sZWdhY3kgJiYgbGVnYWN5RWxzLmluZGV4T2YoZWwpICE9PSAtMSxcbiAgICAgICAgYXZvaWQ6IG1vZGUuYXZvaWRBbGxcbiAgICAgIH07IC8vIEFkZCBydWxlcyBmb3IgY3NzIG1vZGUuXG5cbiAgICAgIGlmIChtb2RlLmNzcykge1xuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIGlzIHZhbGlkIHdpdGggaUZyYW1lcy5cbiAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpOyAvLyBUT0RPOiBIYW5kbGUgJ2xlZnQnIGFuZCAncmlnaHQnIGNvcnJlY3RseS5cbiAgICAgICAgLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yICdhdm9pZCcgb24gYnJlYWtCZWZvcmUvQWZ0ZXIuXG5cbiAgICAgICAgdmFyIGJyZWFrT3B0ID0gWydhbHdheXMnLCAncGFnZScsICdsZWZ0JywgJ3JpZ2h0J107XG4gICAgICAgIHZhciBhdm9pZE9wdCA9IFsnYXZvaWQnLCAnYXZvaWQtcGFnZSddO1xuICAgICAgICBydWxlcyA9IHtcbiAgICAgICAgICBiZWZvcmU6IHJ1bGVzLmJlZm9yZSB8fCBicmVha09wdC5pbmRleE9mKHN0eWxlLmJyZWFrQmVmb3JlIHx8IHN0eWxlLnBhZ2VCcmVha0JlZm9yZSkgIT09IC0xLFxuICAgICAgICAgIGFmdGVyOiBydWxlcy5hZnRlciB8fCBicmVha09wdC5pbmRleE9mKHN0eWxlLmJyZWFrQWZ0ZXIgfHwgc3R5bGUucGFnZUJyZWFrQWZ0ZXIpICE9PSAtMSxcbiAgICAgICAgICBhdm9pZDogcnVsZXMuYXZvaWQgfHwgYXZvaWRPcHQuaW5kZXhPZihzdHlsZS5icmVha0luc2lkZSB8fCBzdHlsZS5wYWdlQnJlYWtJbnNpZGUpICE9PSAtMVxuICAgICAgICB9O1xuICAgICAgfSAvLyBBZGQgcnVsZXMgZm9yIGV4cGxpY2l0IHJlcXVlc3RzLlxuXG5cbiAgICAgIE9iamVjdC5rZXlzKHJ1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcnVsZXNba2V5XSA9IHJ1bGVzW2tleV0gfHwgc2VsZWN0W2tleV0uaW5kZXhPZihlbCkgIT09IC0xO1xuICAgICAgfSk7IC8vIEdldCBlbGVtZW50IHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4uXG4gICAgICAvLyBUT0RPOiBTdWJ0cmFjdCB0aGUgdG9wIG9mIHRoZSBjb250YWluZXIgZnJvbSBjbGllbnRSZWN0LnRvcC9ib3R0b20/XG5cbiAgICAgIHZhciBjbGllbnRSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIEF2b2lkOiBDaGVjayBpZiBhIGJyZWFrIGhhcHBlbnMgbWlkLWVsZW1lbnQuXG5cbiAgICAgIGlmIChydWxlcy5hdm9pZCAmJiAhcnVsZXMuYmVmb3JlKSB7XG4gICAgICAgIHZhciBzdGFydFBhZ2UgPSBNYXRoLmZsb29yKGNsaWVudFJlY3QudG9wIC8gcHhQYWdlSGVpZ2h0KTtcbiAgICAgICAgdmFyIGVuZFBhZ2UgPSBNYXRoLmZsb29yKGNsaWVudFJlY3QuYm90dG9tIC8gcHhQYWdlSGVpZ2h0KTtcbiAgICAgICAgdmFyIG5QYWdlcyA9IE1hdGguYWJzKGNsaWVudFJlY3QuYm90dG9tIC0gY2xpZW50UmVjdC50b3ApIC8gcHhQYWdlSGVpZ2h0OyAvLyBUdXJuIG9uIHJ1bGVzLmJlZm9yZSBpZiB0aGUgZWwgaXMgYnJva2VuIGFuZCBpcyBhdCBtb3N0IG9uZSBwYWdlIGxvbmcuXG5cbiAgICAgICAgaWYgKGVuZFBhZ2UgIT09IHN0YXJ0UGFnZSAmJiBuUGFnZXMgPD0gMSkge1xuICAgICAgICAgIHJ1bGVzLmJlZm9yZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQmVmb3JlOiBDcmVhdGUgYSBwYWRkaW5nIGRpdiB0byBwdXNoIHRoZSBlbGVtZW50IHRvIHRoZSBuZXh0IHBhZ2UuXG5cblxuICAgICAgaWYgKHJ1bGVzLmJlZm9yZSkge1xuICAgICAgICB2YXIgcGFkID0gKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uY3JlYXRlRWxlbWVudCkoJ2RpdicsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgIGhlaWdodDogcHhQYWdlSGVpZ2h0IC0gY2xpZW50UmVjdC50b3AgJSBweFBhZ2VIZWlnaHQgKyAncHgnXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocGFkLCBlbCk7XG4gICAgICB9IC8vIEFmdGVyOiBDcmVhdGUgYSBwYWRkaW5nIGRpdiB0byBmaWxsIHRoZSByZW1haW5pbmcgcGFnZS5cblxuXG4gICAgICBpZiAocnVsZXMuYWZ0ZXIpIHtcbiAgICAgICAgdmFyIHBhZCA9ICgwLF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLmNyZWF0ZUVsZW1lbnQpKCdkaXYnLCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICBoZWlnaHQ6IHB4UGFnZUhlaWdodCAtIGNsaWVudFJlY3QuYm90dG9tICUgcHhQYWdlSGVpZ2h0ICsgJ3B4J1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBhZCwgZWwubmV4dFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJvYmpUeXBlXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBvYmpUeXBlOyB9LFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcImNyZWF0ZUVsZW1lbnRcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNyZWF0ZUVsZW1lbnQ7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiY2xvbmVOb2RlXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjbG9uZU5vZGU7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwidW5pdENvbnZlcnRcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIHVuaXRDb252ZXJ0OyB9LFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInRvUHhcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIHRvUHg7IH1cbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19udW1iZXJfY29uc3RydWN0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19udW1iZXJfY29uc3RydWN0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfbnVtYmVyX2NvbnN0cnVjdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyk7XG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8vIERldGVybWluZSB0aGUgdHlwZSBvZiBhIHZhcmlhYmxlL29iamVjdC5cbnZhciBvYmpUeXBlID0gZnVuY3Rpb24gb2JqVHlwZShvYmopIHtcbiAgdmFyIHR5cGUgPSBfdHlwZW9mKG9iaik7XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJ3VuZGVmaW5lZCc7ZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycgfHwgb2JqIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gJ3N0cmluZyc7ZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gJ251bWJlcic7ZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBvYmogaW5zdGFuY2VvZiBGdW5jdGlvbikgcmV0dXJuICdmdW5jdGlvbic7ZWxzZSBpZiAoISFvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheSkgcmV0dXJuICdhcnJheSc7ZWxzZSBpZiAob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuICdlbGVtZW50JztlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JykgcmV0dXJuICdvYmplY3QnO2Vsc2UgcmV0dXJuICd1bmtub3duJztcbn07IC8vIENyZWF0ZSBhbiBIVE1MIGVsZW1lbnQgd2l0aCBvcHRpb25hbCBjbGFzc05hbWUsIGlubmVySFRNTCwgYW5kIHN0eWxlLlxuXG52YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgb3B0KSB7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmIChvcHQuY2xhc3NOYW1lKSBlbC5jbGFzc05hbWUgPSBvcHQuY2xhc3NOYW1lO1xuXG4gIGlmIChvcHQuaW5uZXJIVE1MKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gb3B0LmlubmVySFRNTDtcbiAgICB2YXIgc2NyaXB0cyA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcblxuICAgIGZvciAodmFyIGkgPSBzY3JpcHRzLmxlbmd0aDsgaS0tID4gMDsgbnVsbCkge1xuICAgICAgc2NyaXB0c1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvcHQuc3R5bGUpIHtcbiAgICBlbC5zdHlsZVtrZXldID0gb3B0LnN0eWxlW2tleV07XG4gIH1cblxuICByZXR1cm4gZWw7XG59OyAvLyBEZWVwLWNsb25lIGEgbm9kZSBhbmQgcHJlc2VydmUgY29udGVudHMvcHJvcGVydGllcy5cblxudmFyIGNsb25lTm9kZSA9IGZ1bmN0aW9uIGNsb25lTm9kZShub2RlLCBqYXZhc2NyaXB0RW5hYmxlZCkge1xuICAvLyBSZWN1cnNpdmVseSBjbG9uZSB0aGUgbm9kZS5cbiAgdmFyIGNsb25lID0gbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUubm9kZVZhbHVlKSA6IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcblxuICBmb3IgKHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICBpZiAoamF2YXNjcmlwdEVuYWJsZWQgPT09IHRydWUgfHwgY2hpbGQubm9kZVR5cGUgIT09IDEgfHwgY2hpbGQubm9kZU5hbWUgIT09ICdTQ1JJUFQnKSB7XG4gICAgICBjbG9uZS5hcHBlbmRDaGlsZChjbG9uZU5vZGUoY2hpbGQsIGphdmFzY3JpcHRFbmFibGVkKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAvLyBQcmVzZXJ2ZSBjb250ZW50cy9wcm9wZXJ0aWVzIG9mIHNwZWNpYWwgbm9kZXMuXG4gICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdDQU5WQVMnKSB7XG4gICAgICBjbG9uZS53aWR0aCA9IG5vZGUud2lkdGg7XG4gICAgICBjbG9uZS5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgIGNsb25lLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKG5vZGUsIDAsIDApO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCBub2RlLm5vZGVOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgY2xvbmUudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIH0gLy8gUHJlc2VydmUgdGhlIG5vZGUncyBzY3JvbGwgcG9zaXRpb24gd2hlbiBpdCBsb2Fkcy5cblxuXG4gICAgY2xvbmUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsb25lLnNjcm9sbFRvcCA9IG5vZGUuc2Nyb2xsVG9wO1xuICAgICAgY2xvbmUuc2Nyb2xsTGVmdCA9IG5vZGUuc2Nyb2xsTGVmdDtcbiAgICB9LCB0cnVlKTtcbiAgfSAvLyBSZXR1cm4gdGhlIGNsb25lZCBub2RlLlxuXG5cbiAgcmV0dXJuIGNsb25lO1xufTsgLy8gQ29udmVydCB1bml0cyBmcm9tIHB4IHVzaW5nIHRoZSBjb252ZXJzaW9uIHZhbHVlICdrJyBmcm9tIGpzUERGLlxuXG52YXIgdW5pdENvbnZlcnQgPSBmdW5jdGlvbiB1bml0Q29udmVydChvYmosIGspIHtcbiAgaWYgKG9ialR5cGUob2JqKSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gb2JqICogNzIgLyA5NiAvIGs7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5ld09iaiA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XSAqIDcyIC8gOTYgLyBrO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmo7XG4gIH1cbn07IC8vIENvbnZlcnQgdW5pdHMgdG8gcHggdXNpbmcgdGhlIGNvbnZlcnNpb24gdmFsdWUgJ2snIGZyb20ganNQREYuXG5cbnZhciB0b1B4ID0gZnVuY3Rpb24gdG9QeCh2YWwsIGspIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodmFsICogayAvIDcyICogOTYpO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvd29ya2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy93b3JrZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfYXNzaWduX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfYXNzaWduX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9hc3NpZ25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X21hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X21hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9tYXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9jb25jYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9jb25jYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3JlZ2V4cF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3JlZ2V4cF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfcmVnZXhwX3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfZnVuY3Rpb25fbmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfZnVuY3Rpb25fbmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19mdW5jdGlvbl9uYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGpzcGRmICovIFwianNwZGZcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBodG1sMmNhbnZhc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgaHRtbDJjYW52YXMgKi8gXCJodG1sMmNhbnZhc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBodG1sMmNhbnZhc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGh0bWwyY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMuanMgKi8gXCIuL3NyYy91dGlscy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBlczZfcHJvbWlzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGVzNi1wcm9taXNlICovIFwiLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBlczZfcHJvbWlzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihlczZfcHJvbWlzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgUHJvbWlzZSA9IChlczZfcHJvbWlzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX19kZWZhdWx0KCkuUHJvbWlzZSk7XG4vKiAtLS0tLSBDT05TVFJVQ1RPUiAtLS0tLSAqL1xuXG52YXIgV29ya2VyID0gZnVuY3Rpb24gV29ya2VyKG9wdCkge1xuICAvLyBDcmVhdGUgdGhlIHJvb3QgcGFyZW50IGZvciB0aGUgcHJvdG8gY2hhaW4sIGFuZCB0aGUgc3RhcnRpbmcgV29ya2VyLlxuICB2YXIgcm9vdCA9IE9iamVjdC5hc3NpZ24oV29ya2VyLmNvbnZlcnQoUHJvbWlzZS5yZXNvbHZlKCkpLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KFdvcmtlci50ZW1wbGF0ZSkpKTtcbiAgdmFyIHNlbGYgPSBXb3JrZXIuY29udmVydChQcm9taXNlLnJlc29sdmUoKSwgcm9vdCk7IC8vIFNldCBwcm9ncmVzcywgb3B0aW9uYWwgc2V0dGluZ3MsIGFuZCByZXR1cm4uXG5cbiAgc2VsZiA9IHNlbGYuc2V0UHJvZ3Jlc3MoMSwgV29ya2VyLCAxLCBbV29ya2VyXSk7XG4gIHNlbGYgPSBzZWxmLnNldChvcHQpO1xuICByZXR1cm4gc2VsZjtcbn07IC8vIEJvaWxlcnBsYXRlIGZvciBzdWJjbGFzc2luZyBQcm9taXNlLlxuXG5cbldvcmtlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTtcbldvcmtlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXb3JrZXI7IC8vIENvbnZlcnRzL2Nhc3RzIHByb21pc2VzIGludG8gV29ya2Vycy5cblxuV29ya2VyLmNvbnZlcnQgPSBmdW5jdGlvbiBjb252ZXJ0KHByb21pc2UsIGluaGVyaXQpIHtcbiAgLy8gVXNlcyBwcm90b3R5cGFsIGluaGVyaXRhbmNlIHRvIHJlY2VpdmUgY2hhbmdlcyBtYWRlIHRvIGFuY2VzdG9ycycgcHJvcGVydGllcy5cbiAgcHJvbWlzZS5fX3Byb3RvX18gPSBpbmhlcml0IHx8IFdvcmtlci5wcm90b3R5cGU7XG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuV29ya2VyLnRlbXBsYXRlID0ge1xuICBwcm9wOiB7XG4gICAgc3JjOiBudWxsLFxuICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICBvdmVybGF5OiBudWxsLFxuICAgIGNhbnZhczogbnVsbCxcbiAgICBpbWc6IG51bGwsXG4gICAgcGRmOiBudWxsLFxuICAgIHBhZ2VTaXplOiBudWxsXG4gIH0sXG4gIHByb2dyZXNzOiB7XG4gICAgdmFsOiAwLFxuICAgIHN0YXRlOiBudWxsLFxuICAgIG46IDAsXG4gICAgc3RhY2s6IFtdXG4gIH0sXG4gIG9wdDoge1xuICAgIGZpbGVuYW1lOiAnZmlsZS5wZGYnLFxuICAgIG1hcmdpbjogWzAsIDAsIDAsIDBdLFxuICAgIGltYWdlOiB7XG4gICAgICB0eXBlOiAnanBlZycsXG4gICAgICBxdWFsaXR5OiAwLjk1XG4gICAgfSxcbiAgICBlbmFibGVMaW5rczogdHJ1ZSxcbiAgICBodG1sMmNhbnZhczoge30sXG4gICAganNQREY6IHt9XG4gIH1cbn07XG4vKiAtLS0tLSBGUk9NIC8gVE8gLS0tLS0gKi9cblxuV29ya2VyLnByb3RvdHlwZS5mcm9tID0gZnVuY3Rpb24gZnJvbShzcmMsIHR5cGUpIHtcbiAgZnVuY3Rpb24gZ2V0VHlwZShzcmMpIHtcbiAgICBzd2l0Y2ggKCgwLF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXy5vYmpUeXBlKShzcmMpKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG5cbiAgICAgIGNhc2UgJ2VsZW1lbnQnOlxuICAgICAgICByZXR1cm4gc3JjLm5vZGVOYW1lLnRvTG93ZXJDYXNlICYmIHNyYy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJyA/ICdjYW52YXMnIDogJ2VsZW1lbnQnO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gZnJvbV9tYWluKCkge1xuICAgIHR5cGUgPSB0eXBlIHx8IGdldFR5cGUoc3JjKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICBzcmM6ICgwLF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXy5jcmVhdGVFbGVtZW50KSgnZGl2Jywge1xuICAgICAgICAgICAgaW5uZXJIVE1MOiBzcmNcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnZWxlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgc3JjOiBzcmNcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgY2FudmFzOiBzcmNcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgaW1nOiBzcmNcbiAgICAgICAgfSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdVbmtub3duIHNvdXJjZSB0eXBlLicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0KSB7XG4gIC8vIFJvdXRlIHRoZSAndG8nIHJlcXVlc3QgdG8gdGhlIGFwcHJvcHJpYXRlIG1ldGhvZC5cbiAgc3dpdGNoICh0YXJnZXQpIHtcbiAgICBjYXNlICdjb250YWluZXInOlxuICAgICAgcmV0dXJuIHRoaXMudG9Db250YWluZXIoKTtcblxuICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICByZXR1cm4gdGhpcy50b0NhbnZhcygpO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIHJldHVybiB0aGlzLnRvSW1nKCk7XG5cbiAgICBjYXNlICdwZGYnOlxuICAgICAgcmV0dXJuIHRoaXMudG9QZGYoKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcignSW52YWxpZCB0YXJnZXQuJyk7XG4gIH1cbn07XG5cbldvcmtlci5wcm90b3R5cGUudG9Db250YWluZXIgPSBmdW5jdGlvbiB0b0NvbnRhaW5lcigpIHtcbiAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrU3JjKCkge1xuICAgIHJldHVybiB0aGlzLnByb3Auc3JjIHx8IHRoaXMuZXJyb3IoJ0Nhbm5vdCBkdXBsaWNhdGUgLSBubyBzb3VyY2UgSFRNTC4nKTtcbiAgfSwgZnVuY3Rpb24gY2hlY2tQYWdlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLnBhZ2VTaXplIHx8IHRoaXMuc2V0UGFnZVNpemUoKTtcbiAgfV07XG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gdG9Db250YWluZXJfbWFpbigpIHtcbiAgICAvLyBEZWZpbmUgdGhlIENTUyBzdHlsZXMgZm9yIHRoZSBjb250YWluZXIgYW5kIGl0cyBvdmVybGF5IHBhcmVudC5cbiAgICB2YXIgb3ZlcmxheUNTUyA9IHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgekluZGV4OiAxMDAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJ1xuICAgIH07XG4gICAgdmFyIGNvbnRhaW5lckNTUyA9IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6IHRoaXMucHJvcC5wYWdlU2l6ZS5pbm5lci53aWR0aCArIHRoaXMucHJvcC5wYWdlU2l6ZS51bml0LFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICBtYXJnaW46ICdhdXRvJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJ1xuICAgIH07IC8vIFNldCB0aGUgb3ZlcmxheSB0byBoaWRkZW4gKGNvdWxkIGJlIGNoYW5nZWQgaW4gdGhlIGZ1dHVyZSB0byBwcm92aWRlIGEgcHJpbnQgcHJldmlldykuXG5cbiAgICBvdmVybGF5Q1NTLm9wYWNpdHkgPSAwOyAvLyBDcmVhdGUgYW5kIGF0dGFjaCB0aGUgZWxlbWVudHMuXG5cbiAgICB2YXIgc291cmNlID0gKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLmNsb25lTm9kZSkodGhpcy5wcm9wLnNyYywgdGhpcy5vcHQuaHRtbDJjYW52YXMuamF2YXNjcmlwdEVuYWJsZWQpO1xuICAgIHRoaXMucHJvcC5vdmVybGF5ID0gKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLmNyZWF0ZUVsZW1lbnQpKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICdodG1sMnBkZl9fb3ZlcmxheScsXG4gICAgICBzdHlsZTogb3ZlcmxheUNTU1xuICAgIH0pO1xuICAgIHRoaXMucHJvcC5jb250YWluZXIgPSAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uY3JlYXRlRWxlbWVudCkoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2h0bWwycGRmX19jb250YWluZXInLFxuICAgICAgc3R5bGU6IGNvbnRhaW5lckNTU1xuICAgIH0pO1xuICAgIHRoaXMucHJvcC5jb250YWluZXIuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgICB0aGlzLnByb3Aub3ZlcmxheS5hcHBlbmRDaGlsZCh0aGlzLnByb3AuY29udGFpbmVyKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucHJvcC5vdmVybGF5KTtcbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnRvQ2FudmFzID0gZnVuY3Rpb24gdG9DYW52YXMoKSB7XG4gIC8vIFNldCB1cCBmdW5jdGlvbiBwcmVyZXF1aXNpdGVzLlxuICB2YXIgcHJlcmVxcyA9IFtmdW5jdGlvbiBjaGVja0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnByb3AuY29udGFpbmVyKSB8fCB0aGlzLnRvQ29udGFpbmVyKCk7XG4gIH1dOyAvLyBGdWxmaWxsIHByZXJlcXMgdGhlbiBjcmVhdGUgdGhlIGNhbnZhcy5cblxuICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS50aGVuKGZ1bmN0aW9uIHRvQ2FudmFzX21haW4oKSB7XG4gICAgLy8gSGFuZGxlIG9sZC1mYXNoaW9uZWQgJ29ucmVuZGVyZWQnIGFyZ3VtZW50LlxuICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHQuaHRtbDJjYW52YXMpO1xuICAgIGRlbGV0ZSBvcHRpb25zLm9ucmVuZGVyZWQ7XG4gICAgcmV0dXJuIGh0bWwyY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18odGhpcy5wcm9wLmNvbnRhaW5lciwgb3B0aW9ucyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gdG9DYW52YXNfcG9zdChjYW52YXMpIHtcbiAgICAvLyBIYW5kbGUgb2xkLWZhc2hpb25lZCAnb25yZW5kZXJlZCcgYXJndW1lbnQuXG4gICAgdmFyIG9uUmVuZGVyZWQgPSB0aGlzLm9wdC5odG1sMmNhbnZhcy5vbnJlbmRlcmVkIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgb25SZW5kZXJlZChjYW52YXMpO1xuICAgIHRoaXMucHJvcC5jYW52YXMgPSBjYW52YXM7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLnByb3Aub3ZlcmxheSk7XG4gIH0pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS50b0ltZyA9IGZ1bmN0aW9uIHRvSW1nKCkge1xuICAvLyBTZXQgdXAgZnVuY3Rpb24gcHJlcmVxdWlzaXRlcy5cbiAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5jYW52YXMgfHwgdGhpcy50b0NhbnZhcygpO1xuICB9XTsgLy8gRnVsZmlsbCBwcmVyZXFzIHRoZW4gY3JlYXRlIHRoZSBpbWFnZS5cblxuICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS50aGVuKGZ1bmN0aW9uIHRvSW1nX21haW4oKSB7XG4gICAgdmFyIGltZ0RhdGEgPSB0aGlzLnByb3AuY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvJyArIHRoaXMub3B0LmltYWdlLnR5cGUsIHRoaXMub3B0LmltYWdlLnF1YWxpdHkpO1xuICAgIHRoaXMucHJvcC5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICB0aGlzLnByb3AuaW1nLnNyYyA9IGltZ0RhdGE7XG4gIH0pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS50b1BkZiA9IGZ1bmN0aW9uIHRvUGRmKCkge1xuICAvLyBTZXQgdXAgZnVuY3Rpb24gcHJlcmVxdWlzaXRlcy5cbiAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5jYW52YXMgfHwgdGhpcy50b0NhbnZhcygpO1xuICB9LCBmdW5jdGlvbiBjaGVja1BhZ2VTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnByb3AucGFnZVNpemUgfHwgdGhpcy5zZXRQYWdlU2l6ZSgpO1xuICB9XTsgLy8gRnVsZmlsbCBwcmVyZXFzIHRoZW4gY3JlYXRlIHRoZSBpbWFnZS5cblxuICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS50aGVuKGZ1bmN0aW9uIHRvUGRmX21haW4oKSB7XG4gICAgLy8gQ3JlYXRlIGxvY2FsIGNvcGllcyBvZiBmcmVxdWVudGx5IHVzZWQgcHJvcGVydGllcy5cbiAgICB2YXIgY2FudmFzID0gdGhpcy5wcm9wLmNhbnZhcztcbiAgICB2YXIgb3B0ID0gdGhpcy5vcHQ7IC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHBhZ2VzLlxuXG4gICAgdmFyIHB4RnVsbEhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgdmFyIHB4UGFnZUhlaWdodCA9IE1hdGguZmxvb3IoY2FudmFzLndpZHRoICogdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLnJhdGlvKTtcbiAgICB2YXIgblBhZ2VzID0gTWF0aC5jZWlsKHB4RnVsbEhlaWdodCAvIHB4UGFnZUhlaWdodCk7IC8vIERlZmluZSBwYWdlSGVpZ2h0IHNlcGFyYXRlbHkgc28gaXQgY2FuIGJlIHRyaW1tZWQgb24gdGhlIGZpbmFsIHBhZ2UuXG5cbiAgICB2YXIgcGFnZUhlaWdodCA9IHRoaXMucHJvcC5wYWdlU2l6ZS5pbm5lci5oZWlnaHQ7IC8vIENyZWF0ZSBhIG9uZS1wYWdlIGNhbnZhcyB0byBzcGxpdCB1cCB0aGUgZnVsbCBpbWFnZS5cblxuICAgIHZhciBwYWdlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIHBhZ2VDdHggPSBwYWdlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgcGFnZUNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICBwYWdlQ2FudmFzLmhlaWdodCA9IHB4UGFnZUhlaWdodDsgLy8gSW5pdGlhbGl6ZSB0aGUgUERGLlxuXG4gICAgdGhpcy5wcm9wLnBkZiA9IHRoaXMucHJvcC5wZGYgfHwgbmV3IGpzcGRmX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18uanNQREYob3B0LmpzUERGKTtcblxuICAgIGZvciAodmFyIHBhZ2UgPSAwOyBwYWdlIDwgblBhZ2VzOyBwYWdlKyspIHtcbiAgICAgIC8vIFRyaW0gdGhlIGZpbmFsIHBhZ2UgdG8gcmVkdWNlIGZpbGUgc2l6ZS5cbiAgICAgIGlmIChwYWdlID09PSBuUGFnZXMgLSAxICYmIHB4RnVsbEhlaWdodCAlIHB4UGFnZUhlaWdodCAhPT0gMCkge1xuICAgICAgICBwYWdlQ2FudmFzLmhlaWdodCA9IHB4RnVsbEhlaWdodCAlIHB4UGFnZUhlaWdodDtcbiAgICAgICAgcGFnZUhlaWdodCA9IHBhZ2VDYW52YXMuaGVpZ2h0ICogdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLndpZHRoIC8gcGFnZUNhbnZhcy53aWR0aDtcbiAgICAgIH0gLy8gRGlzcGxheSB0aGUgcGFnZS5cblxuXG4gICAgICB2YXIgdyA9IHBhZ2VDYW52YXMud2lkdGg7XG4gICAgICB2YXIgaCA9IHBhZ2VDYW52YXMuaGVpZ2h0O1xuICAgICAgcGFnZUN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgcGFnZUN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgIHBhZ2VDdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgcGFnZSAqIHB4UGFnZUhlaWdodCwgdywgaCwgMCwgMCwgdywgaCk7IC8vIEFkZCB0aGUgcGFnZSB0byB0aGUgUERGLlxuXG4gICAgICBpZiAocGFnZSkgdGhpcy5wcm9wLnBkZi5hZGRQYWdlKCk7XG4gICAgICB2YXIgaW1nRGF0YSA9IHBhZ2VDYW52YXMudG9EYXRhVVJMKCdpbWFnZS8nICsgb3B0LmltYWdlLnR5cGUsIG9wdC5pbWFnZS5xdWFsaXR5KTtcbiAgICAgIHRoaXMucHJvcC5wZGYuYWRkSW1hZ2UoaW1nRGF0YSwgb3B0LmltYWdlLnR5cGUsIG9wdC5tYXJnaW5bMV0sIG9wdC5tYXJnaW5bMF0sIHRoaXMucHJvcC5wYWdlU2l6ZS5pbm5lci53aWR0aCwgcGFnZUhlaWdodCk7XG4gICAgfVxuICB9KTtcbn07XG4vKiAtLS0tLSBPVVRQVVQgLyBTQVZFIC0tLS0tICovXG5cblxuV29ya2VyLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiBvdXRwdXQodHlwZSwgb3B0aW9ucywgc3JjKSB7XG4gIC8vIFJlZGlyZWN0IHJlcXVlc3RzIHRvIHRoZSBjb3JyZWN0IGZ1bmN0aW9uIChvdXRwdXRQZGYgLyBvdXRwdXRJbWcpLlxuICBzcmMgPSBzcmMgfHwgJ3BkZic7XG5cbiAgaWYgKHNyYy50b0xvd2VyQ2FzZSgpID09PSAnaW1nJyB8fCBzcmMudG9Mb3dlckNhc2UoKSA9PT0gJ2ltYWdlJykge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEltZyh0eXBlLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRQZGYodHlwZSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbldvcmtlci5wcm90b3R5cGUub3V0cHV0UGRmID0gZnVuY3Rpb24gb3V0cHV0UGRmKHR5cGUsIG9wdGlvbnMpIHtcbiAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrUGRmKCkge1xuICAgIHJldHVybiB0aGlzLnByb3AucGRmIHx8IHRoaXMudG9QZGYoKTtcbiAgfV07IC8vIEZ1bGZpbGwgcHJlcmVxcyB0aGVuIHBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIG91dHB1dC5cblxuICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS50aGVuKGZ1bmN0aW9uIG91dHB1dFBkZl9tYWluKCkge1xuICAgIC8qIEN1cnJlbnRseSBpbXBsZW1lbnRlZCBvdXRwdXQgdHlwZXM6XG4gICAgICogICAgaHR0cHM6Ly9yYXdnaXQuY29tL01yUmlvL2pzUERGL21hc3Rlci9kb2NzL2pzcGRmLmpzLmh0bWwjbGluZTk5MlxuICAgICAqICBzYXZlKG9wdGlvbnMpLCBhcnJheWJ1ZmZlciwgYmxvYiwgYmxvYnVyaS9ibG9idXJsLFxuICAgICAqICBkYXRhdXJpc3RyaW5nL2RhdGF1cmxzdHJpbmcsIGRhdGF1cmxuZXd3aW5kb3csIGRhdGF1cmkvZGF0YXVybFxuICAgICAqL1xuICAgIHJldHVybiB0aGlzLnByb3AucGRmLm91dHB1dCh0eXBlLCBvcHRpb25zKTtcbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLm91dHB1dEltZyA9IGZ1bmN0aW9uIG91dHB1dEltZyh0eXBlLCBvcHRpb25zKSB7XG4gIC8vIFNldCB1cCBmdW5jdGlvbiBwcmVyZXF1aXNpdGVzLlxuICB2YXIgcHJlcmVxcyA9IFtmdW5jdGlvbiBjaGVja0ltZygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLmltZyB8fCB0aGlzLnRvSW1nKCk7XG4gIH1dOyAvLyBGdWxmaWxsIHByZXJlcXMgdGhlbiBwZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSBvdXRwdXQuXG5cbiAgcmV0dXJuIHRoaXMudGhlbkxpc3QocHJlcmVxcykudGhlbihmdW5jdGlvbiBvdXRwdXRJbWdfbWFpbigpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5pbWc7XG5cbiAgICAgIGNhc2UgJ2RhdGF1cmlzdHJpbmcnOlxuICAgICAgY2FzZSAnZGF0YXVybHN0cmluZyc6XG4gICAgICAgIHJldHVybiB0aGlzLnByb3AuaW1nLnNyYztcblxuICAgICAgY2FzZSAnZGF0YXVyaSc6XG4gICAgICBjYXNlICdkYXRhdXJsJzpcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgPSB0aGlzLnByb3AuaW1nLnNyYztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgJ0ltYWdlIG91dHB1dCB0eXBlIFwiJyArIHR5cGUgKyAnXCIgaXMgbm90IHN1cHBvcnRlZC4nO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKGZpbGVuYW1lKSB7XG4gIC8vIFNldCB1cCBmdW5jdGlvbiBwcmVyZXF1aXNpdGVzLlxuICB2YXIgcHJlcmVxcyA9IFtmdW5jdGlvbiBjaGVja1BkZigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLnBkZiB8fCB0aGlzLnRvUGRmKCk7XG4gIH1dOyAvLyBGdWxmaWxsIHByZXJlcXMsIHVwZGF0ZSB0aGUgZmlsZW5hbWUgKGlmIHByb3ZpZGVkKSwgYW5kIHNhdmUgdGhlIFBERi5cblxuICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS5zZXQoZmlsZW5hbWUgPyB7XG4gICAgZmlsZW5hbWU6IGZpbGVuYW1lXG4gIH0gOiBudWxsKS50aGVuKGZ1bmN0aW9uIHNhdmVfbWFpbigpIHtcbiAgICB0aGlzLnByb3AucGRmLnNhdmUodGhpcy5vcHQuZmlsZW5hbWUpO1xuICB9KTtcbn07XG4vKiAtLS0tLSBTRVQgLyBHRVQgLS0tLS0gKi9cblxuXG5Xb3JrZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChvcHQpIHtcbiAgLy8gVE9ETzogSW1wbGVtZW50IG9yZGVyZWQgcGFpcnM/XG4gIC8vIFNpbGVudGx5IGlnbm9yZSBpbnZhbGlkIG9yIGVtcHR5IGlucHV0LlxuICBpZiAoKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLm9ialR5cGUpKG9wdCkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gQnVpbGQgYW4gYXJyYXkgb2Ygc2V0dGVyIGZ1bmN0aW9ucyB0byBxdWV1ZS5cblxuXG4gIHZhciBmbnMgPSBPYmplY3Qua2V5cyhvcHQgfHwge30pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ21hcmdpbic6XG4gICAgICAgIHJldHVybiB0aGlzLnNldE1hcmdpbi5iaW5kKHRoaXMsIG9wdC5tYXJnaW4pO1xuXG4gICAgICBjYXNlICdqc1BERic6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRfanNQREYoKSB7XG4gICAgICAgICAgdGhpcy5vcHQuanNQREYgPSBvcHQuanNQREY7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0UGFnZVNpemUoKTtcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSAncGFnZVNpemUnOlxuICAgICAgICByZXR1cm4gdGhpcy5zZXRQYWdlU2l6ZS5iaW5kKHRoaXMsIG9wdC5wYWdlU2l6ZSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChrZXkgaW4gV29ya2VyLnRlbXBsYXRlLnByb3ApIHtcbiAgICAgICAgICAvLyBTZXQgcHJlLWRlZmluZWQgcHJvcGVydGllcyBpbiBwcm9wLlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRfcHJvcCgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcFtrZXldID0gb3B0W2tleV07XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTZXQgYW55IG90aGVyIHByb3BlcnRpZXMgaW4gb3B0LlxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRfb3B0KCkge1xuICAgICAgICAgICAgdGhpcy5vcHRba2V5XSA9IG9wdFtrZXldO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH1cbiAgfSwgdGhpcyk7IC8vIFNldCBwcm9wZXJ0aWVzIHdpdGhpbiB0aGUgcHJvbWlzZSBjaGFpbi5cblxuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIHNldF9tYWluKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW5MaXN0KGZucyk7XG4gIH0pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5LCBjYmspIHtcbiAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiBnZXRfbWFpbigpIHtcbiAgICAvLyBGZXRjaCB0aGUgcmVxdWVzdGVkIHByb3BlcnR5LCBlaXRoZXIgYXMgYSBwcmVkZWZpbmVkIHByb3Agb3IgaW4gb3B0LlxuICAgIHZhciB2YWwgPSBrZXkgaW4gV29ya2VyLnRlbXBsYXRlLnByb3AgPyB0aGlzLnByb3Bba2V5XSA6IHRoaXMub3B0W2tleV07XG4gICAgcmV0dXJuIGNiayA/IGNiayh2YWwpIDogdmFsO1xuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUuc2V0TWFyZ2luID0gZnVuY3Rpb24gc2V0TWFyZ2luKG1hcmdpbikge1xuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIHNldE1hcmdpbl9tYWluKCkge1xuICAgIC8vIFBhcnNlIHRoZSBtYXJnaW4gcHJvcGVydHk6IFt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHRdLlxuICAgIHN3aXRjaCAoKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLm9ialR5cGUpKG1hcmdpbikpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIG1hcmdpbiA9IFttYXJnaW4sIG1hcmdpbiwgbWFyZ2luLCBtYXJnaW5dO1xuXG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIGlmIChtYXJnaW4ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgbWFyZ2luID0gW21hcmdpblswXSwgbWFyZ2luWzFdLCBtYXJnaW5bMF0sIG1hcmdpblsxXV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFyZ2luLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdJbnZhbGlkIG1hcmdpbiBhcnJheS4nKTtcbiAgICB9IC8vIFNldCB0aGUgbWFyZ2luIHByb3BlcnR5LCB0aGVuIHVwZGF0ZSBwYWdlU2l6ZS5cblxuXG4gICAgdGhpcy5vcHQubWFyZ2luID0gbWFyZ2luO1xuICB9KS50aGVuKHRoaXMuc2V0UGFnZVNpemUpO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS5zZXRQYWdlU2l6ZSA9IGZ1bmN0aW9uIHNldFBhZ2VTaXplKHBhZ2VTaXplKSB7XG4gIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gc2V0UGFnZVNpemVfbWFpbigpIHtcbiAgICAvLyBSZXRyaWV2ZSBwYWdlLXNpemUgYmFzZWQgb24ganNQREYgc2V0dGluZ3MsIGlmIG5vdCBleHBsaWNpdGx5IHByb3ZpZGVkLlxuICAgIHBhZ2VTaXplID0gcGFnZVNpemUgfHwganNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXy5qc1BERi5nZXRQYWdlU2l6ZSh0aGlzLm9wdC5qc1BERik7IC8vIEFkZCAnaW5uZXInIGZpZWxkIGlmIG5vdCBwcmVzZW50LlxuXG4gICAgaWYgKCFwYWdlU2l6ZS5oYXNPd25Qcm9wZXJ0eSgnaW5uZXInKSkge1xuICAgICAgcGFnZVNpemUuaW5uZXIgPSB7XG4gICAgICAgIHdpZHRoOiBwYWdlU2l6ZS53aWR0aCAtIHRoaXMub3B0Lm1hcmdpblsxXSAtIHRoaXMub3B0Lm1hcmdpblszXSxcbiAgICAgICAgaGVpZ2h0OiBwYWdlU2l6ZS5oZWlnaHQgLSB0aGlzLm9wdC5tYXJnaW5bMF0gLSB0aGlzLm9wdC5tYXJnaW5bMl1cbiAgICAgIH07XG4gICAgICBwYWdlU2l6ZS5pbm5lci5weCA9IHtcbiAgICAgICAgd2lkdGg6ICgwLF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXy50b1B4KShwYWdlU2l6ZS5pbm5lci53aWR0aCwgcGFnZVNpemUuayksXG4gICAgICAgIGhlaWdodDogKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLnRvUHgpKHBhZ2VTaXplLmlubmVyLmhlaWdodCwgcGFnZVNpemUuaylcbiAgICAgIH07XG4gICAgICBwYWdlU2l6ZS5pbm5lci5yYXRpbyA9IHBhZ2VTaXplLmlubmVyLmhlaWdodCAvIHBhZ2VTaXplLmlubmVyLndpZHRoO1xuICAgIH0gLy8gQXR0YWNoIHBhZ2VTaXplIHRvIHRoaXMuXG5cblxuICAgIHRoaXMucHJvcC5wYWdlU2l6ZSA9IHBhZ2VTaXplO1xuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUuc2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiBzZXRQcm9ncmVzcyh2YWwsIHN0YXRlLCBuLCBzdGFjaykge1xuICAvLyBJbW1lZGlhdGVseSB1cGRhdGUgYWxsIHByb2dyZXNzIHZhbHVlcy5cbiAgaWYgKHZhbCAhPSBudWxsKSB0aGlzLnByb2dyZXNzLnZhbCA9IHZhbDtcbiAgaWYgKHN0YXRlICE9IG51bGwpIHRoaXMucHJvZ3Jlc3Muc3RhdGUgPSBzdGF0ZTtcbiAgaWYgKG4gIT0gbnVsbCkgdGhpcy5wcm9ncmVzcy5uID0gbjtcbiAgaWYgKHN0YWNrICE9IG51bGwpIHRoaXMucHJvZ3Jlc3Muc3RhY2sgPSBzdGFjaztcbiAgdGhpcy5wcm9ncmVzcy5yYXRpbyA9IHRoaXMucHJvZ3Jlc3MudmFsIC8gdGhpcy5wcm9ncmVzcy5zdGF0ZTsgLy8gUmV0dXJuIHRoaXMgZm9yIGNvbW1hbmQgY2hhaW5pbmcuXG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnVwZGF0ZVByb2dyZXNzID0gZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3ModmFsLCBzdGF0ZSwgbiwgc3RhY2spIHtcbiAgLy8gSW1tZWRpYXRlbHkgdXBkYXRlIGFsbCBwcm9ncmVzcyB2YWx1ZXMsIHVzaW5nIHNldFByb2dyZXNzLlxuICByZXR1cm4gdGhpcy5zZXRQcm9ncmVzcyh2YWwgPyB0aGlzLnByb2dyZXNzLnZhbCArIHZhbCA6IG51bGwsIHN0YXRlID8gc3RhdGUgOiBudWxsLCBuID8gdGhpcy5wcm9ncmVzcy5uICsgbiA6IG51bGwsIHN0YWNrID8gdGhpcy5wcm9ncmVzcy5zdGFjay5jb25jYXQoc3RhY2spIDogbnVsbCk7XG59O1xuLyogLS0tLS0gUFJPTUlTRSBNQVBQSU5HIC0tLS0tICovXG5cblxuV29ya2VyLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAvLyBXcmFwIGB0aGlzYCBmb3IgZW5jYXBzdWxhdGlvbi5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy50aGVuQ29yZShvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgZnVuY3Rpb24gdGhlbl9tYWluKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgLy8gVXBkYXRlIHByb2dyZXNzIHdoaWxlIHF1ZXVpbmcsIGNhbGxpbmcsIGFuZCByZXNvbHZpbmcgYHRoZW5gLlxuICAgIHNlbGYudXBkYXRlUHJvZ3Jlc3MobnVsbCwgbnVsbCwgMSwgW29uRnVsZmlsbGVkXSk7XG4gICAgcmV0dXJuIFByb21pc2UucHJvdG90eXBlLnRoZW4uY2FsbCh0aGlzLCBmdW5jdGlvbiB0aGVuX3ByZSh2YWwpIHtcbiAgICAgIHNlbGYudXBkYXRlUHJvZ3Jlc3MobnVsbCwgb25GdWxmaWxsZWQpO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9KS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKS50aGVuKGZ1bmN0aW9uIHRoZW5fcG9zdCh2YWwpIHtcbiAgICAgIHNlbGYudXBkYXRlUHJvZ3Jlc3MoMSk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUudGhlbkNvcmUgPSBmdW5jdGlvbiB0aGVuQ29yZShvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgdGhlbkJhc2UpIHtcbiAgLy8gSGFuZGxlIG9wdGlvbmFsIHRoZW5CYXNlIHBhcmFtZXRlci5cbiAgdGhlbkJhc2UgPSB0aGVuQmFzZSB8fCBQcm9taXNlLnByb3RvdHlwZS50aGVuOyAvLyBXcmFwIGB0aGlzYCBmb3IgZW5jYXBzdWxhdGlvbiBhbmQgYmluZCBpdCB0byB0aGUgcHJvbWlzZSBoYW5kbGVycy5cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKG9uRnVsZmlsbGVkKSB7XG4gICAgb25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZC5iaW5kKHNlbGYpO1xuICB9XG5cbiAgaWYgKG9uUmVqZWN0ZWQpIHtcbiAgICBvblJlamVjdGVkID0gb25SZWplY3RlZC5iaW5kKHNlbGYpO1xuICB9IC8vIENhc3Qgc2VsZiBpbnRvIGEgUHJvbWlzZSB0byBhdm9pZCBwb2x5ZmlsbHMgcmVjdXJzaXZlbHkgZGVmaW5pbmcgYHRoZW5gLlxuXG5cbiAgdmFyIGlzTmF0aXZlID0gUHJvbWlzZS50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPT0gLTEgJiYgUHJvbWlzZS5uYW1lID09PSAnUHJvbWlzZSc7XG4gIHZhciBzZWxmUHJvbWlzZSA9IGlzTmF0aXZlID8gc2VsZiA6IFdvcmtlci5jb252ZXJ0KE9iamVjdC5hc3NpZ24oe30sIHNlbGYpLCBQcm9taXNlLnByb3RvdHlwZSk7IC8vIFJldHVybiB0aGUgcHJvbWlzZSwgYWZ0ZXIgY2FzdGluZyBpdCBpbnRvIGEgV29ya2VyIGFuZCBwcmVzZXJ2aW5nIHByb3BzLlxuXG4gIHZhciByZXR1cm5WYWwgPSB0aGVuQmFzZS5jYWxsKHNlbGZQcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIHJldHVybiBXb3JrZXIuY29udmVydChyZXR1cm5WYWwsIHNlbGYuX19wcm90b19fKTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUudGhlbkV4dGVybmFsID0gZnVuY3Rpb24gdGhlbkV4dGVybmFsKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIC8vIENhbGwgYHRoZW5gIGFuZCByZXR1cm4gYSBzdGFuZGFyZCBwcm9taXNlIChleGl0cyB0aGUgV29ya2VyIGNoYWluKS5cbiAgcmV0dXJuIFByb21pc2UucHJvdG90eXBlLnRoZW4uY2FsbCh0aGlzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnRoZW5MaXN0ID0gZnVuY3Rpb24gdGhlbkxpc3QoZm5zKSB7XG4gIC8vIFF1ZXVlIGEgc2VyaWVzIG9mIHByb21pc2UgJ2ZhY3RvcmllcycgaW50byB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmbnMuZm9yRWFjaChmdW5jdGlvbiB0aGVuTGlzdF9mb3JFYWNoKGZuKSB7XG4gICAgc2VsZiA9IHNlbGYudGhlbkNvcmUoZm4pO1xuICB9KTtcbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgLy8gQmluZCBgdGhpc2AgdG8gdGhlIHByb21pc2UgaGFuZGxlciwgY2FsbCBgY2F0Y2hgLCBhbmQgcmV0dXJuIGEgV29ya2VyLlxuICBpZiAob25SZWplY3RlZCkge1xuICAgIG9uUmVqZWN0ZWQgPSBvblJlamVjdGVkLmJpbmQodGhpcyk7XG4gIH1cblxuICB2YXIgcmV0dXJuVmFsID0gUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10uY2FsbCh0aGlzLCBvblJlamVjdGVkKTtcbiAgcmV0dXJuIFdvcmtlci5jb252ZXJ0KHJldHVyblZhbCwgdGhpcyk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLmNhdGNoRXh0ZXJuYWwgPSBmdW5jdGlvbiBjYXRjaEV4dGVybmFsKG9uUmVqZWN0ZWQpIHtcbiAgLy8gQ2FsbCBgY2F0Y2hgIGFuZCByZXR1cm4gYSBzdGFuZGFyZCBwcm9taXNlIChleGl0cyB0aGUgV29ya2VyIGNoYWluKS5cbiAgcmV0dXJuIFByb21pc2UucHJvdG90eXBlWydjYXRjaCddLmNhbGwodGhpcywgb25SZWplY3RlZCk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIC8vIFRocm93IHRoZSBlcnJvciBpbiB0aGUgUHJvbWlzZSBjaGFpbi5cbiAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiBlcnJvcl9tYWluKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9KTtcbn07XG4vKiAtLS0tLSBBTElBU0VTIC0tLS0tICovXG5cblxuV29ya2VyLnByb3RvdHlwZS51c2luZyA9IFdvcmtlci5wcm90b3R5cGUuc2V0O1xuV29ya2VyLnByb3RvdHlwZS5zYXZlQXMgPSBXb3JrZXIucHJvdG90eXBlLnNhdmU7XG5Xb3JrZXIucHJvdG90eXBlLmV4cG9ydCA9IFdvcmtlci5wcm90b3R5cGUub3V0cHV0O1xuV29ya2VyLnByb3RvdHlwZS5ydW4gPSBXb3JrZXIucHJvdG90eXBlLnRoZW47XG4vKiAtLS0tLSBGSU5JU0hJTkcgLS0tLS0gKi9cbi8vIEV4cG9zZSB0aGUgV29ya2VyIGNsYXNzLlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFdvcmtlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtZnVuY3Rpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWZ1bmN0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgJiYgaXQgIT09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmcoaXQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcIik7XG5cbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKEFycmF5UHJvdG90eXBlLCBVTlNDT1BBQkxFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3JlYXRlKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanNcIikuZm9yRWFjaDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0LmpzXCIpO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2ZvckVhY2gnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbm1vZHVsZS5leHBvcnRzID0gIVNUUklDVF9NRVRIT0QgPyBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxufSA6IFtdLmZvckVhY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qc1wiKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qc1wiKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qc1wiKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qc1wiKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qc1wiKTtcblxudmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlclJlamVjdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PSA3O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX1JFSkVDVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmYWxzZTsgICAgICAgICAgICAgLy8gZXZlcnlcbiAgICAgICAgICBjYXNlIDc6IHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsgLy8gZmlsdGVyUmVqZWN0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHRhcmdldDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCgwKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgbWFwOiBjcmVhdGVNZXRob2QoMSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kKDIpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCgzKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QoNCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kKDUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCg2KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJSZWplY3RgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1maWx0ZXJpbmdcbiAgZmlsdGVyUmVqZWN0OiBjcmVhdGVNZXRob2QoNylcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG52YXIgVjhfVkVSU0lPTiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzXCIpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3N1xuICByZXR1cm4gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFycmF5LmNvbnN0cnVjdG9yID0ge307XG4gICAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBmb286IDEgfTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICB9KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwsbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgMTsgfSwgMSk7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG4vLyBhIHBhcnQgb2YgYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgZWxzZSBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1wiKTtcblxuLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzXCIpO1xudmFyIGNsYXNzb2ZSYXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb3duLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzKHRhcmdldCwga2V5KSkgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1odG1sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1odG1sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1wiKTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanNcIik7XG5cbnZhciBxdW90ID0gL1wiL2c7XG5cbi8vIGBDcmVhdGVIVE1MYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlaHRtbFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHN0cmluZykpO1xuICB2YXIgcDEgPSAnPCcgKyB0YWc7XG4gIGlmIChhdHRyaWJ1dGUgIT09ICcnKSBwMSArPSAnICcgKyBhdHRyaWJ1dGUgKyAnPVwiJyArIHRvU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3Rvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzXCIpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzXCIpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanNcIik7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcIik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcIik7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanNcIik7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qc1wiKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1wiKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcIik7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9wYXRoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcIikuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICB2YXIgU3ltYm9sID0gcGF0aC5TeW1ib2wgfHwgKHBhdGguU3ltYm9sID0ge30pO1xuICBpZiAoIWhhcyhTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eShTeW1ib2wsIE5BTUUsIHtcbiAgICB2YWx1ZTogd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKE5BTUUpXG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCIpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzXCIpO1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWwuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPCA0ID8gMSA6IG1hdGNoWzBdICsgbWF0Y2hbMV07XG59IGVsc2UgaWYgKHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9IG1hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbiAmJiArdmVyc2lvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCIpLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXCIpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qc1wiKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qc1wiKTtcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1mb3JjZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanNcIik7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1mdW5jdGlvbi5qc1wiKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PSAnZnVuY3Rpb24nID8gdmFyaWFibGUgOiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pIDogZ2xvYmFsW25hbWVzcGFjZV0gJiYgZ2xvYmFsW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXCIpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRvT2JqZWN0KGl0KSwga2V5KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanNcIik7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWllZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mLXJhdyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXCIpO1xuXG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanNcIik7XG5cbi8vIG1ha2VzIHN1YmNsYXNzaW5nIHdvcmsgY29ycmVjdCBmb3Igd3JhcHBlZCBidWlsdC1pbnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCR0aGlzLCBkdW1teSwgV3JhcHBlcikge1xuICB2YXIgTmV3VGFyZ2V0LCBOZXdUYXJnZXRQcm90b3R5cGU7XG4gIGlmIChcbiAgICAvLyBpdCBjYW4gd29yayBvbmx5IHdpdGggbmF0aXZlIGBzZXRQcm90b3R5cGVPZmBcbiAgICBzZXRQcm90b3R5cGVPZiAmJlxuICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcbiAgICB0eXBlb2YgKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSA9PSAnZnVuY3Rpb24nICYmXG4gICAgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmXG4gICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcbiAgICBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlXG4gICkgc2V0UHJvdG90eXBlT2YoJHRoaXMsIE5ld1RhcmdldFByb3RvdHlwZSk7XG4gIHJldHVybiAkdGhpcztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qc1wiKTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi50b1N0cmluZztcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKHR5cGVvZiBzdG9yZS5pbnNwZWN0U291cmNlICE9ICdmdW5jdGlvbicpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanNcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBvYmplY3RIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanNcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCIpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1wiKTtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG4gIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcbiAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHdtaGFzLmNhbGwoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQuY2FsbChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChvYmplY3RIYXMoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcIik7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjbGFzc29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IHR5cGVvZiBkZXRlY3Rpb24gPT0gJ2Z1bmN0aW9uJyA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzXCIpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKTtcbiAgcmV0dXJuIHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbicgJiYgT2JqZWN0KGl0KSBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLXB1cmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzXCIpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCghSVNfUFVSRSB8fCBORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgVjhfVkVSU0lPTiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uLmpzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qc1wiKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1hc3NpZ24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzXCIpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanNcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXCIpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1wiKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc3ltYm9sIC0tIHNhZmVcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IG9iamVjdEtleXMoUykuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzXCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXCIpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1wiKTtcbnZhciBodG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2h0bWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzXCIpO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzXCIpO1xudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qc1wiKTtcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZiAoaWZyYW1lLnN0eWxlKSB7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICAgIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gICAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG4gIH1cbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnQgP1xuICAgIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSA6IC8vIG9sZCBJRVxuICAgIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpIHx8XG4gICAgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcIik7XG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXCIpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBQcm9wZXJ0aWVzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qc1wiKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIik7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanNcIik7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIXByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmUgKi9cbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXCIpLmY7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nXG4gICAgPyBnZXRXaW5kb3dOYW1lcyhpdClcbiAgICA6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcIik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanNcIik7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCIpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanNcIik7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXCIpO1xudmFyIGluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qc1wiKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcIik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanNcIik7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAtLSBzYWZlICovXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXCIpO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzXCIpO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanNcIik7XG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qc1wiKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpbnB1dC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXCIpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qc1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcIik7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciBzZXRHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanNcIik7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzXCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1wiKTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICB2YXIgc3RhdGU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnICYmICFoYXModmFsdWUsICduYW1lJykpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCBrZXkpO1xuICAgIH1cbiAgICBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgICBpZiAoIXN0YXRlLnNvdXJjZSkge1xuICAgICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogJycpO1xuICAgIH1cbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1mbGFncy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LmRvdEFsbCkgcmVzdWx0ICs9ICdzJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKS5mO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShpdCwgVE9fU1RSSU5HX1RBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qc1wiKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXCIpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzXCIpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLXB1cmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzXCIpO1xudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qc1wiKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjE2LjAnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMjEgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctaHRtbC1mb3JjZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1odG1sLWZvcmNlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG5cbi8vIGNoZWNrIHRoZSBleGlzdGVuY2Ugb2YgYSBtZXRob2QsIGxvd2VyY2FzZVxuLy8gb2YgYSB0YWcgYW5kIGVzY2FwaW5nIHF1b3RlcyBpbiBhcmd1bWVudHNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHJldHVybiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSAnJ1tNRVRIT0RfTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW50ZWdlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanNcIik7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCIpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXCIpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HID8gUy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAyKSA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXRyaW0uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXRyaW0uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXCIpO1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qc1wiKTtcbnZhciB3aGl0ZXNwYWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93aGl0ZXNwYWNlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzXCIpO1xuXG52YXIgd2hpdGVzcGFjZSA9ICdbJyArIHdoaXRlc3BhY2VzICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcykge1xuICAgIHZhciBzdHJpbmcgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcbiAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG4gIHRyaW06IGNyZWF0ZU1ldGhvZCgzKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWludGVnZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLmpzXCIpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW50ZWdlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanNcIik7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcIik7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzXCIpO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xuXG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBpbnB1dFtUT19QUklNSVRJVkVdO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXCIpO1xudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qc1wiKTtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUddID0gJ3onO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNTeW1ib2woYXJndW1lbnQpKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiBTdHJpbmcoYXJndW1lbnQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgU3RyaW5nKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArICgrK2lkICsgcG9zdGZpeCkudG9TdHJpbmcoMzYpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBOQVRJVkVfU1lNQk9MID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0xcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbmV4cG9ydHMuZiA9IHdlbGxLbm93blN5bWJvbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VpZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qc1wiKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzXCIpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanNcIik7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPT0gJ3N0cmluZycpKSB7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzKFN5bWJvbCwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbFtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICAgIH1cbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93aGl0ZXNwYWNlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93aGl0ZXNwYWNlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbm1vZHVsZS5leHBvcnRzID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArXG4gICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanNcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1wiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1sZW5ndGggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanNcIik7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzXCIpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXCIpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciBWOF9WRVJTSU9OID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanNcIik7XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHdlbGxLbm93blN5bWJvbCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7XG52YXIgTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCc7XG5cbi8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG59KTtcblxudmFyIFNQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2NvbmNhdCcpO1xuXG52YXIgaXNDb25jYXRTcHJlYWRhYmxlID0gZnVuY3Rpb24gKE8pIHtcbiAgaWYgKCFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3ByZWFkYWJsZSA9IE9bSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShPKTtcbn07XG5cbnZhciBGT1JDRUQgPSAhSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCB8fCAhU1BFQ0lFU19TVVBQT1JUO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXRcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoYXJnKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuICAgIGZvciAoaSA9IC0xLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoaXNDb25jYXRTcHJlYWRhYmxlKEUpKSB7XG4gICAgICAgIGxlbiA9IHRvTGVuZ3RoKEUubGVuZ3RoKTtcbiAgICAgICAgaWYgKG4gKyBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrLCBuKyspIGlmIChrIGluIEUpIGNyZWF0ZVByb3BlcnR5KEEsIG4sIEVba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG4gPj0gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KEEsIG4rKywgRSk7XG4gICAgICB9XG4gICAgfVxuICAgIEEubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanNcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1wiKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcIik7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yLmpzXCIpO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdC5qc1wiKTtcblxudmFyIG5hdGl2ZUpvaW4gPSBbXS5qb2luO1xuXG52YXIgRVMzX1NUUklOR1MgPSBJbmRleGVkT2JqZWN0ICE9IE9iamVjdDtcbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnam9pbicsICcsJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuam9pbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5qb2luXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBFUzNfU1RSSU5HUyB8fCAhU1RSSUNUX01FVEhPRCB9LCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUpvaW4uY2FsbCh0b0luZGV4ZWRPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcIik7XG52YXIgJG1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanNcIikubWFwO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qc1wiKTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdtYXAnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfSwge1xuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LmpzXCIpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qc1wiKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0LmpzXCIpO1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ3NsaWNlJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgbmF0aXZlU2xpY2UgPSBbXS5zbGljZTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zbGljZVxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgICAvLyBpbmxpbmUgYEFycmF5U3BlY2llc0NyZWF0ZWAgZm9yIHVzYWdlIG5hdGl2ZSBgQXJyYXkjc2xpY2VgIHdoZXJlIGl0J3MgcG9zc2libGVcbiAgICB2YXIgQ29uc3RydWN0b3IsIHJlc3VsdCwgbjtcbiAgICBpZiAoaXNBcnJheShPKSkge1xuICAgICAgQ29uc3RydWN0b3IgPSBPLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgQ29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAoQ29uc3RydWN0b3IgPT09IEFycmF5IHx8IGlzQXJyYXkoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KENvbnN0cnVjdG9yKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yW1NQRUNJRVNdO1xuICAgICAgICBpZiAoQ29uc3RydWN0b3IgPT09IG51bGwpIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTbGljZS5jYWxsKE8sIGssIGZpbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IG5ldyAoQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQ29uc3RydWN0b3IpKG1heChmaW4gLSBrLCAwKSk7XG4gICAgZm9yIChuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGlmIChrIGluIE8pIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKS5mO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZyA9IEZ1bmN0aW9uUHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnO1xuXG4vLyBGdW5jdGlvbiBpbnN0YW5jZXMgYC5uYW1lYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi1pbnN0YW5jZXMtbmFtZVxuaWYgKERFU0NSSVBUT1JTICYmICEoTkFNRSBpbiBGdW5jdGlvblByb3RvdHlwZSkpIHtcbiAgZGVmaW5lUHJvcGVydHkoRnVuY3Rpb25Qcm90b3R5cGUsIE5BTUUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZy5jYWxsKHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtZm9yY2VkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcIik7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQuanNcIik7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanNcIikuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIikuZjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKS5mO1xudmFyIHRyaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qc1wiKS50cmltO1xuXG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgTmF0aXZlTnVtYmVyID0gZ2xvYmFsW05VTUJFUl07XG52YXIgTnVtYmVyUHJvdG90eXBlID0gTmF0aXZlTnVtYmVyLnByb3RvdHlwZTtcblxuLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG52YXIgQlJPS0VOX0NMQVNTT0YgPSBjbGFzc29mKGNyZWF0ZShOdW1iZXJQcm90b3R5cGUpKSA9PSBOVU1CRVI7XG5cbi8vIGBUb051bWJlcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbnVtYmVyXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzU3ltYm9sKGFyZ3VtZW50KSkgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIG51bWJlcicpO1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ251bWJlcicpO1xuICB2YXIgZmlyc3QsIHRoaXJkLCByYWRpeCwgbWF4Q29kZSwgZGlnaXRzLCBsZW5ndGgsIGluZGV4LCBjb2RlO1xuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpIHtcbiAgICBpdCA9IHRyaW0oaXQpO1xuICAgIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgb2YgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgb2YgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZGlnaXRzID0gaXQuc2xpY2UoMik7XG4gICAgICBsZW5ndGggPSBkaWdpdHMubGVuZ3RoO1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG4vLyBgTnVtYmVyYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1udW1iZXItY29uc3RydWN0b3JcbmlmIChpc0ZvcmNlZChOVU1CRVIsICFOYXRpdmVOdW1iZXIoJyAwbzEnKSB8fCAhTmF0aXZlTnVtYmVyKCcwYjEnKSB8fCBOYXRpdmVOdW1iZXIoJysweDEnKSkpIHtcbiAgdmFyIE51bWJlcldyYXBwZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTtcbiAgICB2YXIgZHVtbXkgPSB0aGlzO1xuICAgIHJldHVybiBkdW1teSBpbnN0YW5jZW9mIE51bWJlcldyYXBwZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DTEFTU09GID8gZmFpbHMoZnVuY3Rpb24gKCkgeyBOdW1iZXJQcm90b3R5cGUudmFsdWVPZi5jYWxsKGR1bW15KTsgfSkgOiBjbGFzc29mKGR1bW15KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IE5hdGl2ZU51bWJlcih0b051bWJlcihpdCkpLCBkdW1teSwgTnVtYmVyV3JhcHBlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSBERVNDUklQVE9SUyA/IGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlTnVtYmVyKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTMjAxNSAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTMjAxNSBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXIsJyArXG4gICAgLy8gRVNOZXh0XG4gICAgJ2Zyb21TdHJpbmcscmFuZ2UnXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHtcbiAgICBpZiAoaGFzKE5hdGl2ZU51bWJlciwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcyhOdW1iZXJXcmFwcGVyLCBrZXkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShOdW1iZXJXcmFwcGVyLCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihOYXRpdmVOdW1iZXIsIGtleSkpO1xuICAgIH1cbiAgfVxuICBOdW1iZXJXcmFwcGVyLnByb3RvdHlwZSA9IE51bWJlclByb3RvdHlwZTtcbiAgTnVtYmVyUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTnVtYmVyV3JhcHBlcjtcbiAgcmVkZWZpbmUoZ2xvYmFsLCBOVU1CRVIsIE51bWJlcldyYXBwZXIpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtYXNzaWduICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qc1wiKTtcblxuLy8gYE9iamVjdC5hc3NpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWFzc2lnbiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gYXNzaWduIH0sIHtcbiAgYXNzaWduOiBhc3NpZ25cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG52YXIgbmF0aXZlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVLZXlzKDEpOyB9KTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMgfSwge1xuICBrZXlzOiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXModG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qc1wiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXCIpO1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzXCIpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbmlmICghVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gIHJlZGVmaW5lKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVkZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS5qc1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcIik7XG52YXIgJHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIGZsYWdzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFncyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1mbGFncy5qc1wiKTtcblxudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcbnZhciBuYXRpdmVUb1N0cmluZyA9IFJlZ0V4cFByb3RvdHlwZVtUT19TVFJJTkddO1xuXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG52YXIgSU5DT1JSRUNUX05BTUUgPSBuYXRpdmVUb1N0cmluZy5uYW1lICE9IFRPX1NUUklORztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAoTk9UX0dFTkVSSUMgfHwgSU5DT1JSRUNUX05BTUUpIHtcbiAgcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwID0gJHRvU3RyaW5nKFIuc291cmNlKTtcbiAgICB2YXIgcmYgPSBSLmZsYWdzO1xuICAgIHZhciBmID0gJHRvU3RyaW5nKHJmID09PSB1bmRlZmluZWQgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiAhKCdmbGFncycgaW4gUmVnRXhwUHJvdG90eXBlKSA/IGZsYWdzLmNhbGwoUikgOiByZik7XG4gICAgcmV0dXJuICcvJyArIHAgKyAnLycgKyBmO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjaGFyQXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUuanNcIikuY2hhckF0O1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qc1wiKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcIik7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yLmpzXCIpO1xuXG52YXIgU1RSSU5HX0lURVJBVE9SID0gJ1N0cmluZyBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IHRvU3RyaW5nKGl0ZXJhdGVkKSxcbiAgICBpbmRleDogMFxuICB9KTtcbi8vIGAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gY2hhckF0KHN0cmluZywgaW5kZXgpO1xuICBzdGF0ZS5pbmRleCArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubGluay5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5saW5rLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcIik7XG52YXIgY3JlYXRlSFRNTCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtaHRtbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1odG1sLmpzXCIpO1xudmFyIGZvcmNlZFN0cmluZ0hUTUxNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc3RyaW5nLWh0bWwtZm9yY2VkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLWh0bWwtZm9yY2VkLmpzXCIpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5saW5rYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5saW5rXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCgnbGluaycpIH0sIHtcbiAgbGluazogZnVuY3Rpb24gbGluayh1cmwpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gYFN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25gIGdldHRlclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcIikuZjtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qc1wiKTtcblxudmFyIE5hdGl2ZVN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG5cbmlmIChERVNDUklQVE9SUyAmJiB0eXBlb2YgTmF0aXZlU3ltYm9sID09ICdmdW5jdGlvbicgJiYgKCEoJ2Rlc2NyaXB0aW9uJyBpbiBOYXRpdmVTeW1ib2wucHJvdG90eXBlKSB8fFxuICAvLyBTYWZhcmkgMTIgYnVnXG4gIE5hdGl2ZVN5bWJvbCgpLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWRcbikpIHtcbiAgdmFyIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSA9IHt9O1xuICAvLyB3cmFwIFN5bWJvbCBjb25zdHJ1Y3RvciBmb3IgY29ycmVjdCB3b3JrIHdpdGggdW5kZWZpbmVkIGRlc2NyaXB0aW9uXG4gIHZhciBTeW1ib2xXcmFwcGVyID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMgaW5zdGFuY2VvZiBTeW1ib2xXcmFwcGVyXG4gICAgICA/IG5ldyBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pXG4gICAgICAvLyBpbiBFZGdlIDEzLCBTdHJpbmcoU3ltYm9sKHVuZGVmaW5lZCkpID09PSAnU3ltYm9sKHVuZGVmaW5lZCknXG4gICAgICA6IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyBOYXRpdmVTeW1ib2woKSA6IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgaWYgKGRlc2NyaXB0aW9uID09PSAnJykgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlW3Jlc3VsdF0gPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoU3ltYm9sV3JhcHBlciwgTmF0aXZlU3ltYm9sKTtcbiAgdmFyIHN5bWJvbFByb3RvdHlwZSA9IFN5bWJvbFdyYXBwZXIucHJvdG90eXBlID0gTmF0aXZlU3ltYm9sLnByb3RvdHlwZTtcbiAgc3ltYm9sUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ltYm9sV3JhcHBlcjtcblxuICB2YXIgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBuYXRpdmUgPSBTdHJpbmcoTmF0aXZlU3ltYm9sKCd0ZXN0JykpID09ICdTeW1ib2wodGVzdCknO1xuICB2YXIgcmVnZXhwID0gL15TeW1ib2xcXCgoLiopXFwpW14pXSskLztcbiAgZGVmaW5lUHJvcGVydHkoc3ltYm9sUHJvdG90eXBlLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgc3ltYm9sID0gaXNPYmplY3QodGhpcykgPyB0aGlzLnZhbHVlT2YoKSA6IHRoaXM7XG4gICAgICB2YXIgc3RyaW5nID0gc3ltYm9sVG9TdHJpbmcuY2FsbChzeW1ib2wpO1xuICAgICAgaWYgKGhhcyhFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUsIHN5bWJvbCkpIHJldHVybiAnJztcbiAgICAgIHZhciBkZXNjID0gbmF0aXZlID8gc3RyaW5nLnNsaWNlKDcsIC0xKSA6IHN0cmluZy5yZXBsYWNlKHJlZ2V4cCwgJyQxJyk7XG4gICAgICByZXR1cm4gZGVzYyA9PT0gJycgPyB1bmRlZmluZWQgOiBkZXNjO1xuICAgIH1cbiAgfSk7XG5cbiAgJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICBTeW1ib2w6IFN5bWJvbFdyYXBwZXJcbiAgfSk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sLmpzXCIpO1xuXG4vLyBgU3ltYm9sLml0ZXJhdG9yYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXRlcmF0b3JcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzXCIpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanNcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCIpO1xudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qc1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXCIpO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXCIpO1xudmFyICR0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanNcIik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIik7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXCIpO1xudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzXCIpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzXCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanNcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVkZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS5qc1wiKTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXCIpO1xudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qc1wiKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanNcIik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VpZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkLmpzXCIpO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qc1wiKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcIik7XG52YXIgJGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzXCIpLmZvckVhY2g7XG5cbnZhciBISURERU4gPSBzaGFyZWRLZXkoJ2hpZGRlbicpO1xudmFyIFNZTUJPTCA9ICdTeW1ib2wnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNZTUJPTCk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJHN0cmluZ2lmeSA9IGdldEJ1aWx0SW4oJ0pTT04nLCAnc3RyaW5naWZ5Jyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZjtcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvdHlwZVN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeScpO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgVVNFX1NFVFRFUiA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RDcmVhdGUobmF0aXZlRGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgdmFyIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlLCBQKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpIGRlbGV0ZSBPYmplY3RQcm90b3R5cGVbUF07XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBPICE9PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGUsIFAsIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpO1xuICB9XG59IDogbmF0aXZlRGVmaW5lUHJvcGVydHk7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZywgZGVzY3JpcHRpb24pIHtcbiAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG5hdGl2ZU9iamVjdENyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzZXRJbnRlcm5hbFN0YXRlKHN5bWJvbCwge1xuICAgIHR5cGU6IFNZTUJPTCxcbiAgICB0YWc6IHRhZyxcbiAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb25cbiAgfSk7XG4gIGlmICghREVTQ1JJUFRPUlMpIHN5bWJvbC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICByZXR1cm4gc3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgaWYgKE8gPT09IE9iamVjdFByb3RvdHlwZSkgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFAsIEF0dHJpYnV0ZXMpO1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoTywgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMgfHwgJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocHJvcGVydGllcywga2V5KSkgJGRlZmluZVByb3BlcnR5KE8sIGtleSwgcHJvcGVydGllc1trZXldKTtcbiAgfSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gbmF0aXZlT2JqZWN0Q3JlYXRlKE8pIDogJGRlZmluZVByb3BlcnRpZXMobmF0aXZlT2JqZWN0Q3JlYXRlKE8pLCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBQID0gdG9Qcm9wZXJ0eUtleShWKTtcbiAgdmFyIGVudW1lcmFibGUgPSBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRoaXMsIFApO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhcyhBbGxTeW1ib2xzLCBQKSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFApKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbnVtZXJhYmxlIHx8ICFoYXModGhpcywgUCkgfHwgIWhhcyhBbGxTeW1ib2xzLCBQKSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1bUF0gPyBlbnVtZXJhYmxlIDogdHJ1ZTtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgdmFyIGl0ID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBkZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xuICBpZiAoZGVzY3JpcHRvciAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSB7XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChPKSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgJGZvckVhY2gobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoaGlkZGVuS2V5cywga2V5KSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhPKSB7XG4gIHZhciBJU19PQkpFQ1RfUFJPVE9UWVBFID0gTyA9PT0gT2JqZWN0UHJvdG90eXBlO1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKElTX09CSkVDVF9QUk9UT1RZUEUgPyBPYmplY3RQcm90b3R5cGVTeW1ib2xzIDogdG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSAmJiAoIUlTX09CSkVDVF9QUk9UT1RZUEUgfHwgaGFzKE9iamVjdFByb3RvdHlwZSwga2V5KSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICFhcmd1bWVudHMubGVuZ3RoIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogJHRvU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHRhZyA9IHVpZChkZXNjcmlwdGlvbik7XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSkgc2V0dGVyLmNhbGwoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgVVNFX1NFVFRFUikgc2V0U3ltYm9sRGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcblxuICByZWRlZmluZSgkU3ltYm9sLCAnd2l0aG91dFNldHRlcicsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB3cmFwKHVpZChkZXNjcmlwdGlvbiksIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG5cbiAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wobmFtZSksIG5hbWUpO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLVN5bWJvbC1kZXNjcmlwdGlvblxuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFJU19QVVJFKSB7XG4gICAgICByZWRlZmluZShPYmplY3RQcm90b3R5cGUsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuICB9XG59XG5cbiQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsIHNoYW06ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgU3ltYm9sOiAkU3ltYm9sXG59KTtcblxuJGZvckVhY2gob2JqZWN0S2V5cyhXZWxsS25vd25TeW1ib2xzU3RvcmUpLCBmdW5jdGlvbiAobmFtZSkge1xuICBkZWZpbmVXZWxsS25vd25TeW1ib2wobmFtZSk7XG59KTtcblxuJCh7IHRhcmdldDogU1lNQk9MLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5mb3JcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc3RyaW5nID0gJHRvU3RyaW5nKGtleSk7XG4gICAgaWYgKGhhcyhTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5LCBzdHJpbmcpKSByZXR1cm4gU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddO1xuICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKHN0cmluZyk7XG4gICAgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddID0gc3ltYm9sO1xuICAgIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltYm9sXSA9IHN0cmluZztcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9LFxuICAvLyBgU3ltYm9sLmtleUZvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmtleWZvclxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICAgIGlmIChoYXMoU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSwgc3ltKSkgcmV0dXJuIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltXTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IGZhbHNlOyB9XG59KTtcblxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlzeW1ib2xzXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IGZhaWxzKGZ1bmN0aW9uICgpIHsgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYoMSk7IH0pIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmYodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbi8vIGBKU09OLnN0cmluZ2lmeWAgbWV0aG9kIGJlaGF2aW9yIHdpdGggc3ltYm9sc1xuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuaWYgKCRzdHJpbmdpZnkpIHtcbiAgdmFyIEZPUkNFRF9KU09OX1NUUklOR0lGWSA9ICFOQVRJVkVfU1lNQk9MIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3ltYm9sID0gJFN5bWJvbCgpO1xuICAgIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gICAgcmV0dXJuICRzdHJpbmdpZnkoW3N5bWJvbF0pICE9ICdbbnVsbF0nXG4gICAgICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgICAgIHx8ICRzdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT0gJ3t9J1xuICAgICAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgICAgIHx8ICRzdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9ICd7fSc7XG4gIH0pO1xuXG4gICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRURfSlNPTl9TVFJJTkdJRlkgfSwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gICAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgICAgdmFyIGluZGV4ID0gMTtcbiAgICAgIHZhciAkcmVwbGFjZXI7XG4gICAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGluZGV4KSBhcmdzLnB1c2goYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICAgICRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICAgIHJldHVybiAkc3RyaW5naWZ5LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG5pZiAoISRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xufVxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11gIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgU1lNQk9MKTtcblxuaGlkZGVuS2V5c1tISURERU5dID0gdHJ1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xudmFyIERPTUl0ZXJhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kb20taXRlcmFibGVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcy5qc1wiKTtcbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2guanNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggIT09IGZvckVhY2gpIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsICdmb3JFYWNoJywgZm9yRWFjaCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoID0gZm9yRWFjaDtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgRE9NSXRlcmFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzXCIpO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSA9IEFycmF5VmFsdWVzO1xuICAgIH1cbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBR10pIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIH1cbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuOCsxZTY4ZGNlNlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdCB0cnVlID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHQwO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB4O1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cblxuXG52YXIgX2lzQXJyYXkgPSB2b2lkIDA7XG5pZiAoQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59IGVsc2Uge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdm9pZCAwO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdm9pZCAwO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHZlcnR4ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKS5yZXF1aXJlKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbn1cblxudmFyIHNjaGVkdWxlRmx1c2ggPSB2b2lkIDA7XG4vLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuaWYgKGlzTm9kZSkge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbn0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbn0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG59IGVsc2UgaWYgKGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiBcImZ1bmN0aW9uXCIgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiB0cnlUaGVuKHRoZW4kJDEsIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICB0aGVuJCQxLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4kJDEsIHRoZW5hYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGVuYWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfVxuICB9LCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yICYmIHRoZW4kJDEgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlJDEpIHtcbiAgICBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgdGhlbiQkMSA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgdGhlbiQkMSA9IHZhbHVlLnRoZW47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIHRoZW4kJDEpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB2b2lkIDAsXG4gICAgICBjYWxsYmFjayA9IHZvaWQgMCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gIH1cblxuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAvLyBub29wXG4gIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc3VjY2VlZGVkID09PSBmYWxzZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSB2b2lkIDA7XG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIF90aGVuID0gZW50cnkudGhlbjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UkMSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJDEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSQkMShlbnRyeSk7XG4gICAgICAgIH0pLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUkJDEoZW50cnkpLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIF9zZXR0bGVkQXQoc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cblxuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uIF93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSkge1xuICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgIHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KFJFSkVDVEVELCBpLCByZWFzb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBFbnVtZXJhdG9yO1xufSgpO1xuXG4vKipcbiAgYFByb21pc2UuYWxsYCBhY2NlcHRzIGFuIGFycmF5IG9mIHByb21pc2VzLCBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoXG4gIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3JcbiAgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZC4gSXQgY2FzdHMgYWxsXG4gIGVsZW1lbnRzIG9mIHRoZSBwYXNzZWQgaXRlcmFibGUgdG8gcHJvbWlzZXMgYXMgaXQgcnVucyB0aGlzIGFsZ29yaXRobS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVzb2x2ZSgyKTtcbiAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuICB9KTtcbiAgYGBgXG5cbiAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBhbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2VcbiAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG4gIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuICBsZXQgcHJvbWlzZTMgPSByZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCBhbGxcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIGFycmF5IG9mIHByb21pc2VzXG4gIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cbiAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG4gIEBzdGF0aWNcbiovXG5mdW5jdGlvbiBhbGwoZW50cmllcykge1xuICByZXR1cm4gbmV3IEVudW1lcmF0b3IodGhpcywgZW50cmllcykucHJvbWlzZTtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJhY2VgIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaCBpcyBzZXR0bGVkIGluIHRoZSBzYW1lIHdheSBhcyB0aGVcbiAgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gc2V0dGxlLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAyJyk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gcmVzdWx0ID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gIH0pO1xuICBgYGBcblxuICBgUHJvbWlzZS5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0XG4gIHNldHRsZWQgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGVcbiAgYHByb21pc2VzYCBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3Qgc2V0dGxlZCBwcm9taXNlIGhhc1xuICBiZWNvbWUgcmVqZWN0ZWQgYmVmb3JlIHRoZSBvdGhlciBwcm9taXNlcyBiZWNhbWUgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAgcHJvbWlzZSB3aWxsIGJlY29tZSByZWplY3RlZDpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdwcm9taXNlIDInKSk7XG4gICAgfSwgMTAwKTtcbiAgfSk7XG5cbiAgUHJvbWlzZS5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnNcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBBbiBleGFtcGxlIHJlYWwtd29ybGQgdXNlIGNhc2UgaXMgaW1wbGVtZW50aW5nIHRpbWVvdXRzOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgUHJvbWlzZS5yYWNlKFthamF4KCdmb28uanNvbicpLCB0aW1lb3V0KDUwMDApXSlcbiAgYGBgXG5cbiAgQG1ldGhvZCByYWNlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCBzZXR0bGVzIGluIHRoZSBzYW1lIHdheSBhcyB0aGUgZmlyc3QgcGFzc2VkXG4gIHByb21pc2UgdG8gc2V0dGxlLlxuKi9cbmZ1bmN0aW9uIHJhY2UoZW50cmllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAgYFByb21pc2UucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWQgYHJlYXNvbmAuXG4gIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlamVjdFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuKi9cbmZ1bmN0aW9uIHJlamVjdCQxKHJlYXNvbikge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cblxudmFyIFByb21pc2UkMSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICAgIHRoaXNbUFJPTUlTRV9JRF0gPSBuZXh0SWQoKTtcbiAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgaWYgKG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgICAgdGhpcyBpbnN0YW5jZW9mIFByb21pc2UgPyBpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcikgOiBuZWVkc05ldygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgfSk7XG4gIGBgYFxuICAgQ2hhaW5pbmdcbiAgLS0tLS0tLS1cbiAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gdXNlci5uYW1lO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgfSk7XG4gICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICB9KTtcbiAgYGBgXG4gIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICB9KTtcbiAgYGBgXG4gICBBc3NpbWlsYXRpb25cbiAgLS0tLS0tLS0tLS0tXG4gICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgfSk7XG4gIGBgYFxuICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICB9KTtcbiAgYGBgXG4gICBTaW1wbGUgRXhhbXBsZVxuICAtLS0tLS0tLS0tLS0tLVxuICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICAgYGBgamF2YXNjcmlwdFxuICBsZXQgcmVzdWx0O1xuICAgdHJ5IHtcbiAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgLy8gc3VjY2Vzc1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAgIC8vIGZhaWx1cmVcbiAgfVxuICBgYGBcbiAgIEVycmJhY2sgRXhhbXBsZVxuICAgYGBganNcbiAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgLy8gc3VjY2Vzc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIGZhaWx1cmVcbiAgfSk7XG4gIGBgYFxuICAgQWR2YW5jZWQgRXhhbXBsZVxuICAtLS0tLS0tLS0tLS0tLVxuICAgU3luY2hyb25vdXMgRXhhbXBsZVxuICAgYGBgamF2YXNjcmlwdFxuICBsZXQgYXV0aG9yLCBib29rcztcbiAgIHRyeSB7XG4gICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgLy8gc3VjY2Vzc1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAgIC8vIGZhaWx1cmVcbiAgfVxuICBgYGBcbiAgIEVycmJhY2sgRXhhbXBsZVxuICAgYGBganNcbiAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgIH1cbiAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG4gICB9XG4gICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBmYWlsdXJlKGVycik7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIH1cbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZEF1dGhvcigpLlxuICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgLy8gZm91bmQgYm9va3NcbiAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gICBAbWV0aG9kIHRoZW5cbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cbiAgLyoqXG4gIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cbiAgYGBganNcbiAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgfVxuICAvLyBzeW5jaHJvbm91c1xuICB0cnkge1xuICBmaW5kQXV0aG9yKCk7XG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH1cbiAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICBAbWV0aG9kIGNhdGNoXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAgYGZpbmFsbHlgIHdpbGwgYmUgaW52b2tlZCByZWdhcmRsZXNzIG9mIHRoZSBwcm9taXNlJ3MgZmF0ZSBqdXN0IGFzIG5hdGl2ZVxuICAgIHRyeS9jYXRjaC9maW5hbGx5IGJlaGF2ZXNcbiAgXG4gICAgU3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkge1xuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEF1dGhvcigpO1xuICAgIH1cbiAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmaW5kQXV0aG9yKCk7IC8vIHN1Y2NlZWQgb3IgZmFpbFxuICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gYWx3YXlzIHJ1bnNcbiAgICAgIC8vIGRvZXNuJ3QgYWZmZWN0IHRoZSByZXR1cm4gdmFsdWVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEFzeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKXtcbiAgICAgIC8vIGF1dGhvciB3YXMgZWl0aGVyIGZvdW5kLCBvciBub3RcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCBmaW5hbGx5XG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uIF9maW5hbGx5KGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgcmV0dXJuIFByb21pc2U7XG59KCk7XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IHRoZW47XG5Qcm9taXNlJDEuYWxsID0gYWxsO1xuUHJvbWlzZSQxLnJhY2UgPSByYWNlO1xuUHJvbWlzZSQxLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDEucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDEuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDEuX2FzYXAgPSBhc2FwO1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICB2YXIgbG9jYWwgPSB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBzZWxmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgaWYgKFApIHtcbiAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgfVxuXG4gICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQxO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDEucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UkMS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG5yZXR1cm4gUHJvbWlzZSQxO1xuXG59KSkpO1xuXG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiaHRtbDJjYW52YXNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiBleHRlcm5hbCBcImh0bWwyY2FudmFzXCIgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfaHRtbDJjYW52YXNfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwianNwZGZcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiBleHRlcm5hbCBcImpzcGRmXCIgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfanNwZGZfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7IH1cbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaW4gc3RyaWN0IG1vZGUuXG4hZnVuY3Rpb24oKSB7XG5cInVzZSBzdHJpY3RcIjtcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi93b3JrZXIuanMgKi8gXCIuL3NyYy93b3JrZXIuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BsdWdpbl9qc3BkZl9wbHVnaW5fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGx1Z2luL2pzcGRmLXBsdWdpbi5qcyAqLyBcIi4vc3JjL3BsdWdpbi9qc3BkZi1wbHVnaW4uanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BsdWdpbl9wYWdlYnJlYWtzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BsdWdpbi9wYWdlYnJlYWtzLmpzICovIFwiLi9zcmMvcGx1Z2luL3BhZ2VicmVha3MuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BsdWdpbl9oeXBlcmxpbmtzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BsdWdpbi9oeXBlcmxpbmtzLmpzICovIFwiLi9zcmMvcGx1Z2luL2h5cGVybGlua3MuanNcIik7XG5cblxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSBQREYgZnJvbSBhbiBIVE1MIGVsZW1lbnQgb3Igc3RyaW5nIHVzaW5nIGh0bWwyY2FudmFzIGFuZCBqc1BERi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSBlbGVtZW50IG9yIEhUTUwgc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHQgQW4gb2JqZWN0IG9mIG9wdGlvbmFsIHNldHRpbmdzOiAnbWFyZ2luJywgJ2ZpbGVuYW1lJyxcbiAqICAgICdpbWFnZScgKCd0eXBlJyBhbmQgJ3F1YWxpdHknKSwgYW5kICdodG1sMmNhbnZhcycgLyAnanNwZGYnLCB3aGljaCBhcmVcbiAqICAgIHNlbnQgYXMgc2V0dGluZ3MgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBmdW5jdGlvbnMuXG4gKi9cblxudmFyIGh0bWwycGRmID0gZnVuY3Rpb24gaHRtbDJwZGYoc3JjLCBvcHQpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHdvcmtlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICB2YXIgd29ya2VyID0gbmV3IGh0bWwycGRmLldvcmtlcihvcHQpO1xuXG4gIGlmIChzcmMpIHtcbiAgICAvLyBJZiBzcmMgaXMgc3BlY2lmaWVkLCBwZXJmb3JtIHRoZSB0cmFkaXRpb25hbCAnc2ltcGxlJyBvcGVyYXRpb24uXG4gICAgcmV0dXJuIHdvcmtlci5mcm9tKHNyYykuc2F2ZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIHRoZSB3b3JrZXIgZm9yIG5ldyBQcm9taXNlLWJhc2VkIG9wZXJhdGlvbi5cbiAgICByZXR1cm4gd29ya2VyO1xuICB9XG59O1xuXG5odG1sMnBkZi5Xb3JrZXIgPSBfd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZGVmYXVsdDsgLy8gRXhwb3NlIHRoZSBodG1sMnBkZiBmdW5jdGlvbi5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChodG1sMnBkZik7XG59KCk7XG5fX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX2V4cG9ydHNfXy5kZWZhdWx0O1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJzZWxmIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9qc3BkZl9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9odG1sMmNhbnZhc19fIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJyIiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsIm4iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2xpbmtfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsImNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfbGlua19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQiLCJfd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyIsImxpbmtJbmZvIiwib3JpZyIsInRvQ29udGFpbmVyIiwiZGVmYXVsdCIsInByb3RvdHlwZSIsInRvUGRmIiwiY2FsbCIsInRoZW4iLCJ0b0NvbnRhaW5lcl9oeXBlcmxpbmsiLCJvcHQiLCJlbmFibGVMaW5rcyIsImNvbnRhaW5lciIsInByb3AiLCJsaW5rcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjb250YWluZXJSZWN0IiwidW5pdENvbnZlcnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWdlU2l6ZSIsImsiLCJBcnJheSIsImZvckVhY2giLCJsaW5rIiwiY2xpZW50UmVjdHMiLCJnZXRDbGllbnRSZWN0cyIsImkiLCJsZW5ndGgiLCJjbGllbnRSZWN0IiwibGVmdCIsInRvcCIsInBhZ2UiLCJNYXRoIiwiZmxvb3IiLCJpbm5lciIsImhlaWdodCIsIm1hcmdpbiIsInB1c2giLCJ0b1BkZl9oeXBlcmxpbmsiLCJsIiwicGRmIiwic2V0UGFnZSIsIndpZHRoIiwidXJsIiwiaHJlZiIsIm5QYWdlcyIsImludGVybmFsIiwiZ2V0TnVtYmVyT2ZQYWdlcyIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fIiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18iLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQiLCJqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fIiwianNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0IiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJqc1BERiIsImdldFBhZ2VTaXplIiwib3JpZW50YXRpb24iLCJ1bml0IiwiZm9ybWF0Iiwib3B0aW9ucyIsInRvTG93ZXJDYXNlIiwiZm9ybWF0X2FzX3N0cmluZyIsInBhZ2VGb3JtYXRzIiwiaGFzT3duUHJvcGVydHkiLCJwYWdlSGVpZ2h0IiwicGFnZVdpZHRoIiwiZXJyIiwiRXJyb3IiLCJ0bXAiLCJpbmZvIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfc2xpY2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9zbGljZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfam9pbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2pvaW5fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyIsImNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3Rfa2V5c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCIsIl93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyIsIl91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fIiwidGVtcGxhdGUiLCJwYWdlYnJlYWsiLCJtb2RlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJhdm9pZCIsInRvQ29udGFpbmVyX3BhZ2VicmVhayIsInB4UGFnZUhlaWdodCIsInB4IiwibW9kZVNyYyIsImNvbmNhdCIsImF2b2lkQWxsIiwiaW5kZXhPZiIsImNzcyIsImxlZ2FjeSIsInNlbGVjdCIsImtleSIsImFsbCIsInNsaWNlIiwiam9pbiIsImxlZ2FjeUVscyIsImVscyIsInBhZ2VicmVha19sb29wIiwiZWwiLCJydWxlcyIsInN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJyZWFrT3B0IiwiYXZvaWRPcHQiLCJicmVha0JlZm9yZSIsInBhZ2VCcmVha0JlZm9yZSIsImJyZWFrQWZ0ZXIiLCJwYWdlQnJlYWtBZnRlciIsImJyZWFrSW5zaWRlIiwicGFnZUJyZWFrSW5zaWRlIiwiT2JqZWN0Iiwia2V5cyIsInN0YXJ0UGFnZSIsImVuZFBhZ2UiLCJib3R0b20iLCJhYnMiLCJwYWQiLCJjcmVhdGVFbGVtZW50IiwiZGlzcGxheSIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsImQiLCJvYmpUeXBlIiwiY2xvbmVOb2RlIiwidG9QeCIsImNvcmVfanNfbW9kdWxlc19lc19udW1iZXJfY29uc3RydWN0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImNvcmVfanNfbW9kdWxlc19lc19udW1iZXJfY29uc3RydWN0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyIsImNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyIsImNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19fZGVmYXVsdCIsInR5cGUiLCJTdHJpbmciLCJOdW1iZXIiLCJGdW5jdGlvbiIsIm5vZGVUeXBlIiwidGFnTmFtZSIsImRvY3VtZW50IiwiY2xhc3NOYW1lIiwiaW5uZXJIVE1MIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicmVtb3ZlQ2hpbGQiLCJub2RlIiwiamF2YXNjcmlwdEVuYWJsZWQiLCJjbG9uZSIsImNyZWF0ZVRleHROb2RlIiwibm9kZVZhbHVlIiwiY2hpbGQiLCJmaXJzdENoaWxkIiwibm9kZU5hbWUiLCJhcHBlbmRDaGlsZCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ2YWx1ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwibmV3T2JqIiwidmFsIiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9hc3NpZ25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfYXNzaWduX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9tYXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9tYXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX3JlZ2V4cF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyIsImNvcmVfanNfbW9kdWxlc19lc19yZWdleHBfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19mdW5jdGlvbl9uYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18iLCJjb3JlX2pzX21vZHVsZXNfZXNfZnVuY3Rpb25fbmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fIiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0IiwianNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyIsImpzcGRmX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19fZGVmYXVsdCIsImh0bWwyY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18iLCJodG1sMmNhbnZhc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fX2RlZmF1bHQiLCJfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18iLCJlczZfcHJvbWlzZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyIsImVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fX2RlZmF1bHQiLCJQcm9taXNlIiwiV29ya2VyIiwiYXNzaWduIiwiY29udmVydCIsInJlc29sdmUiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJzZXRQcm9ncmVzcyIsInNldCIsImNyZWF0ZSIsInByb21pc2UiLCJpbmhlcml0IiwiX19wcm90b19fIiwic3JjIiwib3ZlcmxheSIsImNhbnZhcyIsImltZyIsInByb2dyZXNzIiwic3RhdGUiLCJzdGFjayIsImZpbGVuYW1lIiwiaW1hZ2UiLCJxdWFsaXR5IiwiaHRtbDJjYW52YXMiLCJmcm9tIiwiZ2V0VHlwZSIsImZyb21fbWFpbiIsImVycm9yIiwidG8iLCJ0YXJnZXQiLCJ0b0NhbnZhcyIsInRvSW1nIiwicHJlcmVxcyIsImNoZWNrU3JjIiwiY2hlY2tQYWdlU2l6ZSIsInNldFBhZ2VTaXplIiwidGhlbkxpc3QiLCJ0b0NvbnRhaW5lcl9tYWluIiwib3ZlcmxheUNTUyIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJ6SW5kZXgiLCJyaWdodCIsImJhY2tncm91bmRDb2xvciIsImNvbnRhaW5lckNTUyIsIm9wYWNpdHkiLCJzb3VyY2UiLCJib2R5IiwiY2hlY2tDb250YWluZXIiLCJjb250YWlucyIsInRvQ2FudmFzX21haW4iLCJvbnJlbmRlcmVkIiwidG9DYW52YXNfcG9zdCIsIm9uUmVuZGVyZWQiLCJjaGVja0NhbnZhcyIsInRvSW1nX21haW4iLCJpbWdEYXRhIiwidG9EYXRhVVJMIiwidG9QZGZfbWFpbiIsInB4RnVsbEhlaWdodCIsInJhdGlvIiwiY2VpbCIsInBhZ2VDYW52YXMiLCJwYWdlQ3R4IiwidyIsImgiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImFkZFBhZ2UiLCJhZGRJbWFnZSIsIm91dHB1dCIsIm91dHB1dEltZyIsIm91dHB1dFBkZiIsImNoZWNrUGRmIiwib3V0cHV0UGRmX21haW4iLCJjaGVja0ltZyIsIm91dHB1dEltZ19tYWluIiwidW5kZWZpbmVkIiwibG9jYXRpb24iLCJzYXZlIiwic2F2ZV9tYWluIiwiZm5zIiwibWFwIiwic2V0TWFyZ2luIiwiYmluZCIsInNldF9qc1BERiIsInNldF9wcm9wIiwic2V0X29wdCIsInNldF9tYWluIiwiZ2V0IiwiY2JrIiwiZ2V0X21haW4iLCJzZXRNYXJnaW5fbWFpbiIsInNldFBhZ2VTaXplX21haW4iLCJ1cGRhdGVQcm9ncmVzcyIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInRoZW5Db3JlIiwidGhlbl9tYWluIiwidGhlbl9wcmUiLCJ0aGVuX3Bvc3QiLCJ0aGVuQmFzZSIsImlzTmF0aXZlIiwidG9TdHJpbmciLCJuYW1lIiwic2VsZlByb21pc2UiLCJyZXR1cm5WYWwiLCJ0aGVuRXh0ZXJuYWwiLCJ0aGVuTGlzdF9mb3JFYWNoIiwiZm4iLCJjYXRjaEV4dGVybmFsIiwibXNnIiwiZXJyb3JfbWFpbiIsInVzaW5nIiwic2F2ZUFzIiwiZXhwb3J0IiwicnVuIiwiaXQiLCJUeXBlRXJyb3IiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJpc09iamVjdCIsIndlbGxLbm93blN5bWJvbCIsImRlZmluZVByb3BlcnR5TW9kdWxlIiwiVU5TQ09QQUJMRVMiLCJBcnJheVByb3RvdHlwZSIsImYiLCJjb25maWd1cmFibGUiLCIkZm9yRWFjaCIsImFycmF5TWV0aG9kSXNTdHJpY3QiLCJTVFJJQ1RfTUVUSE9EIiwiY2FsbGJhY2tmbiIsImFyZ3VtZW50cyIsInRvSW5kZXhlZE9iamVjdCIsInRvTGVuZ3RoIiwidG9BYnNvbHV0ZUluZGV4IiwiY3JlYXRlTWV0aG9kIiwiSVNfSU5DTFVERVMiLCIkdGhpcyIsImZyb21JbmRleCIsIk8iLCJpbmRleCIsImluY2x1ZGVzIiwiSW5kZXhlZE9iamVjdCIsInRvT2JqZWN0IiwiYXJyYXlTcGVjaWVzQ3JlYXRlIiwiVFlQRSIsIklTX01BUCIsIklTX0ZJTFRFUiIsIklTX1NPTUUiLCJJU19FVkVSWSIsIklTX0ZJTkRfSU5ERVgiLCJJU19GSUxURVJfUkVKRUNUIiwiTk9fSE9MRVMiLCJ0aGF0Iiwic3BlY2lmaWNDcmVhdGUiLCJib3VuZEZ1bmN0aW9uIiwicmVzdWx0IiwiZmlsdGVyIiwic29tZSIsImV2ZXJ5IiwiZmluZCIsImZpbmRJbmRleCIsImZpbHRlclJlamVjdCIsImZhaWxzIiwiVjhfVkVSU0lPTiIsIlNQRUNJRVMiLCJNRVRIT0RfTkFNRSIsImFycmF5IiwiZm9vIiwiQm9vbGVhbiIsImFyZ3VtZW50IiwibWV0aG9kIiwiaXNBcnJheSIsIm9yaWdpbmFsQXJyYXkiLCJDIiwiYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IiLCJUT19TVFJJTkdfVEFHX1NVUFBPUlQiLCJjbGFzc29mUmF3IiwiVE9fU1RSSU5HX1RBRyIsIkNPUlJFQ1RfQVJHVU1FTlRTIiwidHJ5R2V0IiwidGFnIiwiY2FsbGVlIiwiaGFzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRiIsImdldFByb3RvdHlwZU9mIiwicmVxdWlyZU9iamVjdENvZXJjaWJsZSIsInF1b3QiLCJzdHJpbmciLCJhdHRyaWJ1dGUiLCJTIiwicDEiLCJyZXBsYWNlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IiLCJzZXRUb1N0cmluZ1RhZyIsIkl0ZXJhdG9ycyIsInJldHVyblRoaXMiLCJJdGVyYXRvckNvbnN0cnVjdG9yIiwiTkFNRSIsIm5leHQiLCJERVNDUklQVE9SUyIsIm9iamVjdCIsImJpdG1hcCIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInRvUHJvcGVydHlLZXkiLCJwcm9wZXJ0eUtleSIsIiQiLCJjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yIiwic2V0UHJvdG90eXBlT2YiLCJjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkiLCJyZWRlZmluZSIsIklTX1BVUkUiLCJJdGVyYXRvcnNDb3JlIiwiQlVHR1lfU0FGQVJJX0lURVJBVE9SUyIsIklURVJBVE9SIiwiS0VZUyIsIlZBTFVFUyIsIkVOVFJJRVMiLCJJdGVyYWJsZSIsIkRFRkFVTFQiLCJJU19TRVQiLCJGT1JDRUQiLCJnZXRJdGVyYXRpb25NZXRob2QiLCJLSU5EIiwiZGVmYXVsdEl0ZXJhdG9yIiwiSXRlcmFibGVQcm90b3R5cGUiLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiSU5DT1JSRUNUX1ZBTFVFU19OQU1FIiwibmF0aXZlSXRlcmF0b3IiLCJhbnlOYXRpdmVJdGVyYXRvciIsIkN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSIsIm1ldGhvZHMiLCJLRVkiLCJwcm90byIsImZvcmNlZCIsInBhdGgiLCJ3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlIiwiZ2xvYmFsIiwiRVhJU1RTIiwiQ1NTUnVsZUxpc3QiLCJDU1NTdHlsZURlY2xhcmF0aW9uIiwiQ1NTVmFsdWVMaXN0IiwiQ2xpZW50UmVjdExpc3QiLCJET01SZWN0TGlzdCIsIkRPTVN0cmluZ0xpc3QiLCJET01Ub2tlbkxpc3QiLCJEYXRhVHJhbnNmZXJJdGVtTGlzdCIsIkZpbGVMaXN0IiwiSFRNTEFsbENvbGxlY3Rpb24iLCJIVE1MQ29sbGVjdGlvbiIsIkhUTUxGb3JtRWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50IiwiTWVkaWFMaXN0IiwiTWltZVR5cGVBcnJheSIsIk5hbWVkTm9kZU1hcCIsIk5vZGVMaXN0IiwiUGFpbnRSZXF1ZXN0TGlzdCIsIlBsdWdpbiIsIlBsdWdpbkFycmF5IiwiU1ZHTGVuZ3RoTGlzdCIsIlNWR051bWJlckxpc3QiLCJTVkdQYXRoU2VnTGlzdCIsIlNWR1BvaW50TGlzdCIsIlNWR1N0cmluZ0xpc3QiLCJTVkdUcmFuc2Zvcm1MaXN0IiwiU291cmNlQnVmZmVyTGlzdCIsIlN0eWxlU2hlZXRMaXN0IiwiVGV4dFRyYWNrQ3VlTGlzdCIsIlRleHRUcmFja0xpc3QiLCJUb3VjaExpc3QiLCJnZXRCdWlsdEluIiwidXNlckFnZW50IiwicHJvY2VzcyIsIkRlbm8iLCJ2ZXJzaW9ucyIsInZlcnNpb24iLCJ2OCIsIm1hdGNoIiwic3BsaXQiLCJzZXRHbG9iYWwiLCJjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzIiwiaXNGb3JjZWQiLCJUQVJHRVQiLCJHTE9CQUwiLCJTVEFUSUMiLCJzdGF0IiwidGFyZ2V0UHJvcGVydHkiLCJzb3VyY2VQcm9wZXJ0eSIsImRlc2NyaXB0b3IiLCJub1RhcmdldEdldCIsInNoYW0iLCJleGVjIiwiYUZ1bmN0aW9uIiwiYSIsImIiLCJjIiwiYXBwbHkiLCJ2YXJpYWJsZSIsIm5hbWVzcGFjZSIsImNoZWNrIiwiZ2xvYmFsVGhpcyIsImhhc093biIsImNsYXNzb2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImR1bW15IiwiV3JhcHBlciIsIk5ld1RhcmdldCIsIk5ld1RhcmdldFByb3RvdHlwZSIsInN0b3JlIiwiZnVuY3Rpb25Ub1N0cmluZyIsImluc3BlY3RTb3VyY2UiLCJOQVRJVkVfV0VBS19NQVAiLCJvYmplY3RIYXMiLCJzaGFyZWQiLCJzaGFyZWRLZXkiLCJoaWRkZW5LZXlzIiwiT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQiLCJXZWFrTWFwIiwiZW5mb3JjZSIsImdldHRlckZvciIsIndtZ2V0Iiwid21oYXMiLCJ3bXNldCIsIm1ldGFkYXRhIiwiZmFjYWRlIiwiU1RBVEUiLCJhcmciLCJyZXBsYWNlbWVudCIsImZlYXR1cmUiLCJkZXRlY3Rpb24iLCJkYXRhIiwibm9ybWFsaXplIiwiUE9MWUZJTEwiLCJOQVRJVkUiLCJVU0VfU1lNQk9MX0FTX1VJRCIsIiRTeW1ib2wiLCJQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUiLCJhcnJheUl0ZXJhdG9yIiwiTkVXX0lURVJBVE9SX1BST1RPVFlQRSIsInRlc3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2wiLCJvYmplY3RLZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlIiwicHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUiLCIkYXNzaWduIiwiQSIsIkIiLCJhbHBoYWJldCIsImNociIsIlQiLCJhcmd1bWVudHNMZW5ndGgiLCJqIiwiYW5PYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZW51bUJ1Z0tleXMiLCJodG1sIiwiZG9jdW1lbnRDcmVhdGVFbGVtZW50IiwiR1QiLCJMVCIsIlBST1RPVFlQRSIsIlNDUklQVCIsIklFX1BST1RPIiwiRW1wdHlDb25zdHJ1Y3RvciIsInNjcmlwdFRhZyIsImNvbnRlbnQiLCJOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYIiwiYWN0aXZlWERvY3VtZW50Iiwid3JpdGUiLCJjbG9zZSIsInRlbXAiLCJwYXJlbnRXaW5kb3ciLCJOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUiLCJpZnJhbWUiLCJKUyIsImlmcmFtZURvY3VtZW50IiwiY29udGVudFdpbmRvdyIsIm9wZW4iLCJOdWxsUHJvdG9PYmplY3QiLCJBY3RpdmVYT2JqZWN0IiwiZG9tYWluIiwiUHJvcGVydGllcyIsIklFOF9ET01fREVGSU5FIiwiJGRlZmluZVByb3BlcnR5IiwiUCIsIkF0dHJpYnV0ZXMiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiJGdldE93blByb3BlcnR5TmFtZXMiLCJ3aW5kb3dOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRXaW5kb3dOYW1lcyIsImludGVybmFsT2JqZWN0S2V5cyIsIkNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiIsIk9iamVjdFByb3RvdHlwZSIsIm5hbWVzIiwiJHByb3BlcnR5SXNFbnVtZXJhYmxlIiwiTkFTSE9STl9CVUciLCJWIiwiYVBvc3NpYmxlUHJvdG90eXBlIiwiQ09SUkVDVF9TRVRURVIiLCJzZXR0ZXIiLCJpbnB1dCIsInByZWYiLCJ2YWx1ZU9mIiwiZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSIsIkludGVybmFsU3RhdGVNb2R1bGUiLCJnZXRJbnRlcm5hbFN0YXRlIiwiZW5mb3JjZUludGVybmFsU3RhdGUiLCJURU1QTEFURSIsInVuc2FmZSIsInNpbXBsZSIsImlnbm9yZUNhc2UiLCJtdWx0aWxpbmUiLCJkb3RBbGwiLCJ1bmljb2RlIiwic3RpY2t5IiwiVEFHIiwidWlkIiwiU0hBUkVEIiwiY29weXJpZ2h0IiwidG9JbnRlZ2VyIiwiQ09OVkVSVF9UT19TVFJJTkciLCJwb3MiLCJzaXplIiwiZmlyc3QiLCJzZWNvbmQiLCJjaGFyQ29kZUF0IiwiY2hhckF0IiwiY29kZUF0Iiwid2hpdGVzcGFjZXMiLCJ3aGl0ZXNwYWNlIiwibHRyaW0iLCJSZWdFeHAiLCJydHJpbSIsInN0YXJ0IiwiZW5kIiwidHJpbSIsIm1heCIsIm1pbiIsImludGVnZXIiLCJpc05hTiIsImlzU3ltYm9sIiwib3JkaW5hcnlUb1ByaW1pdGl2ZSIsIlRPX1BSSU1JVElWRSIsImV4b3RpY1RvUHJpbSIsInRvUHJpbWl0aXZlIiwiaWQiLCJwb3N0Zml4IiwicmFuZG9tIiwiTkFUSVZFX1NZTUJPTCIsIldlbGxLbm93blN5bWJvbHNTdG9yZSIsImNyZWF0ZVdlbGxLbm93blN5bWJvbCIsIndpdGhvdXRTZXR0ZXIiLCJjcmVhdGVQcm9wZXJ0eSIsImFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQiLCJJU19DT05DQVRfU1BSRUFEQUJMRSIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQiLCJJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIiwiU1BFQ0lFU19TVVBQT1JUIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwic3ByZWFkYWJsZSIsImxlbiIsIkUiLCJhZGRUb1Vuc2NvcGFibGVzIiwiZGVmaW5lSXRlcmF0b3IiLCJBUlJBWV9JVEVSQVRPUiIsInNldEludGVybmFsU3RhdGUiLCJpdGVyYXRlZCIsImtpbmQiLCJkb25lIiwiQXJndW1lbnRzIiwibmF0aXZlSm9pbiIsIkVTM19TVFJJTkdTIiwic2VwYXJhdG9yIiwiJG1hcCIsIkhBU19TUEVDSUVTX1NVUFBPUlQiLCJuYXRpdmVTbGljZSIsImZpbiIsIkNvbnN0cnVjdG9yIiwiRnVuY3Rpb25Qcm90b3R5cGUiLCJGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nIiwibmFtZVJFIiwiaW5oZXJpdElmUmVxdWlyZWQiLCJOVU1CRVIiLCJOYXRpdmVOdW1iZXIiLCJOdW1iZXJQcm90b3R5cGUiLCJCUk9LRU5fQ0xBU1NPRiIsInRvTnVtYmVyIiwidGhpcmQiLCJyYWRpeCIsIm1heENvZGUiLCJkaWdpdHMiLCJjb2RlIiwiTmFOIiwicGFyc2VJbnQiLCJOdW1iZXJXcmFwcGVyIiwibmF0aXZlS2V5cyIsIkZBSUxTX09OX1BSSU1JVElWRVMiLCIkdG9TdHJpbmciLCJmbGFncyIsIlRPX1NUUklORyIsIlJlZ0V4cFByb3RvdHlwZSIsIm5hdGl2ZVRvU3RyaW5nIiwiTk9UX0dFTkVSSUMiLCJJTkNPUlJFQ1RfTkFNRSIsIlIiLCJwIiwicmYiLCJTVFJJTkdfSVRFUkFUT1IiLCJwb2ludCIsImNyZWF0ZUhUTUwiLCJmb3JjZWRTdHJpbmdIVE1MTWV0aG9kIiwiTmF0aXZlU3ltYm9sIiwiZGVzY3JpcHRpb24iLCJFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUiLCJTeW1ib2xXcmFwcGVyIiwic3ltYm9sUHJvdG90eXBlIiwic3ltYm9sVG9TdHJpbmciLCJuYXRpdmUiLCJyZWdleHAiLCJkZXNjIiwiZGVmaW5lV2VsbEtub3duU3ltYm9sIiwibmF0aXZlT2JqZWN0Q3JlYXRlIiwiZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsIiwiSElEREVOIiwiU1lNQk9MIiwiJHN0cmluZ2lmeSIsIm5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm5hdGl2ZURlZmluZVByb3BlcnR5IiwibmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyIsIm5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlIiwiQWxsU3ltYm9scyIsIk9iamVjdFByb3RvdHlwZVN5bWJvbHMiLCJTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5IiwiU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSIsIlFPYmplY3QiLCJVU0VfU0VUVEVSIiwiZmluZENoaWxkIiwic2V0U3ltYm9sRGVzY3JpcHRvciIsIk9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IiLCJ3cmFwIiwiJGRlZmluZVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwiJGdldE93blByb3BlcnR5U3ltYm9scyIsIiRjcmVhdGUiLCJJU19PQkpFQ1RfUFJPVE9UWVBFIiwia2V5Rm9yIiwic3ltIiwidXNlU2V0dGVyIiwidXNlU2ltcGxlIiwiRk9SQ0VEX0pTT05fU1RSSU5HSUZZIiwicmVwbGFjZXIiLCJzcGFjZSIsImFyZ3MiLCIkcmVwbGFjZXIiLCJET01JdGVyYWJsZXMiLCJDT0xMRUNUSU9OX05BTUUiLCJDb2xsZWN0aW9uIiwiQ29sbGVjdGlvblByb3RvdHlwZSIsIkFycmF5SXRlcmF0b3JNZXRob2RzIiwiQXJyYXlWYWx1ZXMiLCJvYmplY3RPckZ1bmN0aW9uIiwieCIsImlzRnVuY3Rpb24iLCJfaXNBcnJheSIsInZlcnR4TmV4dCIsImN1c3RvbVNjaGVkdWxlckZuIiwiYXNhcCIsImNhbGxiYWNrIiwicXVldWUiLCJmbHVzaCIsInNjaGVkdWxlRmx1c2giLCJzZXRTY2hlZHVsZXIiLCJzY2hlZHVsZUZuIiwic2V0QXNhcCIsImFzYXBGbiIsImJyb3dzZXJXaW5kb3ciLCJicm93c2VyR2xvYmFsIiwiQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsImlzTm9kZSIsImlzV29ya2VyIiwiVWludDhDbGFtcGVkQXJyYXkiLCJpbXBvcnRTY3JpcHRzIiwiTWVzc2FnZUNoYW5uZWwiLCJ1c2VOZXh0VGljayIsIm5leHRUaWNrIiwidXNlVmVydHhUaW1lciIsInVzZVNldFRpbWVvdXQiLCJ1c2VNdXRhdGlvbk9ic2VydmVyIiwiaXRlcmF0aW9ucyIsIm9ic2VydmVyIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJ1c2VNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvcnQyIiwicG9zdE1lc3NhZ2UiLCJnbG9iYWxTZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsImF0dGVtcHRWZXJ0eCIsInZlcnR4IiwicnVuT25Mb29wIiwicnVuT25Db250ZXh0IiwiZSIsIm9uRnVsZmlsbG1lbnQiLCJvblJlamVjdGlvbiIsInBhcmVudCIsIm5vb3AiLCJQUk9NSVNFX0lEIiwibWFrZVByb21pc2UiLCJfc3RhdGUiLCJpbnZva2VDYWxsYmFjayIsIl9yZXN1bHQiLCJzdWJzY3JpYmUiLCJyZXNvbHZlJDEiLCJzdWJzdHJpbmciLCJQRU5ESU5HIiwiRlVMRklMTEVEIiwiUkVKRUNURUQiLCJzZWxmRnVsZmlsbG1lbnQiLCJjYW5ub3RSZXR1cm5Pd24iLCJ0cnlUaGVuIiwidGhlbiQkMSIsImZ1bGZpbGxtZW50SGFuZGxlciIsInJlamVjdGlvbkhhbmRsZXIiLCJoYW5kbGVGb3JlaWduVGhlbmFibGUiLCJ0aGVuYWJsZSIsInNlYWxlZCIsImZ1bGZpbGwiLCJyZWFzb24iLCJyZWplY3QiLCJfbGFiZWwiLCJoYW5kbGVPd25UaGVuYWJsZSIsImhhbmRsZU1heWJlVGhlbmFibGUiLCJtYXliZVRoZW5hYmxlIiwicHVibGlzaFJlamVjdGlvbiIsIl9vbmVycm9yIiwicHVibGlzaCIsIl9zdWJzY3JpYmVycyIsInN1YnNjcmliZXJzIiwic2V0dGxlZCIsImRldGFpbCIsImhhc0NhbGxiYWNrIiwic3VjY2VlZGVkIiwiaW5pdGlhbGl6ZVByb21pc2UiLCJyZXNvbHZlciIsInJlc29sdmVQcm9taXNlIiwicmVqZWN0UHJvbWlzZSIsIm5leHRJZCIsInZhbGlkYXRpb25FcnJvciIsIkVudW1lcmF0b3IiLCJfaW5zdGFuY2VDb25zdHJ1Y3RvciIsIl9yZW1haW5pbmciLCJfZW51bWVyYXRlIiwiX2VhY2hFbnRyeSIsImVudHJ5IiwicmVzb2x2ZSQkMSIsIl90aGVuIiwiZGlkRXJyb3IiLCJfc2V0dGxlZEF0IiwiUHJvbWlzZSQxIiwiX3dpbGxTZXR0bGVBdCIsImVudW1lcmF0b3IiLCJyYWNlIiwiXyIsInJlamVjdCQxIiwibmVlZHNSZXNvbHZlciIsIm5lZWRzTmV3IiwiY2F0Y2giLCJfY2F0Y2giLCJmaW5hbGx5IiwiX2ZpbmFsbHkiLCJfc2V0U2NoZWR1bGVyIiwiX3NldEFzYXAiLCJfYXNhcCIsInBvbHlmaWxsIiwibG9jYWwiLCJwcm9taXNlVG9TdHJpbmciLCJjYXN0IiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJnZXR0ZXIiLCJfX2VzTW9kdWxlIiwiZGVmaW5pdGlvbiIsIm8iLCJ0b1N0cmluZ1RhZyIsIl93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsIl9wbHVnaW5fanNwZGZfcGx1Z2luX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJfcGx1Z2luX3BhZ2VicmVha3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsIl9wbHVnaW5faHlwZXJsaW5rc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiaHRtbDJwZGYiLCJ3b3JrZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html2pdf.js/dist/html2pdf.js\n");

/***/ })

};
;