"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvg";
exports.ids = ["vendor-chunks/canvg"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvg/lib/index.es.js":
/*!********************************************!*\
  !*** ./node_modules/canvg/lib/index.es.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AElement: () => (/* binding */ AElement),\n/* harmony export */   AnimateColorElement: () => (/* binding */ AnimateColorElement),\n/* harmony export */   AnimateElement: () => (/* binding */ AnimateElement),\n/* harmony export */   AnimateTransformElement: () => (/* binding */ AnimateTransformElement),\n/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox),\n/* harmony export */   CB1: () => (/* binding */ CB1),\n/* harmony export */   CB2: () => (/* binding */ CB2),\n/* harmony export */   CB3: () => (/* binding */ CB3),\n/* harmony export */   CB4: () => (/* binding */ CB4),\n/* harmony export */   Canvg: () => (/* binding */ Canvg),\n/* harmony export */   CircleElement: () => (/* binding */ CircleElement),\n/* harmony export */   ClipPathElement: () => (/* binding */ ClipPathElement),\n/* harmony export */   DefsElement: () => (/* binding */ DefsElement),\n/* harmony export */   DescElement: () => (/* binding */ DescElement),\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   EllipseElement: () => (/* binding */ EllipseElement),\n/* harmony export */   FeColorMatrixElement: () => (/* binding */ FeColorMatrixElement),\n/* harmony export */   FeCompositeElement: () => (/* binding */ FeCompositeElement),\n/* harmony export */   FeDropShadowElement: () => (/* binding */ FeDropShadowElement),\n/* harmony export */   FeGaussianBlurElement: () => (/* binding */ FeGaussianBlurElement),\n/* harmony export */   FeMorphologyElement: () => (/* binding */ FeMorphologyElement),\n/* harmony export */   FilterElement: () => (/* binding */ FilterElement),\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontElement: () => (/* binding */ FontElement),\n/* harmony export */   FontFaceElement: () => (/* binding */ FontFaceElement),\n/* harmony export */   GElement: () => (/* binding */ GElement),\n/* harmony export */   GlyphElement: () => (/* binding */ GlyphElement),\n/* harmony export */   GradientElement: () => (/* binding */ GradientElement),\n/* harmony export */   ImageElement: () => (/* binding */ ImageElement),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearGradientElement: () => (/* binding */ LinearGradientElement),\n/* harmony export */   MarkerElement: () => (/* binding */ MarkerElement),\n/* harmony export */   MaskElement: () => (/* binding */ MaskElement),\n/* harmony export */   Matrix: () => (/* binding */ Matrix),\n/* harmony export */   MissingGlyphElement: () => (/* binding */ MissingGlyphElement),\n/* harmony export */   Mouse: () => (/* binding */ Mouse),\n/* harmony export */   PSEUDO_ZERO: () => (/* binding */ PSEUDO_ZERO),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   PathElement: () => (/* binding */ PathElement),\n/* harmony export */   PathParser: () => (/* binding */ PathParser),\n/* harmony export */   PatternElement: () => (/* binding */ PatternElement),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PolygonElement: () => (/* binding */ PolygonElement),\n/* harmony export */   PolylineElement: () => (/* binding */ PolylineElement),\n/* harmony export */   Property: () => (/* binding */ Property),\n/* harmony export */   QB1: () => (/* binding */ QB1),\n/* harmony export */   QB2: () => (/* binding */ QB2),\n/* harmony export */   QB3: () => (/* binding */ QB3),\n/* harmony export */   RadialGradientElement: () => (/* binding */ RadialGradientElement),\n/* harmony export */   RectElement: () => (/* binding */ RectElement),\n/* harmony export */   RenderedElement: () => (/* binding */ RenderedElement),\n/* harmony export */   Rotate: () => (/* binding */ Rotate),\n/* harmony export */   SVGElement: () => (/* binding */ SVGElement),\n/* harmony export */   SVGFontLoader: () => (/* binding */ SVGFontLoader),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   Screen: () => (/* binding */ Screen),\n/* harmony export */   Skew: () => (/* binding */ Skew),\n/* harmony export */   SkewX: () => (/* binding */ SkewX),\n/* harmony export */   SkewY: () => (/* binding */ SkewY),\n/* harmony export */   StopElement: () => (/* binding */ StopElement),\n/* harmony export */   StyleElement: () => (/* binding */ StyleElement),\n/* harmony export */   SymbolElement: () => (/* binding */ SymbolElement),\n/* harmony export */   TRefElement: () => (/* binding */ TRefElement),\n/* harmony export */   TSpanElement: () => (/* binding */ TSpanElement),\n/* harmony export */   TextElement: () => (/* binding */ TextElement),\n/* harmony export */   TextPathElement: () => (/* binding */ TextPathElement),\n/* harmony export */   TitleElement: () => (/* binding */ TitleElement),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   Translate: () => (/* binding */ Translate),\n/* harmony export */   UnknownElement: () => (/* binding */ UnknownElement),\n/* harmony export */   UseElement: () => (/* binding */ UseElement),\n/* harmony export */   ViewPort: () => (/* binding */ ViewPort),\n/* harmony export */   compressSpaces: () => (/* binding */ compressSpaces),\n/* harmony export */   \"default\": () => (/* binding */ Canvg),\n/* harmony export */   getSelectorSpecificity: () => (/* binding */ getSelectorSpecificity),\n/* harmony export */   normalizeAttributeName: () => (/* binding */ normalizeAttributeName),\n/* harmony export */   normalizeColor: () => (/* binding */ normalizeColor),\n/* harmony export */   parseExternalUrl: () => (/* binding */ parseExternalUrl),\n/* harmony export */   presets: () => (/* binding */ index),\n/* harmony export */   toNumbers: () => (/* binding */ toNumbers),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   vectorMagnitude: () => (/* binding */ vectorMagnitude),\n/* harmony export */   vectorsAngle: () => (/* binding */ vectorsAngle),\n/* harmony export */   vectorsRatio: () => (/* binding */ vectorsRatio)\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.promise.js */ \"(ssr)/./node_modules/core-js/modules/es.promise.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.string.match.js */ \"(ssr)/./node_modules/core-js/modules/es.string.match.js\");\n/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ \"(ssr)/./node_modules/core-js/modules/es.string.replace.js\");\n/* harmony import */ var core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.string.starts-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.starts-with.js\");\n/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.array.iterator.js\");\n/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.array.reduce.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reduce.js\");\n/* harmony import */ var core_js_modules_es_string_ends_with_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.string.ends-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.ends-with.js\");\n/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.string.split.js */ \"(ssr)/./node_modules/core-js/modules/es.string.split.js\");\n/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! raf */ \"(ssr)/./node_modules/raf/index.js\");\n/* harmony import */ var core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.string.trim.js */ \"(ssr)/./node_modules/core-js/modules/es.string.trim.js\");\n/* harmony import */ var rgbcolor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rgbcolor */ \"(ssr)/./node_modules/rgbcolor/index.js\");\n/* harmony import */ var core_js_modules_es_array_index_of_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"(ssr)/./node_modules/core-js/modules/es.array.index-of.js\");\n/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/es.string.includes.js */ \"(ssr)/./node_modules/core-js/modules/es.string.includes.js\");\n/* harmony import */ var core_js_modules_es_array_reverse_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reverse.js\");\n/* harmony import */ var svg_pathdata__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! svg-pathdata */ \"(ssr)/./node_modules/svg-pathdata/lib/SVGPathData.module.js\");\n/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.regexp.to-string.js\");\n/* harmony import */ var stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! stackblur-canvas */ \"(ssr)/./node_modules/stackblur-canvas/dist/stackblur-es.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Options preset for `OffscreenCanvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @returns Preset object.\r\n */ function offscreen() {\n    var { DOMParser: DOMParserFallback } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var preset = {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParserFallback,\n        createCanvas (width, height) {\n            return new OffscreenCanvas(width, height);\n        },\n        createImage (url) {\n            return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n                var response = yield fetch(url);\n                var blob = yield response.blob();\n                var img = yield createImageBitmap(blob);\n                return img;\n            })();\n        }\n    };\n    if (typeof DOMParser !== \"undefined\" || typeof DOMParserFallback === \"undefined\") {\n        Reflect.deleteProperty(preset, \"DOMParser\");\n    }\n    return preset;\n}\n/**\r\n * Options preset for `node-canvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @param config.canvas - `node-canvas` exports.\r\n * @param config.fetch - WHATWG-compatible `fetch` function.\r\n * @returns Preset object.\r\n */ function node(_ref) {\n    var { DOMParser: DOMParser1, canvas, fetch: fetch1 } = _ref;\n    return {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParser1,\n        fetch: fetch1,\n        createCanvas: canvas.createCanvas,\n        createImage: canvas.loadImage\n    };\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    offscreen: offscreen,\n    node: node\n});\n/**\r\n * HTML-safe compress white-spaces.\r\n * @param str - String to compress.\r\n * @returns String.\r\n */ function compressSpaces(str) {\n    return str.replace(/(?!\\u3000)\\s+/gm, \" \");\n}\n/**\r\n * HTML-safe left trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimLeft(str) {\n    return str.replace(/^[\\n \\t]+/, \"\");\n}\n/**\r\n * HTML-safe right trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimRight(str) {\n    return str.replace(/[\\n \\t]+$/, \"\");\n}\n/**\r\n * String to numbers array.\r\n * @param str - Numbers string.\r\n * @returns Numbers array.\r\n */ function toNumbers(str) {\n    var matches = (str || \"\").match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm) || [];\n    return matches.map(parseFloat);\n} // Microsoft Edge fix\nvar allUppercase = /^[A-Z-]+$/;\n/**\r\n * Normalize attribute name.\r\n * @param name - Attribute name.\r\n * @returns Normalized attribute name.\r\n */ function normalizeAttributeName(name) {\n    if (allUppercase.test(name)) {\n        return name.toLowerCase();\n    }\n    return name;\n}\n/**\r\n * Parse external URL.\r\n * @param url - CSS url string.\r\n * @returns Parsed URL.\r\n */ function parseExternalUrl(url) {\n    //                      single quotes [2]\n    //                      v         double quotes [3]\n    //                      v         v         no quotes [4]\n    //                      v         v         v\n    var urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url) || [];\n    return urlMatch[2] || urlMatch[3] || urlMatch[4];\n}\n/**\r\n * Transform floats to integers in rgb colors.\r\n * @param color - Color to normalize.\r\n * @returns Normalized color.\r\n */ function normalizeColor(color) {\n    if (!color.startsWith(\"rgb\")) {\n        return color;\n    }\n    var rgbParts = 3;\n    var normalizedColor = color.replace(/\\d+(\\.\\d+)?/g, (num, isFloat)=>rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);\n    return normalizedColor;\n}\n// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\nvar attributeRegex = /(\\[[^\\]]+\\])/g;\nvar idRegex = /(#[^\\s+>~.[:]+)/g;\nvar classRegex = /(\\.[^\\s+>~.[:]+)/g;\nvar pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nvar pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nvar elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n    var matches = regex.exec(selector);\n    if (!matches) {\n        return [\n            selector,\n            0\n        ];\n    }\n    return [\n        selector.replace(regex, \" \"),\n        matches.length\n    ];\n}\n/**\r\n * Measure selector specificity.\r\n * @param selector - Selector to measure.\r\n * @returns Specificity.\r\n */ function getSelectorSpecificity(selector) {\n    var specificity = [\n        0,\n        0,\n        0\n    ];\n    var currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, \"     $1 \").replace(/{[\\s\\S]*/gm, \" \");\n    var delta = 0;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);\n    specificity[0] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);\n    specificity[2] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);\n    specificity[1] += delta;\n    currentSelector = currentSelector.replace(/[*\\s+>~]/g, \" \").replace(/[#.]/g, \" \");\n    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex); // lgtm [js/useless-assignment-to-local]\n    specificity[2] += delta;\n    return specificity.join(\"\");\n}\nvar PSEUDO_ZERO = .00000001;\n/**\r\n * Vector magnitude.\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorMagnitude(v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n}\n/**\r\n * Ratio between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));\n}\n/**\r\n * Angle between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));\n}\nfunction CB1(t) {\n    return t * t * t;\n}\nfunction CB2(t) {\n    return 3 * t * t * (1 - t);\n}\nfunction CB3(t) {\n    return 3 * t * (1 - t) * (1 - t);\n}\nfunction CB4(t) {\n    return (1 - t) * (1 - t) * (1 - t);\n}\nfunction QB1(t) {\n    return t * t;\n}\nfunction QB2(t) {\n    return 2 * t * (1 - t);\n}\nfunction QB3(t) {\n    return (1 - t) * (1 - t);\n}\nclass Property {\n    constructor(document1, name, value){\n        this.document = document1;\n        this.name = name;\n        this.value = value;\n        this.isNormalizedColor = false;\n    }\n    static empty(document1) {\n        return new Property(document1, \"EMPTY\", \"\");\n    }\n    split() {\n        var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \" \";\n        var { document: document1, name } = this;\n        return compressSpaces(this.getString()).trim().split(separator).map((value)=>new Property(document1, name, value));\n    }\n    hasValue(zeroIsValue) {\n        var { value } = this;\n        return value !== null && value !== \"\" && (zeroIsValue || value !== 0) && typeof value !== \"undefined\";\n    }\n    isString(regexp) {\n        var { value } = this;\n        var result = typeof value === \"string\";\n        if (!result || !regexp) {\n            return result;\n        }\n        return regexp.test(value);\n    }\n    isUrlDefinition() {\n        return this.isString(/^url\\(/);\n    }\n    isPixels() {\n        if (!this.hasValue()) {\n            return false;\n        }\n        var asString = this.getString();\n        switch(true){\n            case asString.endsWith(\"px\"):\n            case /^[0-9]+$/.test(asString):\n                return true;\n            default:\n                return false;\n        }\n    }\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n    getValue(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return this.value;\n        }\n        return def;\n    }\n    getNumber(def) {\n        if (!this.hasValue()) {\n            if (typeof def === \"undefined\") {\n                return 0;\n            }\n            return parseFloat(def);\n        }\n        var { value } = this;\n        var n = parseFloat(value);\n        if (this.isString(/%$/)) {\n            n /= 100.0;\n        }\n        return n;\n    }\n    getString(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return typeof this.value === \"undefined\" ? \"\" : String(this.value);\n        }\n        return String(def);\n    }\n    getColor(def) {\n        var color = this.getString(def);\n        if (this.isNormalizedColor) {\n            return color;\n        }\n        this.isNormalizedColor = true;\n        color = normalizeColor(color);\n        this.value = color;\n        return color;\n    }\n    getDpi() {\n        return 96.0; // TODO: compute?\n    }\n    getRem() {\n        return this.document.rootEmSize;\n    }\n    getEm() {\n        return this.document.emSize;\n    }\n    getUnits() {\n        return this.getString().replace(/[0-9.-]/g, \"\");\n    }\n    getPixels(axisOrIsFontSize) {\n        var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this.hasValue()) {\n            return 0;\n        }\n        var [axis, isFontSize] = typeof axisOrIsFontSize === \"boolean\" ? [\n            undefined,\n            axisOrIsFontSize\n        ] : [\n            axisOrIsFontSize\n        ];\n        var { viewPort } = this.document.screen;\n        switch(true){\n            case this.isString(/vmin$/):\n                return this.getNumber() / 100.0 * Math.min(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vmax$/):\n                return this.getNumber() / 100.0 * Math.max(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vw$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"x\");\n            case this.isString(/vh$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"y\");\n            case this.isString(/rem$/):\n                return this.getNumber() * this.getRem();\n            case this.isString(/em$/):\n                return this.getNumber() * this.getEm();\n            case this.isString(/ex$/):\n                return this.getNumber() * this.getEm() / 2.0;\n            case this.isString(/px$/):\n                return this.getNumber();\n            case this.isString(/pt$/):\n                return this.getNumber() * this.getDpi() * (1.0 / 72.0);\n            case this.isString(/pc$/):\n                return this.getNumber() * 15;\n            case this.isString(/cm$/):\n                return this.getNumber() * this.getDpi() / 2.54;\n            case this.isString(/mm$/):\n                return this.getNumber() * this.getDpi() / 25.4;\n            case this.isString(/in$/):\n                return this.getNumber() * this.getDpi();\n            case this.isString(/%$/) && isFontSize:\n                return this.getNumber() * this.getEm();\n            case this.isString(/%$/):\n                return this.getNumber() * viewPort.computeSize(axis);\n            default:\n                {\n                    var n = this.getNumber();\n                    if (processPercent && n < 1.0) {\n                        return n * viewPort.computeSize(axis);\n                    }\n                    return n;\n                }\n        }\n    }\n    getMilliseconds() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        if (this.isString(/ms$/)) {\n            return this.getNumber();\n        }\n        return this.getNumber() * 1000;\n    }\n    getRadians() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        switch(true){\n            case this.isString(/deg$/):\n                return this.getNumber() * (Math.PI / 180.0);\n            case this.isString(/grad$/):\n                return this.getNumber() * (Math.PI / 200.0);\n            case this.isString(/rad$/):\n                return this.getNumber();\n            default:\n                return this.getNumber() * (Math.PI / 180.0);\n        }\n    }\n    getDefinition() {\n        var asString = this.getString();\n        var name = /#([^)'\"]+)/.exec(asString);\n        if (name) {\n            name = name[1];\n        }\n        if (!name) {\n            name = asString;\n        }\n        return this.document.definitions[name];\n    }\n    getFillStyleDefinition(element, opacity) {\n        var def = this.getDefinition();\n        if (!def) {\n            return null;\n        } // gradient\n        if (typeof def.createGradient === \"function\") {\n            return def.createGradient(this.document.ctx, element, opacity);\n        } // pattern\n        if (typeof def.createPattern === \"function\") {\n            if (def.getHrefAttribute().hasValue()) {\n                var patternTransform = def.getAttribute(\"patternTransform\");\n                def = def.getHrefAttribute().getDefinition();\n                if (patternTransform.hasValue()) {\n                    def.getAttribute(\"patternTransform\", true).setValue(patternTransform.value);\n                }\n            }\n            return def.createPattern(this.document.ctx, element, opacity);\n        }\n        return null;\n    }\n    getTextBaseline() {\n        if (!this.hasValue()) {\n            return null;\n        }\n        return Property.textBaselineMapping[this.getString()];\n    }\n    addOpacity(opacity) {\n        var value = this.getColor();\n        var len = value.length;\n        var commas = 0; // Simulate old RGBColor version, which can't parse rgba.\n        for(var i = 0; i < len; i++){\n            if (value[i] === \",\") {\n                commas++;\n            }\n            if (commas === 3) {\n                break;\n            }\n        }\n        if (opacity.hasValue() && this.isString() && commas !== 3) {\n            var color = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(value);\n            if (color.ok) {\n                color.alpha = opacity.getNumber();\n                value = color.toRGBA();\n            }\n        }\n        return new Property(this.document, this.name, value);\n    }\n}\nProperty.textBaselineMapping = {\n    \"baseline\": \"alphabetic\",\n    \"before-edge\": \"top\",\n    \"text-before-edge\": \"top\",\n    \"middle\": \"middle\",\n    \"central\": \"middle\",\n    \"after-edge\": \"bottom\",\n    \"text-after-edge\": \"bottom\",\n    \"ideographic\": \"ideographic\",\n    \"alphabetic\": \"alphabetic\",\n    \"hanging\": \"hanging\",\n    \"mathematical\": \"alphabetic\"\n};\nclass ViewPort {\n    constructor(){\n        this.viewPorts = [];\n    }\n    clear() {\n        this.viewPorts = [];\n    }\n    setCurrent(width, height) {\n        this.viewPorts.push({\n            width,\n            height\n        });\n    }\n    removeCurrent() {\n        this.viewPorts.pop();\n    }\n    getCurrent() {\n        var { viewPorts } = this;\n        return viewPorts[viewPorts.length - 1];\n    }\n    get width() {\n        return this.getCurrent().width;\n    }\n    get height() {\n        return this.getCurrent().height;\n    }\n    computeSize(d) {\n        if (typeof d === \"number\") {\n            return d;\n        }\n        if (d === \"x\") {\n            return this.width;\n        }\n        if (d === \"y\") {\n            return this.height;\n        }\n        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n    }\n}\nclass Point {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    static parse(point) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var [x = defaultValue, y = defaultValue] = toNumbers(point);\n        return new Point(x, y);\n    }\n    static parseScale(scale) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        var [x = defaultValue, y = x] = toNumbers(scale);\n        return new Point(x, y);\n    }\n    static parsePath(path) {\n        var points = toNumbers(path);\n        var len = points.length;\n        var pathPoints = [];\n        for(var i = 0; i < len; i += 2){\n            pathPoints.push(new Point(points[i], points[i + 1]));\n        }\n        return pathPoints;\n    }\n    angleTo(point) {\n        return Math.atan2(point.y - this.y, point.x - this.x);\n    }\n    applyTransform(transform) {\n        var { x, y } = this;\n        var xp = x * transform[0] + y * transform[2] + transform[4];\n        var yp = x * transform[1] + y * transform[3] + transform[5];\n        this.x = xp;\n        this.y = yp;\n    }\n}\nclass Mouse {\n    constructor(screen){\n        this.screen = screen;\n        this.working = false;\n        this.events = [];\n        this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n    isWorking() {\n        return this.working;\n    }\n    start() {\n        if (this.working) {\n            return;\n        }\n        var { screen, onClick, onMouseMove } = this;\n        var canvas = screen.ctx.canvas;\n        canvas.onclick = onClick;\n        canvas.onmousemove = onMouseMove;\n        this.working = true;\n    }\n    stop() {\n        if (!this.working) {\n            return;\n        }\n        var canvas = this.screen.ctx.canvas;\n        this.working = false;\n        canvas.onclick = null;\n        canvas.onmousemove = null;\n    }\n    hasEvents() {\n        return this.working && this.events.length > 0;\n    }\n    runEvents() {\n        if (!this.working) {\n            return;\n        }\n        var { screen: document1, events, eventElements } = this;\n        var { style } = document1.ctx.canvas;\n        if (style) {\n            style.cursor = \"\";\n        }\n        events.forEach((_ref, i)=>{\n            var { run } = _ref;\n            var element = eventElements[i];\n            while(element){\n                run(element);\n                element = element.parent;\n            }\n        }); // done running, clear\n        this.events = [];\n        this.eventElements = [];\n    }\n    checkPath(element, ctx) {\n        if (!this.working || !ctx) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref2, i)=>{\n            var { x, y } = _ref2;\n            if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    checkBoundingBox(element, boundingBox) {\n        if (!this.working || !boundingBox) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref3, i)=>{\n            var { x, y } = _ref3;\n            if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    mapXY(x, y) {\n        var { window: window1, ctx } = this.screen;\n        var point = new Point(x, y);\n        var element = ctx.canvas;\n        while(element){\n            point.x -= element.offsetLeft;\n            point.y -= element.offsetTop;\n            element = element.offsetParent;\n        }\n        if (window1.scrollX) {\n            point.x += window1.scrollX;\n        }\n        if (window1.scrollY) {\n            point.y += window1.scrollY;\n        }\n        return point;\n    }\n    onClick(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onclick\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onClick) {\n                    eventTarget.onClick();\n                }\n            }\n        });\n    }\n    onMouseMove(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onmousemove\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onMouseMove) {\n                    eventTarget.onMouseMove();\n                }\n            }\n        });\n    }\n}\nvar defaultWindow =  false ? 0 : null;\nvar defaultFetch$1 = typeof fetch !== \"undefined\" ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.\n : null;\nclass Screen {\n    constructor(ctx){\n        var { fetch: fetch1 = defaultFetch$1, window: window1 = defaultWindow } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.ctx = ctx;\n        this.FRAMERATE = 30;\n        this.MAX_VIRTUAL_PIXELS = 30000;\n        this.CLIENT_WIDTH = 800;\n        this.CLIENT_HEIGHT = 600;\n        this.viewPort = new ViewPort();\n        this.mouse = new Mouse(this);\n        this.animations = [];\n        this.waits = [];\n        this.frameDuration = 0;\n        this.isReadyLock = false;\n        this.isFirstRender = true;\n        this.intervalId = null;\n        this.window = window1;\n        this.fetch = fetch1;\n    }\n    wait(checker) {\n        this.waits.push(checker);\n    }\n    ready() {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        if (!this.readyPromise) {\n            return Promise.resolve();\n        }\n        return this.readyPromise;\n    }\n    isReady() {\n        if (this.isReadyLock) {\n            return true;\n        }\n        var isReadyLock = this.waits.every((_)=>_());\n        if (isReadyLock) {\n            this.waits = [];\n            if (this.resolveReady) {\n                this.resolveReady();\n            }\n        }\n        this.isReadyLock = isReadyLock;\n        return isReadyLock;\n    }\n    setDefaults(ctx) {\n        // initial values and defaults\n        ctx.strokeStyle = \"rgba(0,0,0,0)\";\n        ctx.lineCap = \"butt\";\n        ctx.lineJoin = \"miter\";\n        ctx.miterLimit = 4;\n    }\n    setViewBox(_ref) {\n        var { document: document1, ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX = 0, minY = 0, refX, refY, clip = false, clipX = 0, clipY = 0 } = _ref;\n        // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n        var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, \"\"); // ignore defer\n        var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(\" \");\n        var align = aspectRatioAlign || \"xMidYMid\";\n        var meetOrSlice = aspectRatioMeetOrSlice || \"meet\"; // calculate scale\n        var scaleX = width / desiredWidth;\n        var scaleY = height / desiredHeight;\n        var scaleMin = Math.min(scaleX, scaleY);\n        var scaleMax = Math.max(scaleX, scaleY);\n        var finalDesiredWidth = desiredWidth;\n        var finalDesiredHeight = desiredHeight;\n        if (meetOrSlice === \"meet\") {\n            finalDesiredWidth *= scaleMin;\n            finalDesiredHeight *= scaleMin;\n        }\n        if (meetOrSlice === \"slice\") {\n            finalDesiredWidth *= scaleMax;\n            finalDesiredHeight *= scaleMax;\n        }\n        var refXProp = new Property(document1, \"refX\", refX);\n        var refYProp = new Property(document1, \"refY\", refY);\n        var hasRefs = refXProp.hasValue() && refYProp.hasValue();\n        if (hasRefs) {\n            ctx.translate(-scaleMin * refXProp.getPixels(\"x\"), -scaleMin * refYProp.getPixels(\"y\"));\n        }\n        if (clip) {\n            var scaledClipX = scaleMin * clipX;\n            var scaledClipY = scaleMin * clipY;\n            ctx.beginPath();\n            ctx.moveTo(scaledClipX, scaledClipY);\n            ctx.lineTo(width, scaledClipY);\n            ctx.lineTo(width, height);\n            ctx.lineTo(scaledClipX, height);\n            ctx.closePath();\n            ctx.clip();\n        }\n        if (!hasRefs) {\n            var isMeetMinY = meetOrSlice === \"meet\" && scaleMin === scaleY;\n            var isSliceMaxY = meetOrSlice === \"slice\" && scaleMax === scaleY;\n            var isMeetMinX = meetOrSlice === \"meet\" && scaleMin === scaleX;\n            var isSliceMaxX = meetOrSlice === \"slice\" && scaleMax === scaleX;\n            if (align.startsWith(\"xMid\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);\n            }\n            if (align.endsWith(\"YMid\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);\n            }\n            if (align.startsWith(\"xMax\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width - finalDesiredWidth, 0);\n            }\n            if (align.endsWith(\"YMax\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height - finalDesiredHeight);\n            }\n        } // scale\n        switch(true){\n            case align === \"none\":\n                ctx.scale(scaleX, scaleY);\n                break;\n            case meetOrSlice === \"meet\":\n                ctx.scale(scaleMin, scaleMin);\n                break;\n            case meetOrSlice === \"slice\":\n                ctx.scale(scaleMax, scaleMax);\n                break;\n        } // translate\n        ctx.translate(-minX, -minY);\n    }\n    start(element) {\n        var { enableRedraw = false, ignoreMouse = false, ignoreAnimation = false, ignoreDimensions = false, ignoreClear = false, forceRedraw, scaleWidth, scaleHeight, offsetX, offsetY } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { FRAMERATE, mouse } = this;\n        var frameDuration = 1000 / FRAMERATE;\n        this.frameDuration = frameDuration;\n        this.readyPromise = new Promise((resolve)=>{\n            this.resolveReady = resolve;\n        });\n        if (this.isReady()) {\n            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n        }\n        if (!enableRedraw) {\n            return;\n        }\n        var now = Date.now();\n        var then = now;\n        var delta = 0;\n        var tick = ()=>{\n            now = Date.now();\n            delta = now - then;\n            if (delta >= frameDuration) {\n                then = now - delta % frameDuration;\n                if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                    mouse.runEvents();\n                }\n            }\n            this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n        };\n        if (!ignoreMouse) {\n            mouse.start();\n        }\n        this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n    }\n    stop() {\n        if (this.intervalId) {\n            raf__WEBPACK_IMPORTED_MODULE_11__.cancel(this.intervalId);\n            this.intervalId = null;\n        }\n        this.mouse.stop();\n    }\n    shouldUpdate(ignoreAnimation, forceRedraw) {\n        // need update from animations?\n        if (!ignoreAnimation) {\n            var { frameDuration } = this;\n            var shouldUpdate = this.animations.reduce((shouldUpdate, animation)=>animation.update(frameDuration) || shouldUpdate, false);\n            if (shouldUpdate) {\n                return true;\n            }\n        } // need update from redraw?\n        if (typeof forceRedraw === \"function\" && forceRedraw()) {\n            return true;\n        }\n        if (!this.isReadyLock && this.isReady()) {\n            return true;\n        } // need update from mouse events?\n        if (this.mouse.hasEvents()) {\n            return true;\n        }\n        return false;\n    }\n    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n        var { CLIENT_WIDTH, CLIENT_HEIGHT, viewPort, ctx, isFirstRender } = this;\n        var canvas = ctx.canvas;\n        viewPort.clear();\n        if (canvas.width && canvas.height) {\n            viewPort.setCurrent(canvas.width, canvas.height);\n        } else {\n            viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);\n        }\n        var widthStyle = element.getStyle(\"width\");\n        var heightStyle = element.getStyle(\"height\");\n        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== \"number\" && typeof scaleHeight !== \"number\")) {\n            // set canvas size\n            if (widthStyle.hasValue()) {\n                canvas.width = widthStyle.getPixels(\"x\");\n                if (canvas.style) {\n                    canvas.style.width = \"\".concat(canvas.width, \"px\");\n                }\n            }\n            if (heightStyle.hasValue()) {\n                canvas.height = heightStyle.getPixels(\"y\");\n                if (canvas.style) {\n                    canvas.style.height = \"\".concat(canvas.height, \"px\");\n                }\n            }\n        }\n        var cWidth = canvas.clientWidth || canvas.width;\n        var cHeight = canvas.clientHeight || canvas.height;\n        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n            cWidth = widthStyle.getPixels(\"x\");\n            cHeight = heightStyle.getPixels(\"y\");\n        }\n        viewPort.setCurrent(cWidth, cHeight);\n        if (typeof offsetX === \"number\") {\n            element.getAttribute(\"x\", true).setValue(offsetX);\n        }\n        if (typeof offsetY === \"number\") {\n            element.getAttribute(\"y\", true).setValue(offsetY);\n        }\n        if (typeof scaleWidth === \"number\" || typeof scaleHeight === \"number\") {\n            var viewBox = toNumbers(element.getAttribute(\"viewBox\").getString());\n            var xRatio = 0;\n            var yRatio = 0;\n            if (typeof scaleWidth === \"number\") {\n                var _widthStyle = element.getStyle(\"width\");\n                if (_widthStyle.hasValue()) {\n                    xRatio = _widthStyle.getPixels(\"x\") / scaleWidth;\n                } else if (!isNaN(viewBox[2])) {\n                    xRatio = viewBox[2] / scaleWidth;\n                }\n            }\n            if (typeof scaleHeight === \"number\") {\n                var _heightStyle = element.getStyle(\"height\");\n                if (_heightStyle.hasValue()) {\n                    yRatio = _heightStyle.getPixels(\"y\") / scaleHeight;\n                } else if (!isNaN(viewBox[3])) {\n                    yRatio = viewBox[3] / scaleHeight;\n                }\n            }\n            if (!xRatio) {\n                xRatio = yRatio;\n            }\n            if (!yRatio) {\n                yRatio = xRatio;\n            }\n            element.getAttribute(\"width\", true).setValue(scaleWidth);\n            element.getAttribute(\"height\", true).setValue(scaleHeight);\n            var transformStyle = element.getStyle(\"transform\", true, true);\n            transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1.0 / xRatio, \", \").concat(1.0 / yRatio, \")\"));\n        } // clear and render\n        if (!ignoreClear) {\n            ctx.clearRect(0, 0, cWidth, cHeight);\n        }\n        element.render(ctx);\n        if (isFirstRender) {\n            this.isFirstRender = false;\n        }\n    }\n}\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nvar { defaultFetch } = Screen;\nvar DefaultDOMParser = typeof DOMParser !== \"undefined\" ? DOMParser : null;\nclass Parser {\n    constructor(){\n        var { fetch: fetch1 = defaultFetch, DOMParser: DOMParser1 = DefaultDOMParser } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.fetch = fetch1;\n        this.DOMParser = DOMParser1;\n    }\n    parse(resource) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            if (resource.startsWith(\"<\")) {\n                return _this.parseFromString(resource);\n            }\n            return _this.load(resource);\n        })();\n    }\n    parseFromString(xml) {\n        var parser = new this.DOMParser();\n        try {\n            return this.checkDocument(parser.parseFromString(xml, \"image/svg+xml\"));\n        } catch (err) {\n            return this.checkDocument(parser.parseFromString(xml, \"text/xml\"));\n        }\n    }\n    checkDocument(document1) {\n        var parserError = document1.getElementsByTagName(\"parsererror\")[0];\n        if (parserError) {\n            throw new Error(parserError.textContent);\n        }\n        return document1;\n    }\n    load(url) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var response = yield _this2.fetch(url);\n            var xml = yield response.text();\n            return _this2.parseFromString(xml);\n        })();\n    }\n}\nclass Translate {\n    constructor(_, point){\n        this.type = \"translate\";\n        this.point = null;\n        this.point = Point.parse(point);\n    }\n    apply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(x || 0.0, y || 0.0);\n    }\n    unapply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.point;\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            x || 0.0,\n            y || 0.0\n        ]);\n    }\n}\nclass Rotate {\n    constructor(document1, rotate, transformOrigin){\n        this.type = \"rotate\";\n        this.angle = null;\n        this.originX = null;\n        this.originY = null;\n        this.cx = 0;\n        this.cy = 0;\n        var numbers = toNumbers(rotate);\n        this.angle = new Property(document1, \"angle\", numbers[0]);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n        this.cx = numbers[1] || 0;\n        this.cy = numbers[2] || 0;\n    }\n    apply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(-1.0 * angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { cx, cy, angle } = this;\n        var rad = angle.getRadians();\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            cx || 0.0,\n            cy || 0.0 // this.p.y\n        ]);\n        point.applyTransform([\n            Math.cos(rad),\n            Math.sin(rad),\n            -Math.sin(rad),\n            Math.cos(rad),\n            0,\n            0\n        ]);\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            -cx || 0.0,\n            -cy || 0.0 // -this.p.y\n        ]);\n    }\n}\nclass Scale {\n    constructor(_, scale, transformOrigin){\n        this.type = \"scale\";\n        this.scale = null;\n        this.originX = null;\n        this.originY = null;\n        var scaleSize = Point.parseScale(scale); // Workaround for node-canvas\n        if (scaleSize.x === 0 || scaleSize.y === 0) {\n            scaleSize.x = PSEUDO_ZERO;\n            scaleSize.y = PSEUDO_ZERO;\n        }\n        this.scale = scaleSize;\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(x, y || x);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(1.0 / x, 1.0 / y || x);\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.scale;\n        point.applyTransform([\n            x || 0.0,\n            0,\n            0,\n            y || 0.0,\n            0,\n            0\n        ]);\n    }\n}\nclass Matrix {\n    constructor(_, matrix, transformOrigin){\n        this.type = \"matrix\";\n        this.matrix = [];\n        this.originX = null;\n        this.originY = null;\n        this.matrix = toNumbers(matrix);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { originX, originY, matrix } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { originX, originY, matrix } = this;\n        var a = matrix[0];\n        var b = matrix[2];\n        var c = matrix[4];\n        var d = matrix[1];\n        var e = matrix[3];\n        var f = matrix[5];\n        var g = 0.0;\n        var h = 0.0;\n        var i = 1.0;\n        var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        point.applyTransform(this.matrix);\n    }\n}\nclass Skew extends Matrix {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skew\";\n        this.angle = null;\n        this.angle = new Property(document1, \"angle\", skew);\n    }\n}\nclass SkewX extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewX\";\n        this.matrix = [\n            1,\n            0,\n            Math.tan(this.angle.getRadians()),\n            1,\n            0,\n            0\n        ];\n    }\n}\nclass SkewY extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewY\";\n        this.matrix = [\n            1,\n            Math.tan(this.angle.getRadians()),\n            0,\n            1,\n            0,\n            0\n        ];\n    }\n}\nfunction parseTransforms(transform) {\n    return compressSpaces(transform).trim().replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform) {\n    var [type, value] = transform.split(\"(\");\n    return [\n        type.trim(),\n        value.trim().replace(\")\", \"\")\n    ];\n}\nclass Transform {\n    constructor(document1, transform, transformOrigin){\n        this.document = document1;\n        this.transforms = [];\n        var data = parseTransforms(transform);\n        data.forEach((transform)=>{\n            if (transform === \"none\") {\n                return;\n            }\n            var [type, value] = parseTransform(transform);\n            var TransformType = Transform.transformTypes[type];\n            if (typeof TransformType !== \"undefined\") {\n                this.transforms.push(new TransformType(this.document, value, transformOrigin));\n            }\n        });\n    }\n    static fromElement(document1, element) {\n        var transformStyle = element.getStyle(\"transform\", false, true);\n        var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle(\"transform-origin\", false, true).split();\n        var transformOrigin = [\n            transformOriginXProperty,\n            transformOriginYProperty\n        ];\n        if (transformStyle.hasValue()) {\n            return new Transform(document1, transformStyle.getString(), transformOrigin);\n        }\n        return null;\n    }\n    apply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].apply(ctx);\n        }\n    }\n    unapply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = len - 1; i >= 0; i--){\n            transforms[i].unapply(ctx);\n        }\n    }\n    applyToPoint(point) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].applyToPoint(point);\n        }\n    }\n}\nTransform.transformTypes = {\n    translate: Translate,\n    rotate: Rotate,\n    scale: Scale,\n    matrix: Matrix,\n    skewX: SkewX,\n    skewY: SkewY\n};\nclass Element {\n    constructor(document1, node){\n        var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.document = document1;\n        this.node = node;\n        this.captureTextNodes = captureTextNodes;\n        this.attributes = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.animationFrozen = false;\n        this.animationFrozenValue = \"\";\n        this.parent = null;\n        this.children = [];\n        if (!node || node.nodeType !== 1) {\n            // ELEMENT_NODE\n            return;\n        } // add attributes\n        Array.from(node.attributes).forEach((attribute)=>{\n            var nodeName = normalizeAttributeName(attribute.nodeName);\n            this.attributes[nodeName] = new Property(document1, nodeName, attribute.value);\n        });\n        this.addStylesFromStyleDefinition(); // add inline styles\n        if (this.getAttribute(\"style\").hasValue()) {\n            var styles = this.getAttribute(\"style\").getString().split(\";\").map((_)=>_.trim());\n            styles.forEach((style)=>{\n                if (!style) {\n                    return;\n                }\n                var [name, value] = style.split(\":\").map((_)=>_.trim());\n                this.styles[name] = new Property(document1, name, value);\n            });\n        }\n        var { definitions } = document1;\n        var id = this.getAttribute(\"id\"); // add id\n        if (id.hasValue()) {\n            if (!definitions[id.getString()]) {\n                definitions[id.getString()] = this;\n            }\n        }\n        Array.from(node.childNodes).forEach((childNode)=>{\n            if (childNode.nodeType === 1) {\n                this.addChild(childNode); // ELEMENT_NODE\n            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n                var textNode = document1.createTextNode(childNode);\n                if (textNode.getText().length > 0) {\n                    this.addChild(textNode); // TEXT_NODE\n                }\n            }\n        });\n    }\n    getAttribute(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var attr = this.attributes[name];\n        if (!attr && createIfNotExists) {\n            var _attr = new Property(this.document, name, \"\");\n            this.attributes[name] = _attr;\n            return _attr;\n        }\n        return attr || Property.empty(this.document);\n    }\n    getHrefAttribute() {\n        for(var key in this.attributes){\n            if (key === \"href\" || key.endsWith(\":href\")) {\n                return this.attributes[key];\n            }\n        }\n        return Property.empty(this.document);\n    }\n    getStyle(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var style = this.styles[name];\n        if (style) {\n            return style;\n        }\n        var attr = this.getAttribute(name);\n        if (attr !== null && attr !== void 0 && attr.hasValue()) {\n            this.styles[name] = attr; // move up to me to cache\n            return attr;\n        }\n        if (!skipAncestors) {\n            var { parent } = this;\n            if (parent) {\n                var parentStyle = parent.getStyle(name);\n                if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {\n                    return parentStyle;\n                }\n            }\n        }\n        if (createIfNotExists) {\n            var _style = new Property(this.document, name, \"\");\n            this.styles[name] = _style;\n            return _style;\n        }\n        return style || Property.empty(this.document);\n    }\n    render(ctx) {\n        // don't render display=none\n        // don't render visibility=hidden\n        if (this.getStyle(\"display\").getString() === \"none\" || this.getStyle(\"visibility\").getString() === \"hidden\") {\n            return;\n        }\n        ctx.save();\n        if (this.getStyle(\"mask\").hasValue()) {\n            // mask\n            var mask = this.getStyle(\"mask\").getDefinition();\n            if (mask) {\n                this.applyEffects(ctx);\n                mask.apply(ctx, this);\n            }\n        } else if (this.getStyle(\"filter\").getValue(\"none\") !== \"none\") {\n            // filter\n            var filter = this.getStyle(\"filter\").getDefinition();\n            if (filter) {\n                this.applyEffects(ctx);\n                filter.apply(ctx, this);\n            }\n        } else {\n            this.setContext(ctx);\n            this.renderChildren(ctx);\n            this.clearContext(ctx);\n        }\n        ctx.restore();\n    }\n    setContext(_) {}\n    applyEffects(ctx) {\n        // transform\n        var transform = Transform.fromElement(this.document, this);\n        if (transform) {\n            transform.apply(ctx);\n        } // clip\n        var clipPathStyleProp = this.getStyle(\"clip-path\", false, true);\n        if (clipPathStyleProp.hasValue()) {\n            var clip = clipPathStyleProp.getDefinition();\n            if (clip) {\n                clip.apply(ctx);\n            }\n        }\n    }\n    clearContext(_) {}\n    renderChildren(ctx) {\n        this.children.forEach((child)=>{\n            child.render(ctx);\n        });\n    }\n    addChild(childNode) {\n        var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);\n        child.parent = this;\n        if (!Element.ignoreChildTypes.includes(child.type)) {\n            this.children.push(child);\n        }\n    }\n    matchesSelector(selector) {\n        var _node$getAttribute;\n        var { node } = this;\n        if (typeof node.matches === \"function\") {\n            return node.matches(selector);\n        }\n        var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, \"class\");\n        if (!styleClasses || styleClasses === \"\") {\n            return false;\n        }\n        return styleClasses.split(\" \").some((styleClass)=>\".\".concat(styleClass) === selector);\n    }\n    addStylesFromStyleDefinition() {\n        var { styles, stylesSpecificity } = this.document;\n        for(var selector in styles){\n            if (!selector.startsWith(\"@\") && this.matchesSelector(selector)) {\n                var style = styles[selector];\n                var specificity = stylesSpecificity[selector];\n                if (style) {\n                    for(var name in style){\n                        var existingSpecificity = this.stylesSpecificity[name];\n                        if (typeof existingSpecificity === \"undefined\") {\n                            existingSpecificity = \"000\";\n                        }\n                        if (specificity >= existingSpecificity) {\n                            this.styles[name] = style[name];\n                            this.stylesSpecificity[name] = specificity;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    removeStyles(element, ignoreStyles) {\n        var toRestore = ignoreStyles.reduce((toRestore, name)=>{\n            var styleProp = element.getStyle(name);\n            if (!styleProp.hasValue()) {\n                return toRestore;\n            }\n            var value = styleProp.getString();\n            styleProp.setValue(\"\");\n            return [\n                ...toRestore,\n                [\n                    name,\n                    value\n                ]\n            ];\n        }, []);\n        return toRestore;\n    }\n    restoreStyles(element, styles) {\n        styles.forEach((_ref)=>{\n            var [name, value] = _ref;\n            element.getStyle(name, true).setValue(value);\n        });\n    }\n    isFirstChild() {\n        var _this$parent;\n        return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;\n    }\n}\nElement.ignoreChildTypes = [\n    \"title\"\n];\nclass UnknownElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n    }\n}\nfunction wrapFontFamily(fontFamily) {\n    var trimmed = fontFamily.trim();\n    return /^('|\")/.test(trimmed) ? trimmed : '\"'.concat(trimmed, '\"');\n}\nfunction prepareFontFamily(fontFamily) {\n    return typeof process === \"undefined\" ? fontFamily : fontFamily.trim().split(\",\").map(wrapFontFamily).join(\",\");\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style\r\n * @param fontStyle\r\n * @returns CSS font style.\r\n */ function prepareFontStyle(fontStyle) {\n    if (!fontStyle) {\n        return \"\";\n    }\n    var targetFontStyle = fontStyle.trim().toLowerCase();\n    switch(targetFontStyle){\n        case \"normal\":\n        case \"italic\":\n        case \"oblique\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontStyle;\n        default:\n            if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n                return targetFontStyle;\n            }\n            return \"\";\n    }\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight\r\n * @param fontWeight\r\n * @returns CSS font weight.\r\n */ function prepareFontWeight(fontWeight) {\n    if (!fontWeight) {\n        return \"\";\n    }\n    var targetFontWeight = fontWeight.trim().toLowerCase();\n    switch(targetFontWeight){\n        case \"normal\":\n        case \"bold\":\n        case \"lighter\":\n        case \"bolder\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontWeight;\n        default:\n            if (/^[\\d.]+$/.test(targetFontWeight)) {\n                return targetFontWeight;\n            }\n            return \"\";\n    }\n}\nclass Font {\n    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit){\n        var inheritFont = inherit ? typeof inherit === \"string\" ? Font.parse(inherit) : inherit : {};\n        this.fontFamily = fontFamily || inheritFont.fontFamily;\n        this.fontSize = fontSize || inheritFont.fontSize;\n        this.fontStyle = fontStyle || inheritFont.fontStyle;\n        this.fontWeight = fontWeight || inheritFont.fontWeight;\n        this.fontVariant = fontVariant || inheritFont.fontVariant;\n    }\n    static parse() {\n        var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n        var inherit = arguments.length > 1 ? arguments[1] : undefined;\n        var fontStyle = \"\";\n        var fontVariant = \"\";\n        var fontWeight = \"\";\n        var fontSize = \"\";\n        var fontFamily = \"\";\n        var parts = compressSpaces(font).trim().split(\" \");\n        var set = {\n            fontSize: false,\n            fontStyle: false,\n            fontWeight: false,\n            fontVariant: false\n        };\n        parts.forEach((part)=>{\n            switch(true){\n                case !set.fontStyle && Font.styles.includes(part):\n                    if (part !== \"inherit\") {\n                        fontStyle = part;\n                    }\n                    set.fontStyle = true;\n                    break;\n                case !set.fontVariant && Font.variants.includes(part):\n                    if (part !== \"inherit\") {\n                        fontVariant = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    break;\n                case !set.fontWeight && Font.weights.includes(part):\n                    if (part !== \"inherit\") {\n                        fontWeight = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    break;\n                case !set.fontSize:\n                    if (part !== \"inherit\") {\n                        [fontSize] = part.split(\"/\");\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    set.fontSize = true;\n                    break;\n                default:\n                    if (part !== \"inherit\") {\n                        fontFamily += part;\n                    }\n            }\n        });\n        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);\n    }\n    toString() {\n        return [\n            prepareFontStyle(this.fontStyle),\n            this.fontVariant,\n            prepareFontWeight(this.fontWeight),\n            this.fontSize,\n            prepareFontFamily(this.fontFamily)\n        ].join(\" \").trim();\n    }\n}\nFont.styles = \"normal|italic|oblique|inherit\";\nFont.variants = \"normal|small-caps|inherit\";\nFont.weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\";\nclass BoundingBox {\n    constructor(){\n        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;\n        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;\n        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;\n        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    get x() {\n        return this.x1;\n    }\n    get y() {\n        return this.y1;\n    }\n    get width() {\n        return this.x2 - this.x1;\n    }\n    get height() {\n        return this.y2 - this.y1;\n    }\n    addPoint(x, y) {\n        if (typeof x !== \"undefined\") {\n            if (isNaN(this.x1) || isNaN(this.x2)) {\n                this.x1 = x;\n                this.x2 = x;\n            }\n            if (x < this.x1) {\n                this.x1 = x;\n            }\n            if (x > this.x2) {\n                this.x2 = x;\n            }\n        }\n        if (typeof y !== \"undefined\") {\n            if (isNaN(this.y1) || isNaN(this.y2)) {\n                this.y1 = y;\n                this.y2 = y;\n            }\n            if (y < this.y1) {\n                this.y1 = y;\n            }\n            if (y > this.y2) {\n                this.y2 = y;\n            }\n        }\n    }\n    addX(x) {\n        this.addPoint(x, null);\n    }\n    addY(y) {\n        this.addPoint(null, y);\n    }\n    addBoundingBox(boundingBox) {\n        if (!boundingBox) {\n            return;\n        }\n        var { x1, y1, x2, y2 } = boundingBox;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    sumCubic(t, p0, p1, p2, p3) {\n        return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n    }\n    bezierCurveAdd(forX, p0, p1, p2, p3) {\n        var b = 6 * p0 - 12 * p1 + 6 * p2;\n        var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n        var c = 3 * p1 - 3 * p0;\n        if (a === 0) {\n            if (b === 0) {\n                return;\n            }\n            var t = -c / b;\n            if (0 < t && t < 1) {\n                if (forX) {\n                    this.addX(this.sumCubic(t, p0, p1, p2, p3));\n                } else {\n                    this.addY(this.sumCubic(t, p0, p1, p2, p3));\n                }\n            }\n            return;\n        }\n        var b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) {\n            return;\n        }\n        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t1, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t1, p0, p1, p2, p3));\n            }\n        }\n        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t2, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t2, p0, p1, p2, p3));\n            }\n        }\n    }\n    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n        this.addPoint(p0x, p0y);\n        this.addPoint(p3x, p3y);\n        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n    }\n    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n        var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n    }\n    isPointInBox(x, y) {\n        var { x1, y1, x2, y2 } = this;\n        return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n    }\n}\nclass PathParser extends svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData {\n    constructor(path){\n        super(path // Fix spaces after signs.\n        .replace(/([+\\-.])\\s+/gm, \"$1\") // Remove invalid part.\n        .replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, \"\"));\n        this.control = null;\n        this.start = null;\n        this.current = null;\n        this.command = null;\n        this.commands = this.commands;\n        this.i = -1;\n        this.previousCommand = null;\n        this.points = [];\n        this.angles = [];\n    }\n    reset() {\n        this.i = -1;\n        this.command = null;\n        this.previousCommand = null;\n        this.start = new Point(0, 0);\n        this.control = new Point(0, 0);\n        this.current = new Point(0, 0);\n        this.points = [];\n        this.angles = [];\n    }\n    isEnd() {\n        var { i, commands } = this;\n        return i >= commands.length - 1;\n    }\n    next() {\n        var command = this.commands[++this.i];\n        this.previousCommand = this.command;\n        this.command = command;\n        return command;\n    }\n    getPoint() {\n        var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"x\";\n        var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"y\";\n        var point = new Point(this.command[xProp], this.command[yProp]);\n        return this.makeAbsolute(point);\n    }\n    getAsControlPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.control = point;\n        return point;\n    }\n    getAsCurrentPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.current = point;\n        return point;\n    }\n    getReflectedControlPoint() {\n        var previousCommand = this.previousCommand.type;\n        if (previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.QUAD_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_QUAD_TO) {\n            return this.current;\n        } // reflect point\n        var { current: { x: cx, y: cy }, control: { x: ox, y: oy } } = this;\n        var point = new Point(2 * cx - ox, 2 * cy - oy);\n        return point;\n    }\n    makeAbsolute(point) {\n        if (this.command.relative) {\n            var { x, y } = this.current;\n            point.x += x;\n            point.y += y;\n        }\n        return point;\n    }\n    addMarker(point, from, priorTo) {\n        var { points, angles } = this; // if the last angle isn't filled in because we didn't have this point yet ...\n        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n            angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n        }\n        this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n    }\n    addMarkerAngle(point, angle) {\n        this.points.push(point);\n        this.angles.push(angle);\n    }\n    getMarkerPoints() {\n        return this.points;\n    }\n    getMarkerAngles() {\n        var { angles } = this;\n        var len = angles.length;\n        for(var i = 0; i < len; i++){\n            if (!angles[i]) {\n                for(var j = i + 1; j < len; j++){\n                    if (angles[j]) {\n                        angles[i] = angles[j];\n                        break;\n                    }\n                }\n            }\n        }\n        return angles;\n    }\n}\nclass RenderedElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.modifiedEmSizeStack = false;\n    }\n    calculateOpacity() {\n        var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var element = this;\n        while(element){\n            var opacityStyle = element.getStyle(\"opacity\", false, true); // no ancestors on style call\n            if (opacityStyle.hasValue(true)) {\n                opacity *= opacityStyle.getNumber();\n            }\n            element = element.parent;\n        }\n        return opacity;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!fromMeasure) {\n            // causes stack overflow when measuring text with gradients\n            // fill\n            var fillStyleProp = this.getStyle(\"fill\");\n            var fillOpacityStyleProp = this.getStyle(\"fill-opacity\");\n            var strokeStyleProp = this.getStyle(\"stroke\");\n            var strokeOpacityProp = this.getStyle(\"stroke-opacity\");\n            if (fillStyleProp.isUrlDefinition()) {\n                var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n                if (fillStyle) {\n                    ctx.fillStyle = fillStyle;\n                }\n            } else if (fillStyleProp.hasValue()) {\n                if (fillStyleProp.getString() === \"currentColor\") {\n                    fillStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _fillStyle = fillStyleProp.getColor();\n                if (_fillStyle !== \"inherit\") {\n                    ctx.fillStyle = _fillStyle === \"none\" ? \"rgba(0,0,0,0)\" : _fillStyle;\n                }\n            }\n            if (fillOpacityStyleProp.hasValue()) {\n                var _fillStyle2 = new Property(this.document, \"fill\", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n                ctx.fillStyle = _fillStyle2;\n            } // stroke\n            if (strokeStyleProp.isUrlDefinition()) {\n                var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n                if (strokeStyle) {\n                    ctx.strokeStyle = strokeStyle;\n                }\n            } else if (strokeStyleProp.hasValue()) {\n                if (strokeStyleProp.getString() === \"currentColor\") {\n                    strokeStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _strokeStyle = strokeStyleProp.getString();\n                if (_strokeStyle !== \"inherit\") {\n                    ctx.strokeStyle = _strokeStyle === \"none\" ? \"rgba(0,0,0,0)\" : _strokeStyle;\n                }\n            }\n            if (strokeOpacityProp.hasValue()) {\n                var _strokeStyle2 = new Property(this.document, \"stroke\", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n                ctx.strokeStyle = _strokeStyle2;\n            }\n            var strokeWidthStyleProp = this.getStyle(\"stroke-width\");\n            if (strokeWidthStyleProp.hasValue()) {\n                var newLineWidth = strokeWidthStyleProp.getPixels();\n                ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)\n                 : newLineWidth;\n            }\n            var strokeLinecapStyleProp = this.getStyle(\"stroke-linecap\");\n            var strokeLinejoinStyleProp = this.getStyle(\"stroke-linejoin\");\n            var strokeMiterlimitProp = this.getStyle(\"stroke-miterlimit\"); // NEED TEST\n            // const pointOrderStyleProp = this.getStyle('paint-order');\n            var strokeDasharrayStyleProp = this.getStyle(\"stroke-dasharray\");\n            var strokeDashoffsetProp = this.getStyle(\"stroke-dashoffset\");\n            if (strokeLinecapStyleProp.hasValue()) {\n                ctx.lineCap = strokeLinecapStyleProp.getString();\n            }\n            if (strokeLinejoinStyleProp.hasValue()) {\n                ctx.lineJoin = strokeLinejoinStyleProp.getString();\n            }\n            if (strokeMiterlimitProp.hasValue()) {\n                ctx.miterLimit = strokeMiterlimitProp.getNumber();\n            } // NEED TEST\n            // if (pointOrderStyleProp.hasValue()) {\n            // \t// ?\n            // \tctx.paintOrder = pointOrderStyleProp.getValue();\n            // }\n            if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== \"none\") {\n                var gaps = toNumbers(strokeDasharrayStyleProp.getString());\n                if (typeof ctx.setLineDash !== \"undefined\") {\n                    ctx.setLineDash(gaps);\n                } else if (typeof ctx.webkitLineDash !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDash = gaps;\n                } else if (typeof ctx.mozDash !== \"undefined\" && !(gaps.length === 1 && gaps[0] === 0)) {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDash = gaps;\n                }\n                var offset = strokeDashoffsetProp.getPixels();\n                if (typeof ctx.lineDashOffset !== \"undefined\") {\n                    ctx.lineDashOffset = offset;\n                } else if (typeof ctx.webkitLineDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDashOffset = offset;\n                } else if (typeof ctx.mozDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDashOffset = offset;\n                }\n            }\n        } // font\n        this.modifiedEmSizeStack = false;\n        if (typeof ctx.font !== \"undefined\") {\n            var fontStyleProp = this.getStyle(\"font\");\n            var fontStyleStyleProp = this.getStyle(\"font-style\");\n            var fontVariantStyleProp = this.getStyle(\"font-variant\");\n            var fontWeightStyleProp = this.getStyle(\"font-weight\");\n            var fontSizeStyleProp = this.getStyle(\"font-size\");\n            var fontFamilyStyleProp = this.getStyle(\"font-family\");\n            var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : \"\", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n            fontStyleStyleProp.setValue(font.fontStyle);\n            fontVariantStyleProp.setValue(font.fontVariant);\n            fontWeightStyleProp.setValue(font.fontWeight);\n            fontSizeStyleProp.setValue(font.fontSize);\n            fontFamilyStyleProp.setValue(font.fontFamily);\n            ctx.font = font.toString();\n            if (fontSizeStyleProp.isPixels()) {\n                this.document.emSize = fontSizeStyleProp.getPixels();\n                this.modifiedEmSizeStack = true;\n            }\n        }\n        if (!fromMeasure) {\n            // effects\n            this.applyEffects(ctx); // opacity\n            ctx.globalAlpha = this.calculateOpacity();\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        if (this.modifiedEmSizeStack) {\n            this.document.popEmSize();\n        }\n    }\n}\nclass PathElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"path\";\n        this.pathParser = null;\n        this.pathParser = new PathParser(this.getAttribute(\"d\").getString());\n    }\n    path(ctx) {\n        var { pathParser } = this;\n        var boundingBox = new BoundingBox();\n        pathParser.reset();\n        if (ctx) {\n            ctx.beginPath();\n        }\n        while(!pathParser.isEnd()){\n            switch(pathParser.next().type){\n                case PathParser.MOVE_TO:\n                    this.pathM(ctx, boundingBox);\n                    break;\n                case PathParser.LINE_TO:\n                    this.pathL(ctx, boundingBox);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    this.pathH(ctx, boundingBox);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    this.pathV(ctx, boundingBox);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    this.pathS(ctx, boundingBox);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    this.pathT(ctx, boundingBox);\n                    break;\n                case PathParser.ARC:\n                    this.pathA(ctx, boundingBox);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    this.pathZ(ctx, boundingBox);\n                    break;\n            }\n        }\n        return boundingBox;\n    }\n    getBoundingBox(_) {\n        return this.path();\n    }\n    getMarkers() {\n        var { pathParser } = this;\n        var points = pathParser.getMarkerPoints();\n        var angles = pathParser.getMarkerAngles();\n        var markers = points.map((point, i)=>[\n                point,\n                angles[i]\n            ]);\n        return markers;\n    }\n    renderChildren(ctx) {\n        this.path(ctx);\n        this.document.screen.mouse.checkPath(this, ctx);\n        var fillRuleStyleProp = this.getStyle(\"fill-rule\");\n        if (ctx.fillStyle !== \"\") {\n            if (fillRuleStyleProp.getString(\"inherit\") !== \"inherit\") {\n                ctx.fill(fillRuleStyleProp.getString());\n            } else {\n                ctx.fill();\n            }\n        }\n        if (ctx.strokeStyle !== \"\") {\n            if (this.getAttribute(\"vector-effect\").getString() === \"non-scaling-stroke\") {\n                ctx.save();\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.stroke();\n                ctx.restore();\n            } else {\n                ctx.stroke();\n            }\n        }\n        var markers = this.getMarkers();\n        if (markers) {\n            var markersLastIndex = markers.length - 1;\n            var markerStartStyleProp = this.getStyle(\"marker-start\");\n            var markerMidStyleProp = this.getStyle(\"marker-mid\");\n            var markerEndStyleProp = this.getStyle(\"marker-end\");\n            if (markerStartStyleProp.isUrlDefinition()) {\n                var marker = markerStartStyleProp.getDefinition();\n                var [point, angle] = markers[0];\n                marker.render(ctx, point, angle);\n            }\n            if (markerMidStyleProp.isUrlDefinition()) {\n                var _marker = markerMidStyleProp.getDefinition();\n                for(var i = 1; i < markersLastIndex; i++){\n                    var [_point, _angle] = markers[i];\n                    _marker.render(ctx, _point, _angle);\n                }\n            }\n            if (markerEndStyleProp.isUrlDefinition()) {\n                var _marker2 = markerEndStyleProp.getDefinition();\n                var [_point2, _angle2] = markers[markersLastIndex];\n                _marker2.render(ctx, _point2, _angle2);\n            }\n        }\n    }\n    static pathM(pathParser) {\n        var point = pathParser.getAsCurrentPoint();\n        pathParser.start = pathParser.current;\n        return {\n            point\n        };\n    }\n    pathM(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { point } = PathElement.pathM(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.moveTo(x, y);\n        }\n    }\n    static pathL(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point\n        };\n    }\n    pathL(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathL(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathH(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathH(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathH(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathV(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathV(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathV(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathC(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getPoint(\"x1\", \"y1\");\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathC(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathS(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getReflectedControlPoint();\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathS(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathQ(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getAsControlPoint(\"x1\", \"y1\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathQ(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathT(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getReflectedControlPoint();\n        pathParser.control = controlPoint;\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathT(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathA(pathParser) {\n        var { current, command } = pathParser;\n        var { rX, rY, xRot, lArcFlag, sweepFlag } = command;\n        var xAxisRotation = xRot * (Math.PI / 180.0);\n        var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        // x1', y1'\n        var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii\n        var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n        if (l > 1) {\n            rX *= Math.sqrt(l);\n            rY *= Math.sqrt(l);\n        } // cx', cy'\n        var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n        if (isNaN(s)) {\n            s = 0;\n        }\n        var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy\n        var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle\n        var a1 = vectorsAngle([\n            1,\n            0\n        ], [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ]); // θ1\n        // angle delta\n        var u = [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ];\n        var v = [\n            (-currp.x - cpp.x) / rX,\n            (-currp.y - cpp.y) / rY\n        ];\n        var ad = vectorsAngle(u, v); // Δθ\n        if (vectorsRatio(u, v) <= -1) {\n            ad = Math.PI;\n        }\n        if (vectorsRatio(u, v) >= 1) {\n            ad = 0;\n        }\n        return {\n            currentPoint,\n            rX,\n            rY,\n            sweepFlag,\n            xAxisRotation,\n            centp,\n            a1,\n            ad\n        };\n    }\n    pathA(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { currentPoint, rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser); // for markers\n        var dir = 1 - sweepFlag ? 1.0 : -1.0;\n        var ah = a1 + dir * (ad / 2.0);\n        var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n        boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better\n        if (ctx && !isNaN(a1) && !isNaN(ad)) {\n            var r = rX > rY ? rX : rY;\n            var sx = rX > rY ? 1 : rX / rY;\n            var sy = rX > rY ? rY / rX : 1;\n            ctx.translate(centp.x, centp.y);\n            ctx.rotate(xAxisRotation);\n            ctx.scale(sx, sy);\n            ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));\n            ctx.scale(1 / sx, 1 / sy);\n            ctx.rotate(-xAxisRotation);\n            ctx.translate(-centp.x, -centp.y);\n        }\n    }\n    static pathZ(pathParser) {\n        pathParser.current = pathParser.start;\n    }\n    pathZ(ctx, boundingBox) {\n        PathElement.pathZ(this.pathParser);\n        if (ctx) {\n            // only close path if it is not a straight line\n            if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n                ctx.closePath();\n            }\n        }\n    }\n}\nclass GlyphElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"glyph\";\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        this.unicode = this.getAttribute(\"unicode\").getString();\n        this.arabicForm = this.getAttribute(\"arabic-form\").getString();\n    }\n}\nclass TextElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TextElement ? true : captureTextNodes);\n        this.type = \"text\";\n        this.x = 0;\n        this.y = 0;\n        this.measureCache = -1;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        super.setContext(ctx, fromMeasure);\n        var textBaseline = this.getStyle(\"dominant-baseline\").getTextBaseline() || this.getStyle(\"alignment-baseline\").getTextBaseline();\n        if (textBaseline) {\n            ctx.textBaseline = textBaseline;\n        }\n    }\n    initializeCoordinates() {\n        this.x = 0;\n        this.y = 0;\n        this.leafTexts = [];\n        this.textChunkStart = 0;\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n    }\n    getBoundingBox(ctx) {\n        if (this.type !== \"text\") {\n            return this.getTElementBoundingBox(ctx);\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx);\n        var boundingBox = null; // then calculate bounding box\n        this.children.forEach((_, i)=>{\n            var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);\n            if (!boundingBox) {\n                boundingBox = childBoundingBox;\n            } else {\n                boundingBox.addBoundingBox(childBoundingBox);\n            }\n        });\n        return boundingBox;\n    }\n    getFontSize() {\n        var { document: document1, parent } = this;\n        var inheritFontSize = Font.parse(document1.ctx.font).fontSize;\n        var fontSize = parent.getStyle(\"font-size\").getNumber(inheritFontSize);\n        return fontSize;\n    }\n    getTElementBoundingBox(ctx) {\n        var fontSize = this.getFontSize();\n        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);\n    }\n    getGlyph(font, text, i) {\n        var char = text[i];\n        var glyph = null;\n        if (font.isArabic) {\n            var len = text.length;\n            var prevChar = text[i - 1];\n            var nextChar = text[i + 1];\n            var arabicForm = \"isolated\";\n            if ((i === 0 || prevChar === \" \") && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"terminal\";\n            }\n            if (i > 0 && prevChar !== \" \" && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"medial\";\n            }\n            if (i > 0 && prevChar !== \" \" && (i === len - 1 || nextChar === \" \")) {\n                arabicForm = \"initial\";\n            }\n            if (typeof font.glyphs[char] !== \"undefined\") {\n                // NEED TEST\n                var maybeGlyph = font.glyphs[char];\n                glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];\n            }\n        } else {\n            glyph = font.glyphs[char];\n        }\n        if (!glyph) {\n            glyph = font.missingGlyph;\n        }\n        return glyph;\n    }\n    getText() {\n        return \"\";\n    }\n    getTextFromNode(node) {\n        var textNode = node || this.node;\n        var childNodes = Array.from(textNode.parentNode.childNodes);\n        var index = childNodes.indexOf(textNode);\n        var lastIndex = childNodes.length - 1;\n        var text = compressSpaces(// || textNode.text\n        textNode.textContent || \"\");\n        if (index === 0) {\n            text = trimLeft(text);\n        }\n        if (index === lastIndex) {\n            text = trimRight(text);\n        }\n        return text;\n    }\n    renderChildren(ctx) {\n        if (this.type !== \"text\") {\n            this.renderTElementChildren(ctx);\n            return;\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx); // then render\n        this.children.forEach((_, i)=>{\n            this.renderChild(ctx, this, this, i);\n        });\n        var { mouse } = this.document.screen; // Do not calc bounding box if mouse is not working.\n        if (mouse.isWorking()) {\n            mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n        }\n    }\n    renderTElementChildren(ctx) {\n        var { document: document1, parent } = this;\n        var renderText = this.getText();\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var { unitsPerEm } = customFont.fontFace;\n            var ctxFont = Font.parse(document1.ctx.font);\n            var fontSize = parent.getStyle(\"font-size\").getNumber(ctxFont.fontSize);\n            var fontStyle = parent.getStyle(\"font-style\").getString(ctxFont.fontStyle);\n            var scale = fontSize / unitsPerEm;\n            var text = customFont.isRTL ? renderText.split(\"\").reverse().join(\"\") : renderText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                ctx.translate(this.x, this.y);\n                ctx.scale(scale, -scale);\n                var lw = ctx.lineWidth;\n                ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, .4, 1, 0, 0);\n                }\n                glyph.render(ctx);\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, -.4, 1, 0, 0);\n                }\n                ctx.lineWidth = lw;\n                ctx.scale(1 / scale, -1 / scale);\n                ctx.translate(-this.x, -this.y);\n                this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    this.x += dx[i];\n                }\n            }\n            return;\n        }\n        var { x, y } = this; // NEED TEST\n        // if (ctx.paintOrder === 'stroke') {\n        // \tif (ctx.strokeStyle) {\n        // \t\tctx.strokeText(renderText, x, y);\n        // \t}\n        // \tif (ctx.fillStyle) {\n        // \t\tctx.fillText(renderText, x, y);\n        // \t}\n        // } else {\n        if (ctx.fillStyle) {\n            ctx.fillText(renderText, x, y);\n        }\n        if (ctx.strokeStyle) {\n            ctx.strokeText(renderText, x, y);\n        } // }\n    }\n    applyAnchoring() {\n        if (this.textChunkStart >= this.leafTexts.length) {\n            return;\n        } // This is basically the \"Apply anchoring\" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.\n        // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.\n        // Vertical text is not supported.\n        var firstElement = this.leafTexts[this.textChunkStart];\n        var textAnchor = firstElement.getStyle(\"text-anchor\").getString(\"start\");\n        var isRTL = false; // we treat RTL like LTR\n        var shift = 0;\n        if (textAnchor === \"start\" && !isRTL || textAnchor === \"end\" && isRTL) {\n            shift = firstElement.x - this.minX;\n        } else if (textAnchor === \"end\" && !isRTL || textAnchor === \"start\" && isRTL) {\n            shift = firstElement.x - this.maxX;\n        } else {\n            shift = firstElement.x - (this.minX + this.maxX) / 2;\n        }\n        for(var i = this.textChunkStart; i < this.leafTexts.length; i++){\n            this.leafTexts[i].x += shift;\n        } // start new chunk\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n        this.textChunkStart = this.leafTexts.length;\n    }\n    adjustChildCoordinatesRecursive(ctx) {\n        this.children.forEach((_, i)=>{\n            this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);\n        });\n        this.applyAnchoring();\n    }\n    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (child.children.length > 0) {\n            child.children.forEach((_, i)=>{\n                textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);\n            });\n        } else {\n            // only leafs are relevant\n            this.adjustChildCoordinates(ctx, textParent, parent, i);\n        }\n    }\n    adjustChildCoordinates(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (typeof child.measureText !== \"function\") {\n            return child;\n        }\n        ctx.save();\n        child.setContext(ctx, true);\n        var xAttr = child.getAttribute(\"x\");\n        var yAttr = child.getAttribute(\"y\");\n        var dxAttr = child.getAttribute(\"dx\");\n        var dyAttr = child.getAttribute(\"dy\");\n        var customFont = child.getStyle(\"font-family\").getDefinition();\n        var isRTL = Boolean(customFont) && customFont.isRTL;\n        if (i === 0) {\n            // First children inherit attributes from parent(s). Positional attributes\n            // are only inherited from a parent to it's first child.\n            if (!xAttr.hasValue()) {\n                xAttr.setValue(child.getInheritedAttribute(\"x\"));\n            }\n            if (!yAttr.hasValue()) {\n                yAttr.setValue(child.getInheritedAttribute(\"y\"));\n            }\n            if (!dxAttr.hasValue()) {\n                dxAttr.setValue(child.getInheritedAttribute(\"dx\"));\n            }\n            if (!dyAttr.hasValue()) {\n                dyAttr.setValue(child.getInheritedAttribute(\"dy\"));\n            }\n        }\n        var width = child.measureText(ctx);\n        if (isRTL) {\n            textParent.x -= width;\n        }\n        if (xAttr.hasValue()) {\n            // an \"x\" attribute marks the start of a new chunk\n            textParent.applyAnchoring();\n            child.x = xAttr.getPixels(\"x\");\n            if (dxAttr.hasValue()) {\n                child.x += dxAttr.getPixels(\"x\");\n            }\n        } else {\n            if (dxAttr.hasValue()) {\n                textParent.x += dxAttr.getPixels(\"x\");\n            }\n            child.x = textParent.x;\n        }\n        textParent.x = child.x;\n        if (!isRTL) {\n            textParent.x += width;\n        }\n        if (yAttr.hasValue()) {\n            child.y = yAttr.getPixels(\"y\");\n            if (dyAttr.hasValue()) {\n                child.y += dyAttr.getPixels(\"y\");\n            }\n        } else {\n            if (dyAttr.hasValue()) {\n                textParent.y += dyAttr.getPixels(\"y\");\n            }\n            child.y = textParent.y;\n        }\n        textParent.y = child.y; // update the current chunk and it's bounds\n        textParent.leafTexts.push(child);\n        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);\n        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);\n        child.clearContext(ctx);\n        ctx.restore();\n        return child;\n    }\n    getChildBoundingBox(ctx, textParent, parent, i) {\n        var child = parent.children[i]; // not a text node?\n        if (typeof child.getBoundingBox !== \"function\") {\n            return null;\n        }\n        var boundingBox = child.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return null;\n        }\n        child.children.forEach((_, i)=>{\n            var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);\n            boundingBox.addBoundingBox(childBoundingBox);\n        });\n        return boundingBox;\n    }\n    renderChild(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        child.render(ctx);\n        child.children.forEach((_, i)=>{\n            textParent.renderChild(ctx, textParent, child, i);\n        });\n    }\n    measureText(ctx) {\n        var { measureCache } = this;\n        if (~measureCache) {\n            return measureCache;\n        }\n        var renderText = this.getText();\n        var measure = this.measureTargetText(ctx, renderText);\n        this.measureCache = measure;\n        return measure;\n    }\n    measureTargetText(ctx, targetText) {\n        if (!targetText.length) {\n            return 0;\n        }\n        var { parent } = this;\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var fontSize = this.getFontSize();\n            var text = customFont.isRTL ? targetText.split(\"\").reverse().join(\"\") : targetText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            var _measure = 0;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    _measure += dx[i];\n                }\n            }\n            return _measure;\n        }\n        if (!ctx.measureText) {\n            return targetText.length * 10;\n        }\n        ctx.save();\n        this.setContext(ctx, true);\n        var { width: measure } = ctx.measureText(targetText);\n        this.clearContext(ctx);\n        ctx.restore();\n        return measure;\n    }\n    /**\r\n   * Inherits positional attributes from {@link TextElement} parent(s). Attributes\r\n   * are only inherited from a parent to its first child.\r\n   * @param name - The attribute name.\r\n   * @returns The attribute value or null.\r\n   */ getInheritedAttribute(name) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n        var current = this;\n        while(current instanceof TextElement && current.isFirstChild()){\n            var parentAttr = current.parent.getAttribute(name);\n            if (parentAttr.hasValue(true)) {\n                return parentAttr.getValue(\"0\");\n            }\n            current = current.parent;\n        }\n        return null;\n    }\n}\nclass TSpanElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TSpanElement ? true : captureTextNodes);\n        this.type = \"tspan\"; // if this node has children, then they own the text\n        this.text = this.children.length > 0 ? \"\" : this.getTextFromNode();\n    }\n    getText() {\n        return this.text;\n    }\n}\nclass TextNode extends TSpanElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"textNode\";\n    }\n}\nclass SVGElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"svg\";\n        this.root = false;\n    }\n    setContext(ctx) {\n        var _this$node$parentNode;\n        var { document: document1 } = this;\n        var { screen, window: window1 } = document1;\n        var canvas = ctx.canvas;\n        screen.setDefaults(ctx);\n        if (canvas.style && typeof ctx.font !== \"undefined\" && window1 && typeof window1.getComputedStyle !== \"undefined\") {\n            ctx.font = window1.getComputedStyle(canvas).getPropertyValue(\"font\");\n            var fontSizeProp = new Property(document1, \"fontSize\", Font.parse(ctx.font).fontSize);\n            if (fontSizeProp.hasValue()) {\n                document1.rootEmSize = fontSizeProp.getPixels(\"y\");\n                document1.emSize = document1.rootEmSize;\n            }\n        } // create new view port\n        if (!this.getAttribute(\"x\").hasValue()) {\n            this.getAttribute(\"x\", true).setValue(0);\n        }\n        if (!this.getAttribute(\"y\").hasValue()) {\n            this.getAttribute(\"y\", true).setValue(0);\n        }\n        var { width, height } = screen.viewPort;\n        if (!this.getStyle(\"width\").hasValue()) {\n            this.getStyle(\"width\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"height\").hasValue()) {\n            this.getStyle(\"height\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"color\").hasValue()) {\n            this.getStyle(\"color\", true).setValue(\"black\");\n        }\n        var refXAttr = this.getAttribute(\"refX\");\n        var refYAttr = this.getAttribute(\"refY\");\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n        var clip = !this.root && this.getStyle(\"overflow\").getValue(\"hidden\") !== \"visible\";\n        var minX = 0;\n        var minY = 0;\n        var clipX = 0;\n        var clipY = 0;\n        if (viewBox) {\n            minX = viewBox[0];\n            minY = viewBox[1];\n        }\n        if (!this.root) {\n            width = this.getStyle(\"width\").getPixels(\"x\");\n            height = this.getStyle(\"height\").getPixels(\"y\");\n            if (this.type === \"marker\") {\n                clipX = minX;\n                clipY = minY;\n                minX = 0;\n                minY = 0;\n            }\n        }\n        screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin\n        if (this.node // is not temporary SVGElement\n         && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === \"foreignObject\") && this.getStyle(\"transform\", false, true).hasValue() && !this.getStyle(\"transform-origin\", false, true).hasValue()) {\n            this.getStyle(\"transform-origin\", true, true).setValue(\"50% 50%\");\n        }\n        super.setContext(ctx);\n        ctx.translate(this.getAttribute(\"x\").getPixels(\"x\"), this.getAttribute(\"y\").getPixels(\"y\"));\n        if (viewBox) {\n            width = viewBox[2];\n            height = viewBox[3];\n        }\n        document1.setViewBox({\n            ctx,\n            aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n            width: screen.viewPort.width,\n            desiredWidth: width,\n            height: screen.viewPort.height,\n            desiredHeight: height,\n            minX,\n            minY,\n            refX: refXAttr.getValue(),\n            refY: refYAttr.getValue(),\n            clip,\n            clipX,\n            clipY\n        });\n        if (viewBox) {\n            screen.viewPort.removeCurrent();\n            screen.viewPort.setCurrent(width, height);\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        this.document.screen.viewPort.removeCurrent();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var widthAttr = this.getAttribute(\"width\", true);\n        var heightAttr = this.getAttribute(\"height\", true);\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var styleAttr = this.getAttribute(\"style\");\n        var originWidth = widthAttr.getNumber(0);\n        var originHeight = heightAttr.getNumber(0);\n        if (preserveAspectRatio) {\n            if (typeof preserveAspectRatio === \"string\") {\n                this.getAttribute(\"preserveAspectRatio\", true).setValue(preserveAspectRatio);\n            } else {\n                var preserveAspectRatioAttr = this.getAttribute(\"preserveAspectRatio\");\n                if (preserveAspectRatioAttr.hasValue()) {\n                    preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, \"$1\"));\n                }\n            }\n        }\n        widthAttr.setValue(width);\n        heightAttr.setValue(height);\n        if (!viewBoxAttr.hasValue()) {\n            viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n        }\n        if (styleAttr.hasValue()) {\n            var widthStyle = this.getStyle(\"width\");\n            var heightStyle = this.getStyle(\"height\");\n            if (widthStyle.hasValue()) {\n                widthStyle.setValue(\"\".concat(width, \"px\"));\n            }\n            if (heightStyle.hasValue()) {\n                heightStyle.setValue(\"\".concat(height, \"px\"));\n            }\n        }\n    }\n}\nclass RectElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"rect\";\n    }\n    path(ctx) {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\", false, true).getPixels(\"x\");\n        var height = this.getStyle(\"height\", false, true).getPixels(\"y\");\n        var rxAttr = this.getAttribute(\"rx\");\n        var ryAttr = this.getAttribute(\"ry\");\n        var rx = rxAttr.getPixels(\"x\");\n        var ry = ryAttr.getPixels(\"y\");\n        if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n            ry = rx;\n        }\n        if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n            rx = ry;\n        }\n        rx = Math.min(rx, width / 2.0);\n        ry = Math.min(ry, height / 2.0);\n        if (ctx) {\n            var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n            ctx.beginPath(); // always start the path so we don't fill prior paths\n            if (height > 0 && width > 0) {\n                ctx.moveTo(x + rx, y);\n                ctx.lineTo(x + width - rx, y);\n                ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);\n                ctx.lineTo(x + width, y + height - ry);\n                ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);\n                ctx.lineTo(x + rx, y + height);\n                ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);\n                ctx.lineTo(x, y + ry);\n                ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);\n                ctx.closePath();\n            }\n        }\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass CircleElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"circle\";\n    }\n    path(ctx) {\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        var r = this.getAttribute(\"r\").getPixels();\n        if (ctx && r > 0) {\n            ctx.beginPath();\n            ctx.arc(cx, cy, r, 0, Math.PI * 2, false);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - r, cy - r, cx + r, cy + r);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass EllipseElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"ellipse\";\n    }\n    path(ctx) {\n        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n        var rx = this.getAttribute(\"rx\").getPixels(\"x\");\n        var ry = this.getAttribute(\"ry\").getPixels(\"y\");\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        if (ctx && rx > 0 && ry > 0) {\n            ctx.beginPath();\n            ctx.moveTo(cx + rx, cy);\n            ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n            ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n            ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n            ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass LineElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"line\";\n    }\n    getPoints() {\n        return [\n            new Point(this.getAttribute(\"x1\").getPixels(\"x\"), this.getAttribute(\"y1\").getPixels(\"y\")),\n            new Point(this.getAttribute(\"x2\").getPixels(\"x\"), this.getAttribute(\"y2\").getPixels(\"y\"))\n        ];\n    }\n    path(ctx) {\n        var [{ x: x0, y: y0 }, { x: x1, y: y1 }] = this.getPoints();\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n            ctx.lineTo(x1, y1);\n        }\n        return new BoundingBox(x0, y0, x1, y1);\n    }\n    getMarkers() {\n        var [p0, p1] = this.getPoints();\n        var a = p0.angleTo(p1);\n        return [\n            [\n                p0,\n                a\n            ],\n            [\n                p1,\n                a\n            ]\n        ];\n    }\n}\nclass PolylineElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"polyline\";\n        this.points = [];\n        this.points = Point.parsePath(this.getAttribute(\"points\").getString());\n    }\n    path(ctx) {\n        var { points } = this;\n        var [{ x: x0, y: y0 }] = points;\n        var boundingBox = new BoundingBox(x0, y0);\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n        }\n        points.forEach((_ref)=>{\n            var { x, y } = _ref;\n            boundingBox.addPoint(x, y);\n            if (ctx) {\n                ctx.lineTo(x, y);\n            }\n        });\n        return boundingBox;\n    }\n    getMarkers() {\n        var { points } = this;\n        var lastIndex = points.length - 1;\n        var markers = [];\n        points.forEach((point, i)=>{\n            if (i === lastIndex) {\n                return;\n            }\n            markers.push([\n                point,\n                point.angleTo(points[i + 1])\n            ]);\n        });\n        if (markers.length > 0) {\n            markers.push([\n                points[points.length - 1],\n                markers[markers.length - 1][1]\n            ]);\n        }\n        return markers;\n    }\n}\nclass PolygonElement extends PolylineElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"polygon\";\n    }\n    path(ctx) {\n        var boundingBox = super.path(ctx);\n        var [{ x, y }] = this.points;\n        if (ctx) {\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n        return boundingBox;\n    }\n}\nclass PatternElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"pattern\";\n    }\n    createPattern(ctx, _, parentOpacityProp) {\n        var width = this.getStyle(\"width\").getPixels(\"x\", true);\n        var height = this.getStyle(\"height\").getPixels(\"y\", true); // render me using a temporary svg element\n        var patternSvg = new SVGElement(this.document, null);\n        patternSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        patternSvg.attributes.width = new Property(this.document, \"width\", \"\".concat(width, \"px\"));\n        patternSvg.attributes.height = new Property(this.document, \"height\", \"\".concat(height, \"px\"));\n        patternSvg.attributes.transform = new Property(this.document, \"transform\", this.getAttribute(\"patternTransform\").getValue());\n        patternSvg.children = this.children;\n        var patternCanvas = this.document.createCanvas(width, height);\n        var patternCtx = patternCanvas.getContext(\"2d\");\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue() && yAttr.hasValue()) {\n            patternCtx.translate(xAttr.getPixels(\"x\", true), yAttr.getPixels(\"y\", true));\n        }\n        if (parentOpacityProp.hasValue()) {\n            this.styles[\"fill-opacity\"] = parentOpacityProp;\n        } else {\n            Reflect.deleteProperty(this.styles, \"fill-opacity\");\n        } // render 3x3 grid so when we transform there's no white space on edges\n        for(var x = -1; x <= 1; x++){\n            for(var y = -1; y <= 1; y++){\n                patternCtx.save();\n                patternSvg.attributes.x = new Property(this.document, \"x\", x * patternCanvas.width);\n                patternSvg.attributes.y = new Property(this.document, \"y\", y * patternCanvas.height);\n                patternSvg.render(patternCtx);\n                patternCtx.restore();\n            }\n        }\n        var pattern = ctx.createPattern(patternCanvas, \"repeat\");\n        return pattern;\n    }\n}\nclass MarkerElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"marker\";\n    }\n    render(ctx, point, angle) {\n        if (!point) {\n            return;\n        }\n        var { x, y } = point;\n        var orient = this.getAttribute(\"orient\").getString(\"auto\");\n        var markerUnits = this.getAttribute(\"markerUnits\").getString(\"strokeWidth\");\n        ctx.translate(x, y);\n        if (orient === \"auto\") {\n            ctx.rotate(angle);\n        }\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(ctx.lineWidth, ctx.lineWidth);\n        }\n        ctx.save(); // render me using a temporary svg element\n        var markerSvg = new SVGElement(this.document, null);\n        markerSvg.type = this.type;\n        markerSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        markerSvg.attributes.refX = new Property(this.document, \"refX\", this.getAttribute(\"refX\").getValue());\n        markerSvg.attributes.refY = new Property(this.document, \"refY\", this.getAttribute(\"refY\").getValue());\n        markerSvg.attributes.width = new Property(this.document, \"width\", this.getAttribute(\"markerWidth\").getValue());\n        markerSvg.attributes.height = new Property(this.document, \"height\", this.getAttribute(\"markerHeight\").getValue());\n        markerSvg.attributes.overflow = new Property(this.document, \"overflow\", this.getAttribute(\"overflow\").getValue());\n        markerSvg.attributes.fill = new Property(this.document, \"fill\", this.getAttribute(\"fill\").getColor(\"black\"));\n        markerSvg.attributes.stroke = new Property(this.document, \"stroke\", this.getAttribute(\"stroke\").getValue(\"none\"));\n        markerSvg.children = this.children;\n        markerSvg.render(ctx);\n        ctx.restore();\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n        }\n        if (orient === \"auto\") {\n            ctx.rotate(-angle);\n        }\n        ctx.translate(-x, -y);\n    }\n}\nclass DefsElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"defs\";\n    }\n    render() {}\n}\nclass GElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"g\";\n    }\n    getBoundingBox(ctx) {\n        var boundingBox = new BoundingBox();\n        this.children.forEach((child)=>{\n            boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n        });\n        return boundingBox;\n    }\n}\nclass GradientElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.attributesToInherit = [\n            \"gradientUnits\"\n        ];\n        this.stops = [];\n        var { stops, children } = this;\n        children.forEach((child)=>{\n            if (child.type === \"stop\") {\n                stops.push(child);\n            }\n        });\n    }\n    getGradientUnits() {\n        return this.getAttribute(\"gradientUnits\").getString(\"objectBoundingBox\");\n    }\n    createGradient(ctx, element, parentOpacityProp) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var stopsContainer = this;\n        if (this.getHrefAttribute().hasValue()) {\n            stopsContainer = this.getHrefAttribute().getDefinition();\n            this.inheritStopContainer(stopsContainer);\n        }\n        var { stops } = stopsContainer;\n        var gradient = this.getGradient(ctx, element);\n        if (!gradient) {\n            return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n        }\n        stops.forEach((stop)=>{\n            gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));\n        });\n        if (this.getAttribute(\"gradientTransform\").hasValue()) {\n            // render as transformed pattern on temporary canvas\n            var { document: document1 } = this;\n            var { MAX_VIRTUAL_PIXELS, viewPort } = document1.screen;\n            var [rootView] = viewPort.viewPorts;\n            var rect = new RectElement(document1, null);\n            rect.attributes.x = new Property(document1, \"x\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.y = new Property(document1, \"y\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.width = new Property(document1, \"width\", MAX_VIRTUAL_PIXELS);\n            rect.attributes.height = new Property(document1, \"height\", MAX_VIRTUAL_PIXELS);\n            var group = new GElement(document1, null);\n            group.attributes.transform = new Property(document1, \"transform\", this.getAttribute(\"gradientTransform\").getValue());\n            group.children = [\n                rect\n            ];\n            var patternSvg = new SVGElement(document1, null);\n            patternSvg.attributes.x = new Property(document1, \"x\", 0);\n            patternSvg.attributes.y = new Property(document1, \"y\", 0);\n            patternSvg.attributes.width = new Property(document1, \"width\", rootView.width);\n            patternSvg.attributes.height = new Property(document1, \"height\", rootView.height);\n            patternSvg.children = [\n                group\n            ];\n            var patternCanvas = document1.createCanvas(rootView.width, rootView.height);\n            var patternCtx = patternCanvas.getContext(\"2d\");\n            patternCtx.fillStyle = gradient;\n            patternSvg.render(patternCtx);\n            return patternCtx.createPattern(patternCanvas, \"no-repeat\");\n        }\n        return gradient;\n    }\n    inheritStopContainer(stopsContainer) {\n        this.attributesToInherit.forEach((attributeToInherit)=>{\n            if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n                this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n            }\n        });\n    }\n    addParentOpacity(parentOpacityProp, color) {\n        if (parentOpacityProp.hasValue()) {\n            var colorProp = new Property(this.document, \"color\", color);\n            return colorProp.addOpacity(parentOpacityProp).getColor();\n        }\n        return color;\n    }\n}\nclass LinearGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"linearGradient\";\n        this.attributesToInherit.push(\"x1\", \"y1\", \"x2\", \"y2\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"x1\").hasValue() && !this.getAttribute(\"y1\").hasValue() && !this.getAttribute(\"x2\").hasValue() && !this.getAttribute(\"y2\").hasValue()) {\n            this.getAttribute(\"x1\", true).setValue(0);\n            this.getAttribute(\"y1\", true).setValue(0);\n            this.getAttribute(\"x2\", true).setValue(1);\n            this.getAttribute(\"y2\", true).setValue(0);\n        }\n        var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x1\").getNumber() : this.getAttribute(\"x1\").getPixels(\"x\");\n        var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y1\").getNumber() : this.getAttribute(\"y1\").getPixels(\"y\");\n        var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x2\").getNumber() : this.getAttribute(\"x2\").getPixels(\"x\");\n        var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y2\").getNumber() : this.getAttribute(\"y2\").getPixels(\"y\");\n        if (x1 === x2 && y1 === y2) {\n            return null;\n        }\n        return ctx.createLinearGradient(x1, y1, x2, y2);\n    }\n}\nclass RadialGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"radialGradient\";\n        this.attributesToInherit.push(\"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = element.getBoundingBox(ctx);\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"cx\").hasValue()) {\n            this.getAttribute(\"cx\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"cy\").hasValue()) {\n            this.getAttribute(\"cy\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"r\").hasValue()) {\n            this.getAttribute(\"r\", true).setValue(\"50%\");\n        }\n        var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"cx\").getNumber() : this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"cy\").getNumber() : this.getAttribute(\"cy\").getPixels(\"y\");\n        var fx = cx;\n        var fy = cy;\n        if (this.getAttribute(\"fx\").hasValue()) {\n            fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"fx\").getNumber() : this.getAttribute(\"fx\").getPixels(\"x\");\n        }\n        if (this.getAttribute(\"fy\").hasValue()) {\n            fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"fy\").getNumber() : this.getAttribute(\"fy\").getPixels(\"y\");\n        }\n        var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute(\"r\").getNumber() : this.getAttribute(\"r\").getPixels();\n        var fr = this.getAttribute(\"fr\").getPixels();\n        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);\n    }\n}\nclass StopElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"stop\";\n        var offset = Math.max(0, Math.min(1, this.getAttribute(\"offset\").getNumber()));\n        var stopOpacity = this.getStyle(\"stop-opacity\");\n        var stopColor = this.getStyle(\"stop-color\", true);\n        if (stopColor.getString() === \"\") {\n            stopColor.setValue(\"#000\");\n        }\n        if (stopOpacity.hasValue()) {\n            stopColor = stopColor.addOpacity(stopOpacity);\n        }\n        this.offset = offset;\n        this.color = stopColor.getColor();\n    }\n}\nclass AnimateElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"animate\";\n        this.duration = 0;\n        this.initialValue = null;\n        this.initialUnits = \"\";\n        this.removed = false;\n        this.frozen = false;\n        document1.screen.animations.push(this);\n        this.begin = this.getAttribute(\"begin\").getMilliseconds();\n        this.maxDuration = this.begin + this.getAttribute(\"dur\").getMilliseconds();\n        this.from = this.getAttribute(\"from\");\n        this.to = this.getAttribute(\"to\");\n        this.values = new Property(document1, \"values\", null);\n        var valuesAttr = this.getAttribute(\"values\");\n        if (valuesAttr.hasValue()) {\n            this.values.setValue(valuesAttr.getString().split(\";\"));\n        }\n    }\n    getProperty() {\n        var attributeType = this.getAttribute(\"attributeType\").getString();\n        var attributeName = this.getAttribute(\"attributeName\").getString();\n        if (attributeType === \"CSS\") {\n            return this.parent.getStyle(attributeName, true);\n        }\n        return this.parent.getAttribute(attributeName, true);\n    }\n    calcValue() {\n        var { initialUnits } = this;\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n        if (initialUnits === \"%\") {\n            newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100\n        }\n        return \"\".concat(newValue).concat(initialUnits);\n    }\n    update(delta) {\n        var { parent } = this;\n        var prop = this.getProperty(); // set initial value\n        if (!this.initialValue) {\n            this.initialValue = prop.getString();\n            this.initialUnits = prop.getUnits();\n        } // if we're past the end time\n        if (this.duration > this.maxDuration) {\n            var fill = this.getAttribute(\"fill\").getString(\"remove\"); // loop for indefinitely repeating animations\n            if (this.getAttribute(\"repeatCount\").getString() === \"indefinite\" || this.getAttribute(\"repeatDur\").getString() === \"indefinite\") {\n                this.duration = 0;\n            } else if (fill === \"freeze\" && !this.frozen) {\n                this.frozen = true;\n                parent.animationFrozen = true;\n                parent.animationFrozenValue = prop.getString();\n            } else if (fill === \"remove\" && !this.removed) {\n                this.removed = true;\n                prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n                return true;\n            }\n            return false;\n        }\n        this.duration += delta; // if we're past the begin time\n        var updated = false;\n        if (this.begin < this.duration) {\n            var newValue = this.calcValue(); // tween\n            var typeAttr = this.getAttribute(\"type\");\n            if (typeAttr.hasValue()) {\n                // for transform, etc.\n                var type = typeAttr.getString();\n                newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n            }\n            prop.setValue(newValue);\n            updated = true;\n        }\n        return updated;\n    }\n    getProgress() {\n        var { document: document1, values } = this;\n        var result = {\n            progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n        };\n        if (values.hasValue()) {\n            var p = result.progress * (values.getValue().length - 1);\n            var lb = Math.floor(p);\n            var ub = Math.ceil(p);\n            result.from = new Property(document1, \"from\", parseFloat(values.getValue()[lb]));\n            result.to = new Property(document1, \"to\", parseFloat(values.getValue()[ub]));\n            result.progress = (p - lb) / (ub - lb);\n        } else {\n            result.from = this.from;\n            result.to = this.to;\n        }\n        return result;\n    }\n}\nclass AnimateColorElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateColor\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress();\n        var colorFrom = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(from.getColor());\n        var colorTo = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(to.getColor());\n        if (colorFrom.ok && colorTo.ok) {\n            // tween color linearly\n            var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n            var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n            var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha\n            return \"rgb(\".concat(Math.floor(r), \", \").concat(Math.floor(g), \", \").concat(Math.floor(b), \")\");\n        }\n        return this.getAttribute(\"from\").getColor();\n    }\n}\nclass AnimateTransformElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateTransform\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var transformFrom = toNumbers(from.getString());\n        var transformTo = toNumbers(to.getString());\n        var newValue = transformFrom.map((from, i)=>{\n            var to = transformTo[i];\n            return from + (to - from) * progress;\n        }).join(\" \");\n        return newValue;\n    }\n}\nclass FontElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font\";\n        this.glyphs = Object.create(null);\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        var { definitions } = document1;\n        var { children } = this;\n        for (var child of children){\n            switch(child.type){\n                case \"font-face\":\n                    {\n                        this.fontFace = child;\n                        var fontFamilyStyle = child.getStyle(\"font-family\");\n                        if (fontFamilyStyle.hasValue()) {\n                            definitions[fontFamilyStyle.getString()] = this;\n                        }\n                        break;\n                    }\n                case \"missing-glyph\":\n                    this.missingGlyph = child;\n                    break;\n                case \"glyph\":\n                    {\n                        var glyph = child;\n                        if (glyph.arabicForm) {\n                            this.isRTL = true;\n                            this.isArabic = true;\n                            if (typeof this.glyphs[glyph.unicode] === \"undefined\") {\n                                this.glyphs[glyph.unicode] = Object.create(null);\n                            }\n                            this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;\n                        } else {\n                            this.glyphs[glyph.unicode] = glyph;\n                        }\n                        break;\n                    }\n            }\n        }\n    }\n    render() {}\n}\nclass FontFaceElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font-face\";\n        this.ascent = this.getAttribute(\"ascent\").getNumber();\n        this.descent = this.getAttribute(\"descent\").getNumber();\n        this.unitsPerEm = this.getAttribute(\"units-per-em\").getNumber();\n    }\n}\nclass MissingGlyphElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"missing-glyph\";\n        this.horizAdvX = 0;\n    }\n}\nclass TRefElement extends TextElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"tref\";\n    }\n    getText() {\n        var element = this.getHrefAttribute().getDefinition();\n        if (element) {\n            var firstChild = element.children[0];\n            if (firstChild) {\n                return firstChild.getText();\n            }\n        }\n        return \"\";\n    }\n}\nclass AElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"a\";\n        var { childNodes } = node;\n        var firstChild = childNodes[0];\n        var hasText = childNodes.length > 0 && Array.from(childNodes).every((node)=>node.nodeType === 3);\n        this.hasText = hasText;\n        this.text = hasText ? this.getTextFromNode(firstChild) : \"\";\n    }\n    getText() {\n        return this.text;\n    }\n    renderChildren(ctx) {\n        if (this.hasText) {\n            // render as text element\n            super.renderChildren(ctx);\n            var { document: document1, x, y } = this;\n            var { mouse } = document1.screen;\n            var fontSize = new Property(document1, \"fontSize\", Font.parse(document1.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.\n            if (mouse.isWorking()) {\n                mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels(\"y\"), x + this.measureText(ctx), y));\n            }\n        } else if (this.children.length > 0) {\n            // render as temporary group\n            var g = new GElement(this.document, null);\n            g.children = this.children;\n            g.parent = this;\n            g.render(ctx);\n        }\n    }\n    onClick() {\n        var { window: window1 } = this.document;\n        if (window1) {\n            window1.open(this.getHrefAttribute().getString());\n        }\n    }\n    onMouseMove() {\n        var ctx = this.document.ctx;\n        ctx.canvas.style.cursor = \"pointer\";\n    }\n}\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nclass TextPathElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"textPath\";\n        this.textWidth = 0;\n        this.textHeight = 0;\n        this.pathLength = -1;\n        this.glyphInfo = null;\n        this.letterSpacingCache = [];\n        this.measuresCache = new Map([\n            [\n                \"\",\n                0\n            ]\n        ]);\n        var pathElement = this.getHrefAttribute().getDefinition();\n        this.text = this.getTextFromNode();\n        this.dataArray = this.parsePathData(pathElement);\n    }\n    getText() {\n        return this.text;\n    }\n    path(ctx) {\n        var { dataArray } = this;\n        if (ctx) {\n            ctx.beginPath();\n        }\n        dataArray.forEach((_ref)=>{\n            var { type, points } = _ref;\n            switch(type){\n                case PathParser.LINE_TO:\n                    if (ctx) {\n                        ctx.lineTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.MOVE_TO:\n                    if (ctx) {\n                        ctx.moveTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.CURVE_TO:\n                    if (ctx) {\n                        ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n                    }\n                    break;\n                case PathParser.QUAD_TO:\n                    if (ctx) {\n                        ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n                    }\n                    break;\n                case PathParser.ARC:\n                    {\n                        var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;\n                        var r = rx > ry ? rx : ry;\n                        var scaleX = rx > ry ? 1 : rx / ry;\n                        var scaleY = rx > ry ? ry / rx : 1;\n                        if (ctx) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        break;\n                    }\n                case PathParser.CLOSE_PATH:\n                    if (ctx) {\n                        ctx.closePath();\n                    }\n                    break;\n            }\n        });\n    }\n    renderChildren(ctx) {\n        this.setTextData(ctx);\n        ctx.save();\n        var textDecoration = this.parent.getStyle(\"text-decoration\").getString();\n        var fontSize = this.getFontSize();\n        var { glyphInfo } = this;\n        var fill = ctx.fillStyle;\n        if (textDecoration === \"underline\") {\n            ctx.beginPath();\n        }\n        glyphInfo.forEach((glyph, i)=>{\n            var { p0, p1, rotation, text: partialText } = glyph;\n            ctx.save();\n            ctx.translate(p0.x, p0.y);\n            ctx.rotate(rotation);\n            if (ctx.fillStyle) {\n                ctx.fillText(partialText, 0, 0);\n            }\n            if (ctx.strokeStyle) {\n                ctx.strokeText(partialText, 0, 0);\n            }\n            ctx.restore();\n            if (textDecoration === \"underline\") {\n                if (i === 0) {\n                    ctx.moveTo(p0.x, p0.y + fontSize / 8);\n                }\n                ctx.lineTo(p1.x, p1.y + fontSize / 5);\n            } // // To assist with debugging visually, uncomment following\n        //\n        // ctx.beginPath();\n        // if (i % 2)\n        // \tctx.strokeStyle = 'red';\n        // else\n        // \tctx.strokeStyle = 'green';\n        // ctx.moveTo(p0.x, p0.y);\n        // ctx.lineTo(p1.x, p1.y);\n        // ctx.stroke();\n        // ctx.closePath();\n        });\n        if (textDecoration === \"underline\") {\n            ctx.lineWidth = fontSize / 20;\n            ctx.strokeStyle = fill;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n    getLetterSpacingAt() {\n        var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.letterSpacingCache[idx] || 0;\n    }\n    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {\n        var offset = inputOffset;\n        var glyphWidth = this.measureText(ctx, c);\n        if (c === \" \" && anchor === \"justify\" && textFullWidth < fullPathWidth) {\n            glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n        if (charI > -1) {\n            offset += this.getLetterSpacingAt(charI);\n        }\n        var splineStep = this.textHeight / 20;\n        var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);\n        var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);\n        var segment = {\n            p0,\n            p1\n        };\n        var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;\n        if (dy) {\n            var dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n            var dyY = Math.cos(-rotation) * dy;\n            segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {\n                x: p0.x + dyX,\n                y: p0.y + dyY\n            });\n            segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {\n                x: p1.x + dyX,\n                y: p1.y + dyY\n            });\n        }\n        offset += glyphWidth;\n        return {\n            offset,\n            segment,\n            rotation\n        };\n    }\n    measureText(ctx, text) {\n        var { measuresCache } = this;\n        var targetText = text || this.getText();\n        if (measuresCache.has(targetText)) {\n            return measuresCache.get(targetText);\n        }\n        var measure = this.measureTargetText(ctx, targetText);\n        measuresCache.set(targetText, measure);\n        return measure;\n    }\n    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.\n    // You need to call this method manually to update glyphs cache.\n    setTextData(ctx) {\n        if (this.glyphInfo) {\n            return;\n        }\n        var renderText = this.getText();\n        var chars = renderText.split(\"\");\n        var spacesNumber = renderText.split(\" \").length - 1;\n        var dx = this.parent.getAttribute(\"dx\").split().map((_)=>_.getPixels(\"x\"));\n        var dy = this.parent.getAttribute(\"dy\").getPixels(\"y\");\n        var anchor = this.parent.getStyle(\"text-anchor\").getString(\"start\");\n        var thisSpacing = this.getStyle(\"letter-spacing\");\n        var parentSpacing = this.parent.getStyle(\"letter-spacing\");\n        var letterSpacing = 0;\n        if (!thisSpacing.hasValue() || thisSpacing.getValue() === \"inherit\") {\n            letterSpacing = parentSpacing.getPixels();\n        } else if (thisSpacing.hasValue()) {\n            if (thisSpacing.getValue() !== \"initial\" && thisSpacing.getValue() !== \"unset\") {\n                letterSpacing = thisSpacing.getPixels();\n            }\n        } // fill letter-spacing cache\n        var letterSpacingCache = [];\n        var textLen = renderText.length;\n        this.letterSpacingCache = letterSpacingCache;\n        for(var i = 0; i < textLen; i++){\n            letterSpacingCache.push(typeof dx[i] !== \"undefined\" ? dx[i] : letterSpacing);\n        }\n        var dxSum = letterSpacingCache.reduce((acc, cur, i)=>i === 0 ? 0 : acc + cur || 0, 0);\n        var textWidth = this.measureText(ctx);\n        var textFullWidth = Math.max(textWidth + dxSum, 0);\n        this.textWidth = textWidth;\n        this.textHeight = this.getFontSize();\n        this.glyphInfo = [];\n        var fullPathWidth = this.getPathLength();\n        var startOffset = this.getStyle(\"startOffset\").getNumber(0) * fullPathWidth;\n        var offset = 0;\n        if (anchor === \"middle\" || anchor === \"center\") {\n            offset = -textFullWidth / 2;\n        }\n        if (anchor === \"end\" || anchor === \"right\") {\n            offset = -textFullWidth;\n        }\n        offset += startOffset;\n        chars.forEach((char, i)=>{\n            // Find such segment what distance between p0 and p1 is approx. width of glyph\n            var { offset: nextOffset, segment, rotation } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);\n            offset = nextOffset;\n            if (!segment.p0 || !segment.p1) {\n                return;\n            } // const width = this.getLineLength(\n            // \tsegment.p0.x,\n            // \tsegment.p0.y,\n            // \tsegment.p1.x,\n            // \tsegment.p1.y\n            // );\n            // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.\n            // Can foresee having a rough pair table built in that the developer can override as needed.\n            // Or use \"dx\" attribute of the <text> node as a naive replacement\n            // const kern = 0;\n            // placeholder for future implementation\n            // const midpoint = this.getPointOnLine(\n            // \tkern + width / 2.0,\n            // \tsegment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y\n            // );\n            this.glyphInfo.push({\n                // transposeX: midpoint.x,\n                // transposeY: midpoint.y,\n                text: chars[i],\n                p0: segment.p0,\n                p1: segment.p1,\n                rotation\n            });\n        });\n    }\n    parsePathData(path) {\n        this.pathLength = -1; // reset path length\n        if (!path) {\n            return [];\n        }\n        var pathCommands = [];\n        var { pathParser } = path;\n        pathParser.reset(); // convert l, H, h, V, and v to L\n        while(!pathParser.isEnd()){\n            var { current } = pathParser;\n            var startX = current ? current.x : 0;\n            var startY = current ? current.y : 0;\n            var command = pathParser.next();\n            var nextCommandType = command.type;\n            var points = [];\n            switch(command.type){\n                case PathParser.MOVE_TO:\n                    this.pathM(pathParser, points);\n                    break;\n                case PathParser.LINE_TO:\n                    nextCommandType = this.pathL(pathParser, points);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    nextCommandType = this.pathH(pathParser, points);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    nextCommandType = this.pathV(pathParser, points);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    nextCommandType = this.pathS(pathParser, points);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    nextCommandType = this.pathT(pathParser, points);\n                    break;\n                case PathParser.ARC:\n                    points = this.pathA(pathParser);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    PathElement.pathZ(pathParser);\n                    break;\n            }\n            if (command.type !== PathParser.CLOSE_PATH) {\n                pathCommands.push({\n                    type: nextCommandType,\n                    points,\n                    start: {\n                        x: startX,\n                        y: startY\n                    },\n                    pathLength: this.calcLength(startX, startY, nextCommandType, points)\n                });\n            } else {\n                pathCommands.push({\n                    type: PathParser.CLOSE_PATH,\n                    points: [],\n                    pathLength: 0\n                });\n            }\n        }\n        return pathCommands;\n    }\n    pathM(pathParser, points) {\n        var { x, y } = PathElement.pathM(pathParser).point;\n        points.push(x, y);\n    }\n    pathL(pathParser, points) {\n        var { x, y } = PathElement.pathL(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathH(pathParser, points) {\n        var { x, y } = PathElement.pathH(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathV(pathParser, points) {\n        var { x, y } = PathElement.pathV(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathC(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathS(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.CURVE_TO;\n    }\n    pathQ(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathT(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.QUAD_TO;\n    }\n    pathA(pathParser) {\n        var { rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser);\n        if (sweepFlag === 0 && ad > 0) {\n            ad -= 2 * Math.PI;\n        }\n        if (sweepFlag === 1 && ad < 0) {\n            ad += 2 * Math.PI;\n        }\n        return [\n            centp.x,\n            centp.y,\n            rX,\n            rY,\n            a1,\n            ad,\n            xAxisRotation,\n            sweepFlag\n        ];\n    }\n    calcLength(x, y, commandType, points) {\n        var len = 0;\n        var p1 = null;\n        var p2 = null;\n        var t = 0;\n        switch(commandType){\n            case PathParser.LINE_TO:\n                return this.getLineLength(x, y, points[0], points[1]);\n            case PathParser.CURVE_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.QUAD_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.ARC:\n                {\n                    // Approximates by breaking curve into line segments\n                    len = 0.0;\n                    var start = points[4]; // 4 = theta\n                    var dTheta = points[5]; // 5 = dTheta\n                    var end = points[4] + dTheta;\n                    var inc = Math.PI / 180.0; // 1 degree resolution\n                    if (Math.abs(start - end) < inc) {\n                        inc = Math.abs(start - end);\n                    } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\n                    p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                    if (dTheta < 0) {\n                        // clockwise\n                        for(t = start - inc; t > end; t -= inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    } else {\n                        // counter-clockwise\n                        for(t = start + inc; t < end; t += inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    }\n                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    return len;\n                }\n        }\n        return 0;\n    }\n    getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n        var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;\n        var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;\n        var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n        var run = Math.sqrt(dist * dist / (1 + m * m));\n        if (p2x < p1x) {\n            run *= -1;\n        }\n        var rise = m * run;\n        var pt = null;\n        if (p2x === p1x) {\n            // vertical line\n            pt = {\n                x: fromX,\n                y: fromY + rise\n            };\n        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {\n            pt = {\n                x: fromX + run,\n                y: fromY + rise\n            };\n        } else {\n            var ix = 0;\n            var iy = 0;\n            var len = this.getLineLength(p1x, p1y, p2x, p2y);\n            if (len < PSEUDO_ZERO) {\n                return null;\n            }\n            var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n            u /= len * len;\n            ix = p1x + u * (p2x - p1x);\n            iy = p1y + u * (p2y - p1y);\n            var pRise = this.getLineLength(fromX, fromY, ix, iy);\n            var pRun = Math.sqrt(dist * dist - pRise * pRise);\n            run = Math.sqrt(pRun * pRun / (1 + m * m));\n            if (p2x < p1x) {\n                run *= -1;\n            }\n            rise = m * run;\n            pt = {\n                x: ix + run,\n                y: iy + rise\n            };\n        }\n        return pt;\n    }\n    getPointOnPath(distance) {\n        var fullLen = this.getPathLength();\n        var cumulativePathLength = 0;\n        var p = null;\n        if (distance < -0.00005 || distance - 0.00005 > fullLen) {\n            return null;\n        }\n        var { dataArray } = this;\n        for (var command of dataArray){\n            if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {\n                cumulativePathLength += command.pathLength;\n                continue;\n            }\n            var delta = distance - cumulativePathLength;\n            var currentT = 0;\n            switch(command.type){\n                case PathParser.LINE_TO:\n                    p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n                    break;\n                case PathParser.ARC:\n                    {\n                        var start = command.points[4]; // 4 = theta\n                        var dTheta = command.points[5]; // 5 = dTheta\n                        var end = command.points[4] + dTheta;\n                        currentT = start + delta / command.pathLength * dTheta;\n                        if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                            break;\n                        }\n                        p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n                        break;\n                    }\n                case PathParser.CURVE_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n                    break;\n                case PathParser.QUAD_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n                    break;\n            }\n            if (p) {\n                return p;\n            }\n            break;\n        }\n        return null;\n    }\n    getLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    getPathLength() {\n        if (this.pathLength === -1) {\n            this.pathLength = this.dataArray.reduce((length, command)=>command.pathLength > 0 ? length + command.pathLength : length, 0);\n        }\n        return this.pathLength;\n    }\n    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n        var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n        var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n        var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n        var cosPsi = Math.cos(psi);\n        var sinPsi = Math.sin(psi);\n        var pt = {\n            x: rx * Math.cos(theta),\n            y: ry * Math.sin(theta)\n        };\n        return {\n            x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n            y: cy + (pt.x * sinPsi + pt.y * cosPsi)\n        };\n    }\n    buildEquidistantCache(inputStep, inputPrecision) {\n        var fullLen = this.getPathLength();\n        var precision = inputPrecision || 0.25; // accuracy vs performance\n        var step = inputStep || fullLen / 100;\n        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n            // Prepare cache\n            this.equidistantCache = {\n                step,\n                precision,\n                points: []\n            }; // Calculate points\n            var s = 0;\n            for(var l = 0; l <= fullLen; l += precision){\n                var p0 = this.getPointOnPath(l);\n                var p1 = this.getPointOnPath(l + precision);\n                if (!p0 || !p1) {\n                    continue;\n                }\n                s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                if (s >= step) {\n                    this.equidistantCache.points.push({\n                        x: p0.x,\n                        y: p0.y,\n                        distance: l\n                    });\n                    s -= step;\n                }\n            }\n        }\n    }\n    getEquidistantPointOnPath(targetDistance, step, precision) {\n        this.buildEquidistantCache(step, precision);\n        if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {\n            return null;\n        }\n        var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n        return this.equidistantCache.points[idx] || null;\n    }\n}\nvar dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nclass ImageElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"image\";\n        this.loaded = false;\n        var href = this.getHrefAttribute().getString();\n        if (!href) {\n            return;\n        }\n        var isSvg = href.endsWith(\".svg\") || /^\\s*data:image\\/svg\\+xml/i.test(href);\n        document1.images.push(this);\n        if (!isSvg) {\n            void this.loadImage(href);\n        } else {\n            void this.loadSvg(href);\n        }\n        this.isSvg = isSvg;\n    }\n    loadImage(href) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var image = yield _this.document.createImage(href);\n                _this.image = image;\n            } catch (err) {\n                console.error('Error while loading image \"'.concat(href, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n    loadSvg(href) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var match = dataUriRegex.exec(href);\n            if (match) {\n                var data = match[5];\n                if (match[4] === \"base64\") {\n                    _this2.image = atob(data);\n                } else {\n                    _this2.image = decodeURIComponent(data);\n                }\n            } else {\n                try {\n                    var response = yield _this2.document.fetch(href);\n                    var svg = yield response.text();\n                    _this2.image = svg;\n                } catch (err) {\n                    console.error('Error while loading image \"'.concat(href, '\":'), err);\n                }\n            }\n            _this2.loaded = true;\n        })();\n    }\n    renderChildren(ctx) {\n        var { document: document1, image, loaded } = this;\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!loaded || !image || !width || !height) {\n            return;\n        }\n        ctx.save();\n        ctx.translate(x, y);\n        if (this.isSvg) {\n            var subDocument = document1.canvg.forkString(ctx, this.image, {\n                ignoreMouse: true,\n                ignoreAnimation: true,\n                ignoreDimensions: true,\n                ignoreClear: true,\n                offsetX: 0,\n                offsetY: 0,\n                scaleWidth: width,\n                scaleHeight: height\n            });\n            subDocument.document.documentElement.parent = this;\n            void subDocument.render();\n        } else {\n            var _image = this.image;\n            document1.setViewBox({\n                ctx,\n                aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n                width,\n                desiredWidth: _image.width,\n                height,\n                desiredHeight: _image.height\n            });\n            if (this.loaded) {\n                if (typeof _image.complete === \"undefined\" || _image.complete) {\n                    ctx.drawImage(_image, 0, 0);\n                }\n            }\n        }\n        ctx.restore();\n    }\n    getBoundingBox() {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n}\nclass SymbolElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"symbol\";\n    }\n    render(_) {}\n}\nclass SVGFontLoader {\n    constructor(document1){\n        this.document = document1;\n        this.loaded = false;\n        document1.fonts.push(this);\n    }\n    load(fontFamily, url) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var { document: document1 } = _this;\n                var svgDocument = yield document1.canvg.parser.load(url);\n                var fonts = svgDocument.getElementsByTagName(\"font\");\n                Array.from(fonts).forEach((fontNode)=>{\n                    var font = document1.createElement(fontNode);\n                    document1.definitions[fontFamily] = font;\n                });\n            } catch (err) {\n                console.error('Error while loading font \"'.concat(url, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n}\nclass StyleElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"style\";\n        var css = compressSpaces(Array.from(node.childNodes) // NEED TEST\n        .map((_)=>_.textContent).join(\"\").replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\") // remove comments\n        .replace(/@import.*;/g, \"\") // remove imports\n        );\n        var cssDefs = css.split(\"}\");\n        cssDefs.forEach((_)=>{\n            var def = _.trim();\n            if (!def) {\n                return;\n            }\n            var cssParts = def.split(\"{\");\n            var cssClasses = cssParts[0].split(\",\");\n            var cssProps = cssParts[1].split(\";\");\n            cssClasses.forEach((_)=>{\n                var cssClass = _.trim();\n                if (!cssClass) {\n                    return;\n                }\n                var props = document1.styles[cssClass] || {};\n                cssProps.forEach((cssProp)=>{\n                    var prop = cssProp.indexOf(\":\");\n                    var name = cssProp.substr(0, prop).trim();\n                    var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n                    if (name && value) {\n                        props[name] = new Property(document1, name, value);\n                    }\n                });\n                document1.styles[cssClass] = props;\n                document1.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n                if (cssClass === \"@font-face\") {\n                    //  && !nodeEnv\n                    var fontFamily = props[\"font-family\"].getString().replace(/\"|'/g, \"\");\n                    var srcs = props.src.getString().split(\",\");\n                    srcs.forEach((src)=>{\n                        if (src.indexOf('format(\"svg\")') > 0) {\n                            var url = parseExternalUrl(src);\n                            if (url) {\n                                void new SVGFontLoader(document1).load(fontFamily, url);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n    }\n}\nStyleElement.parseExternalUrl = parseExternalUrl;\nclass UseElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"use\";\n    }\n    setContext(ctx) {\n        super.setContext(ctx);\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue()) {\n            ctx.translate(xAttr.getPixels(\"x\"), 0);\n        }\n        if (yAttr.hasValue()) {\n            ctx.translate(0, yAttr.getPixels(\"y\"));\n        }\n    }\n    path(ctx) {\n        var { element } = this;\n        if (element) {\n            element.path(ctx);\n        }\n    }\n    renderChildren(ctx) {\n        var { document: document1, element } = this;\n        if (element) {\n            var tempSvg = element;\n            if (element.type === \"symbol\") {\n                // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n                tempSvg = new SVGElement(document1, null);\n                tempSvg.attributes.viewBox = new Property(document1, \"viewBox\", element.getAttribute(\"viewBox\").getString());\n                tempSvg.attributes.preserveAspectRatio = new Property(document1, \"preserveAspectRatio\", element.getAttribute(\"preserveAspectRatio\").getString());\n                tempSvg.attributes.overflow = new Property(document1, \"overflow\", element.getAttribute(\"overflow\").getString());\n                tempSvg.children = element.children; // element is still the parent of the children\n                element.styles.opacity = new Property(document1, \"opacity\", this.calculateOpacity());\n            }\n            if (tempSvg.type === \"svg\") {\n                var widthStyle = this.getStyle(\"width\", false, true);\n                var heightStyle = this.getStyle(\"height\", false, true); // if symbol or svg, inherit width/height from me\n                if (widthStyle.hasValue()) {\n                    tempSvg.attributes.width = new Property(document1, \"width\", widthStyle.getString());\n                }\n                if (heightStyle.hasValue()) {\n                    tempSvg.attributes.height = new Property(document1, \"height\", heightStyle.getString());\n                }\n            }\n            var oldParent = tempSvg.parent;\n            tempSvg.parent = this;\n            tempSvg.render(ctx);\n            tempSvg.parent = oldParent;\n        }\n    }\n    getBoundingBox(ctx) {\n        var { element } = this;\n        if (element) {\n            return element.getBoundingBox(ctx);\n        }\n        return null;\n    }\n    elementTransform() {\n        var { document: document1, element } = this;\n        return Transform.fromElement(document1, element);\n    }\n    get element() {\n        if (!this.cachedElement) {\n            this.cachedElement = this.getHrefAttribute().getDefinition();\n        }\n        return this.cachedElement;\n    }\n}\nfunction imGet(img, x, y, width, _height, rgba) {\n    return img[y * width * 4 + x * 4 + rgba];\n}\nfunction imSet(img, x, y, width, _height, rgba, val) {\n    img[y * width * 4 + x * 4 + rgba] = val;\n}\nfunction m(matrix, i, v) {\n    var mi = matrix[i];\n    return mi * v;\n}\nfunction c(a, m1, m2, m3) {\n    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n}\nclass FeColorMatrixElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feColorMatrix\";\n        var matrix = toNumbers(this.getAttribute(\"values\").getString());\n        switch(this.getAttribute(\"type\").getString(\"matrix\")){\n            // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement\n            case \"saturate\":\n                {\n                    var s = matrix[0];\n                    /* eslint-disable array-element-newline */ matrix = [\n                        0.213 + 0.787 * s,\n                        0.715 - 0.715 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 + 0.285 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 - 0.715 * s,\n                        0.072 + 0.928 * s,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"hueRotate\":\n                {\n                    var a = matrix[0] * Math.PI / 180.0;\n                    /* eslint-disable array-element-newline */ matrix = [\n                        c(a, 0.213, 0.787, -0.213),\n                        c(a, 0.715, -0.715, -0.715),\n                        c(a, 0.072, -0.072, 0.928),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, 0.143),\n                        c(a, 0.715, 0.285, 0.140),\n                        c(a, 0.072, -0.072, -0.283),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, -0.787),\n                        c(a, 0.715, -0.715, 0.715),\n                        c(a, 0.072, 0.928, 0.072),\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"luminanceToAlpha\":\n                /* eslint-disable array-element-newline */ matrix = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0.2125,\n                    0.7154,\n                    0.0721,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                break;\n        }\n        this.matrix = matrix;\n        this.includeOpacity = this.getAttribute(\"includeOpacity\").hasValue();\n    }\n    apply(ctx, _x, _y, width, height) {\n        // assuming x==0 && y==0 for now\n        var { includeOpacity, matrix } = this;\n        var srcData = ctx.getImageData(0, 0, width, height);\n        for(var y = 0; y < height; y++){\n            for(var x = 0; x < width; x++){\n                var r = imGet(srcData.data, x, y, width, height, 0);\n                var g = imGet(srcData.data, x, y, width, height, 1);\n                var b = imGet(srcData.data, x, y, width, height, 2);\n                var a = imGet(srcData.data, x, y, width, height, 3);\n                var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);\n                var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);\n                var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);\n                var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);\n                if (includeOpacity) {\n                    nr = 0;\n                    ng = 0;\n                    nb = 0;\n                    na *= a / 255;\n                }\n                imSet(srcData.data, x, y, width, height, 0, nr);\n                imSet(srcData.data, x, y, width, height, 1, ng);\n                imSet(srcData.data, x, y, width, height, 2, nb);\n                imSet(srcData.data, x, y, width, height, 3, na);\n            }\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.putImageData(srcData, 0, 0);\n    }\n}\nclass MaskElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"mask\";\n    }\n    apply(ctx, element) {\n        var { document: document1 } = this; // render as temp svg\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!width && !height) {\n            var boundingBox = new BoundingBox();\n            this.children.forEach((child)=>{\n                boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n            });\n            x = Math.floor(boundingBox.x1);\n            y = Math.floor(boundingBox.y1);\n            width = Math.floor(boundingBox.width);\n            height = Math.floor(boundingBox.height);\n        }\n        var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n        var maskCanvas = document1.createCanvas(x + width, y + height);\n        var maskCtx = maskCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(maskCtx);\n        this.renderChildren(maskCtx); // convert mask to alpha with a fake node\n        // TODO: refactor out apply from feColorMatrix\n        new FeColorMatrixElement(document1, {\n            nodeType: 1,\n            childNodes: [],\n            attributes: [\n                {\n                    nodeName: \"type\",\n                    value: \"luminanceToAlpha\"\n                },\n                {\n                    nodeName: \"includeOpacity\",\n                    value: \"true\"\n                }\n            ]\n        }).apply(maskCtx, 0, 0, x + width, y + height);\n        var tmpCanvas = document1.createCanvas(x + width, y + height);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        element.render(tmpCtx);\n        tmpCtx.globalCompositeOperation = \"destination-in\";\n        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, \"no-repeat\");\n        tmpCtx.fillRect(0, 0, x + width, y + height);\n        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, \"no-repeat\");\n        ctx.fillRect(0, 0, x + width, y + height); // reassign mask\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nMaskElement.ignoreStyles = [\n    \"mask\",\n    \"transform\",\n    \"clip-path\"\n];\nvar noop = ()=>{};\nclass ClipPathElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"clipPath\";\n    }\n    apply(ctx) {\n        var { document: document1 } = this;\n        var contextProto = Reflect.getPrototypeOf(ctx);\n        var { beginPath, closePath } = ctx;\n        if (contextProto) {\n            contextProto.beginPath = noop;\n            contextProto.closePath = noop;\n        }\n        Reflect.apply(beginPath, ctx, []);\n        this.children.forEach((child)=>{\n            if (typeof child.path === \"undefined\") {\n                return;\n            }\n            var transform = typeof child.elementTransform !== \"undefined\" ? child.elementTransform() : null; // handle <use />\n            if (!transform) {\n                transform = Transform.fromElement(document1, child);\n            }\n            if (transform) {\n                transform.apply(ctx);\n            }\n            child.path(ctx);\n            if (contextProto) {\n                contextProto.closePath = closePath;\n            }\n            if (transform) {\n                transform.unapply(ctx);\n            }\n        });\n        Reflect.apply(closePath, ctx, []);\n        ctx.clip();\n        if (contextProto) {\n            contextProto.beginPath = beginPath;\n            contextProto.closePath = closePath;\n        }\n    }\n    render(_) {}\n}\nclass FilterElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"filter\";\n    }\n    apply(ctx, element) {\n        // render as temp svg\n        var { document: document1, children } = this;\n        var boundingBox = element.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return;\n        }\n        var px = 0;\n        var py = 0;\n        children.forEach((child)=>{\n            var efd = child.extraFilterDistance || 0;\n            px = Math.max(px, efd);\n            py = Math.max(py, efd);\n        });\n        var width = Math.floor(boundingBox.width);\n        var height = Math.floor(boundingBox.height);\n        var tmpCanvasWidth = width + 2 * px;\n        var tmpCanvasHeight = height + 2 * py;\n        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n            return;\n        }\n        var x = Math.floor(boundingBox.x);\n        var y = Math.floor(boundingBox.y);\n        var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n        var tmpCanvas = document1.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        tmpCtx.translate(-x + px, -y + py);\n        element.render(tmpCtx); // apply filters\n        children.forEach((child)=>{\n            if (typeof child.apply === \"function\") {\n                child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n            }\n        }); // render on me\n        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nFilterElement.ignoreStyles = [\n    \"filter\",\n    \"transform\",\n    \"clip-path\"\n];\nclass FeDropShadowElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feDropShadow\";\n        this.addStylesFromStyleDefinition();\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeMorphologyElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feMorphology\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeCompositeElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feComposite\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeGaussianBlurElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feGaussianBlur\";\n        this.blurRadius = Math.floor(this.getAttribute(\"stdDeviation\").getNumber());\n        this.extraFilterDistance = this.blurRadius;\n    }\n    apply(ctx, x, y, width, height) {\n        var { document: document1, blurRadius } = this;\n        var body = document1.window ? document1.window.document.body : null;\n        var canvas = ctx.canvas; // StackBlur requires canvas be on document\n        canvas.id = document1.getUniqueId();\n        if (body) {\n            canvas.style.display = \"none\";\n            body.appendChild(canvas);\n        }\n        (0,stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__.canvasRGBA)(canvas, x, y, width, height, blurRadius);\n        if (body) {\n            body.removeChild(canvas);\n        }\n    }\n}\nclass TitleElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"title\";\n    }\n}\nclass DescElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"desc\";\n    }\n}\nvar elements = {\n    \"svg\": SVGElement,\n    \"rect\": RectElement,\n    \"circle\": CircleElement,\n    \"ellipse\": EllipseElement,\n    \"line\": LineElement,\n    \"polyline\": PolylineElement,\n    \"polygon\": PolygonElement,\n    \"path\": PathElement,\n    \"pattern\": PatternElement,\n    \"marker\": MarkerElement,\n    \"defs\": DefsElement,\n    \"linearGradient\": LinearGradientElement,\n    \"radialGradient\": RadialGradientElement,\n    \"stop\": StopElement,\n    \"animate\": AnimateElement,\n    \"animateColor\": AnimateColorElement,\n    \"animateTransform\": AnimateTransformElement,\n    \"font\": FontElement,\n    \"font-face\": FontFaceElement,\n    \"missing-glyph\": MissingGlyphElement,\n    \"glyph\": GlyphElement,\n    \"text\": TextElement,\n    \"tspan\": TSpanElement,\n    \"tref\": TRefElement,\n    \"a\": AElement,\n    \"textPath\": TextPathElement,\n    \"image\": ImageElement,\n    \"g\": GElement,\n    \"symbol\": SymbolElement,\n    \"style\": StyleElement,\n    \"use\": UseElement,\n    \"mask\": MaskElement,\n    \"clipPath\": ClipPathElement,\n    \"filter\": FilterElement,\n    \"feDropShadow\": FeDropShadowElement,\n    \"feMorphology\": FeMorphologyElement,\n    \"feComposite\": FeCompositeElement,\n    \"feColorMatrix\": FeColorMatrixElement,\n    \"feGaussianBlur\": FeGaussianBlurElement,\n    \"title\": TitleElement,\n    \"desc\": DescElement\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction createCanvas(width, height) {\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nfunction createImage(_x) {\n    return _createImage.apply(this, arguments);\n}\nfunction _createImage() {\n    _createImage = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*(src) {\n        var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var image = document.createElement(\"img\");\n        if (anonymousCrossOrigin) {\n            image.crossOrigin = \"Anonymous\";\n        }\n        return new Promise((resolve, reject)=>{\n            image.onload = ()=>{\n                resolve(image);\n            };\n            image.onerror = (_event, _source, _lineno, _colno, error)=>{\n                reject(error);\n            };\n            image.src = src;\n        });\n    });\n    return _createImage.apply(this, arguments);\n}\nclass Document {\n    constructor(canvg){\n        var { rootEmSize = 12, emSize = 12, createCanvas = Document.createCanvas, createImage = Document.createImage, anonymousCrossOrigin } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.canvg = canvg;\n        this.definitions = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.images = [];\n        this.fonts = [];\n        this.emSizeStack = [];\n        this.uniqueId = 0;\n        this.screen = canvg.screen;\n        this.rootEmSize = rootEmSize;\n        this.emSize = emSize;\n        this.createCanvas = createCanvas;\n        this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);\n        this.screen.wait(this.isImagesLoaded.bind(this));\n        this.screen.wait(this.isFontsLoaded.bind(this));\n    }\n    bindCreateImage(createImage, anonymousCrossOrigin) {\n        if (typeof anonymousCrossOrigin === \"boolean\") {\n            return (source, forceAnonymousCrossOrigin)=>createImage(source, typeof forceAnonymousCrossOrigin === \"boolean\" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);\n        }\n        return createImage;\n    }\n    get window() {\n        return this.screen.window;\n    }\n    get fetch() {\n        return this.screen.fetch;\n    }\n    get ctx() {\n        return this.screen.ctx;\n    }\n    get emSize() {\n        var { emSizeStack } = this;\n        return emSizeStack[emSizeStack.length - 1];\n    }\n    set emSize(value) {\n        var { emSizeStack } = this;\n        emSizeStack.push(value);\n    }\n    popEmSize() {\n        var { emSizeStack } = this;\n        emSizeStack.pop();\n    }\n    getUniqueId() {\n        return \"canvg\".concat(++this.uniqueId);\n    }\n    isImagesLoaded() {\n        return this.images.every((_)=>_.loaded);\n    }\n    isFontsLoaded() {\n        return this.fonts.every((_)=>_.loaded);\n    }\n    createDocumentElement(document1) {\n        var documentElement = this.createElement(document1.documentElement);\n        documentElement.root = true;\n        documentElement.addStylesFromStyleDefinition();\n        this.documentElement = documentElement;\n        return documentElement;\n    }\n    createElement(node) {\n        var elementType = node.nodeName.replace(/^[^:]+:/, \"\");\n        var ElementType = Document.elementTypes[elementType];\n        if (typeof ElementType !== \"undefined\") {\n            return new ElementType(this, node);\n        }\n        return new UnknownElement(this, node);\n    }\n    createTextNode(node) {\n        return new TextNode(this, node);\n    }\n    setViewBox(config) {\n        this.screen.setViewBox(_objectSpread$1({\n            document: this\n        }, config));\n    }\n}\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * SVG renderer on canvas.\r\n */ class Canvg {\n    /**\r\n   * Main constructor.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG Document.\r\n   * @param options - Rendering options.\r\n   */ constructor(ctx, svg){\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this.parser = new Parser(options);\n        this.screen = new Screen(ctx, options);\n        this.options = options;\n        var document1 = new Document(this, options);\n        var documentElement = document1.createDocumentElement(svg);\n        this.document = document1;\n        this.documentElement = documentElement;\n    }\n    /**\r\n   * Create Canvg instance from SVG source string or URL.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static from(ctx, svg) {\n        var _arguments = arguments;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};\n            var parser = new Parser(options);\n            var svgDocument = yield parser.parse(svg);\n            return new Canvg(ctx, svgDocument, options);\n        })();\n    }\n    /**\r\n   * Create Canvg instance from SVG source string.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static fromString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var parser = new Parser(options);\n        var svgDocument = parser.parseFromString(svg);\n        return new Canvg(ctx, svgDocument, options);\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ fork(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ forkString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Document is ready promise.\r\n   * @returns Ready promise.\r\n   */ ready() {\n        return this.screen.ready();\n    }\n    /**\r\n   * Document is ready value.\r\n   * @returns Is ready or not.\r\n   */ isReady() {\n        return this.screen.isReady();\n    }\n    /**\r\n   * Render only first frame, ignoring animations and mouse.\r\n   * @param options - Rendering options.\r\n   */ render() {\n        var _arguments2 = arguments, _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};\n            _this.start(_objectSpread({\n                enableRedraw: true,\n                ignoreAnimation: true,\n                ignoreMouse: true\n            }, options));\n            yield _this.ready();\n            _this.stop();\n        })();\n    }\n    /**\r\n   * Start rendering.\r\n   * @param options - Render options.\r\n   */ start() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var { documentElement, screen, options: baseOptions } = this;\n        screen.start(documentElement, _objectSpread(_objectSpread({\n            enableRedraw: true\n        }, baseOptions), options));\n    }\n    /**\r\n   * Stop rendering.\r\n   */ stop() {\n        this.screen.stop();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.documentElement.resize(width, height, preserveAspectRatio);\n    }\n}\n //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZXMuanMiLCJzb3VyY2VzIjpbXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDaUM7QUFDNUI7QUFDRTtBQUNJO0FBQ0o7QUFDVztBQUNXO0FBQ3hCO0FBQ0k7QUFDSjtBQUNKO0FBQ0c7QUFDWDtBQUNjO0FBQ0M7QUFDRjtBQUNGO0FBQ0s7QUFDRjtBQUU5Qzs7Ozs7Q0FLQyxHQUNELFNBQVNNO0lBQ1AsSUFBSSxFQUNGQyxXQUFXQyxpQkFBaUIsRUFDN0IsR0FBR0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztJQUN6RSxJQUFJRyxTQUFTO1FBQ1hDLFFBQVE7UUFDUkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JSLFdBQVdDO1FBRVhRLGNBQWFDLEtBQUssRUFBRUMsTUFBTTtZQUN4QixPQUFPLElBQUlDLGdCQUFnQkYsT0FBT0M7UUFDcEM7UUFFQUUsYUFBWUMsR0FBRztZQUNiLE9BQU9yQixvRUFBaUJBLENBQUM7Z0JBQ3ZCLElBQUlzQixXQUFXLE1BQU1DLE1BQU1GO2dCQUMzQixJQUFJRyxPQUFPLE1BQU1GLFNBQVNFLElBQUk7Z0JBQzlCLElBQUlDLE1BQU0sTUFBTUMsa0JBQWtCRjtnQkFDbEMsT0FBT0M7WUFDVDtRQUNGO0lBRUY7SUFFQSxJQUFJLE9BQU9sQixjQUFjLGVBQWUsT0FBT0Msc0JBQXNCLGFBQWE7UUFDaEZtQixRQUFRQyxjQUFjLENBQUNoQixRQUFRO0lBQ2pDO0lBRUEsT0FBT0E7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTaUIsS0FBS0MsSUFBSTtJQUNoQixJQUFJLEVBQ0Z2QixXQUFBQSxVQUFTLEVBQ1R3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RSxHQUFHLENBQUM7UUFDbkYsSUFBSSxFQUNGMDVCLGVBQWUsRUFDZjd4QixNQUFNLEVBQ051NEIsU0FBU0ssV0FBVyxFQUNyQixHQUFHLElBQUk7UUFDUjU0QixPQUFPOEQsS0FBSyxDQUFDK3RCLGlCQUFpQndHLGNBQWNBLGNBQWM7WUFDeER6dUIsY0FBYztRQUNoQixHQUFHZ3ZCLGNBQWNMO0lBQ25CO0lBQ0E7O0dBRUMsR0FHRHQwQixPQUFPO1FBQ0wsSUFBSSxDQUFDakUsTUFBTSxDQUFDaUUsSUFBSTtJQUNsQjtJQUNBOzs7OztHQUtDLEdBR0QyZixPQUFPanJCLEtBQUssRUFBRTtRQUNaLElBQUlDLFNBQVNULFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHUTtRQUNqRixJQUFJa3JCLHNCQUFzQjFyQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM5RixJQUFJLENBQUMwNUIsZUFBZSxDQUFDak8sTUFBTSxDQUFDanJCLE9BQU9DLFFBQVFpckI7SUFDN0M7QUFFRjtBQUUwb0MsQ0FDMW9DLDR0UkFBNHRSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9jYW52Zy9saWIvaW5kZXguZXMuanM/MGRkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzJztcbmltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3InO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdGFydHMtd2l0aC5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmVuZHMtd2l0aC5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMnO1xuaW1wb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tICdyYWYnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0uanMnO1xuaW1wb3J0IFJHQkNvbG9yIGZyb20gJ3JnYmNvbG9yJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZXZlcnNlLmpzJztcbmltcG9ydCB7IFNWR1BhdGhEYXRhIH0gZnJvbSAnc3ZnLXBhdGhkYXRhJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMnO1xuaW1wb3J0IHsgY2FudmFzUkdCQSB9IGZyb20gJ3N0YWNrYmx1ci1jYW52YXMnO1xuXG4vKipcclxuICogT3B0aW9ucyBwcmVzZXQgZm9yIGBPZmZzY3JlZW5DYW52YXNgLlxyXG4gKiBAcGFyYW0gY29uZmlnIC0gUHJlc2V0IHJlcXVpcmVtZW50cy5cclxuICogQHBhcmFtIGNvbmZpZy5ET01QYXJzZXIgLSBYTUwvSFRNTCBwYXJzZXIgZnJvbSBzdHJpbmcgaW50byBET00gRG9jdW1lbnQuXHJcbiAqIEByZXR1cm5zIFByZXNldCBvYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gb2Zmc2NyZWVuKCkge1xuICB2YXIge1xuICAgIERPTVBhcnNlcjogRE9NUGFyc2VyRmFsbGJhY2tcbiAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBwcmVzZXQgPSB7XG4gICAgd2luZG93OiBudWxsLFxuICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICBET01QYXJzZXI6IERPTVBhcnNlckZhbGxiYWNrLFxuXG4gICAgY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVJbWFnZSh1cmwpIHtcbiAgICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh1cmwpO1xuICAgICAgICB2YXIgYmxvYiA9IHlpZWxkIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgdmFyIGltZyA9IHlpZWxkIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IpO1xuICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgfTtcblxuICBpZiAodHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIERPTVBhcnNlckZhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkocHJlc2V0LCAnRE9NUGFyc2VyJyk7XG4gIH1cblxuICByZXR1cm4gcHJlc2V0O1xufVxuXG4vKipcclxuICogT3B0aW9ucyBwcmVzZXQgZm9yIGBub2RlLWNhbnZhc2AuXHJcbiAqIEBwYXJhbSBjb25maWcgLSBQcmVzZXQgcmVxdWlyZW1lbnRzLlxyXG4gKiBAcGFyYW0gY29uZmlnLkRPTVBhcnNlciAtIFhNTC9IVE1MIHBhcnNlciBmcm9tIHN0cmluZyBpbnRvIERPTSBEb2N1bWVudC5cclxuICogQHBhcmFtIGNvbmZpZy5jYW52YXMgLSBgbm9kZS1jYW52YXNgIGV4cG9ydHMuXHJcbiAqIEBwYXJhbSBjb25maWcuZmV0Y2ggLSBXSEFUV0ctY29tcGF0aWJsZSBgZmV0Y2hgIGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyBQcmVzZXQgb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIG5vZGUoX3JlZikge1xuICB2YXIge1xuICAgIERPTVBhcnNlcixcbiAgICBjYW52YXMsXG4gICAgZmV0Y2hcbiAgfSA9IF9yZWY7XG4gIHJldHVybiB7XG4gICAgd2luZG93OiBudWxsLFxuICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICBET01QYXJzZXIsXG4gICAgZmV0Y2gsXG4gICAgY3JlYXRlQ2FudmFzOiBjYW52YXMuY3JlYXRlQ2FudmFzLFxuICAgIGNyZWF0ZUltYWdlOiBjYW52YXMubG9hZEltYWdlXG4gIH07XG59XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRvZmZzY3JlZW46IG9mZnNjcmVlbixcblx0bm9kZTogbm9kZVxufSk7XG5cbi8qKlxyXG4gKiBIVE1MLXNhZmUgY29tcHJlc3Mgd2hpdGUtc3BhY2VzLlxyXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIGNvbXByZXNzLlxyXG4gKiBAcmV0dXJucyBTdHJpbmcuXHJcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NTcGFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKD8hXFx1MzAwMClcXHMrL2dtLCAnICcpO1xufVxuLyoqXHJcbiAqIEhUTUwtc2FmZSBsZWZ0IHRyaW0uXHJcbiAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gdHJpbS5cclxuICogQHJldHVybnMgU3RyaW5nLlxyXG4gKi9cblxuZnVuY3Rpb24gdHJpbUxlZnQoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXltcXG4gXFx0XSsvLCAnJyk7XG59XG4vKipcclxuICogSFRNTC1zYWZlIHJpZ2h0IHRyaW0uXHJcbiAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gdHJpbS5cclxuICogQHJldHVybnMgU3RyaW5nLlxyXG4gKi9cblxuZnVuY3Rpb24gdHJpbVJpZ2h0KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXG4gXFx0XSskLywgJycpO1xufVxuLyoqXHJcbiAqIFN0cmluZyB0byBudW1iZXJzIGFycmF5LlxyXG4gKiBAcGFyYW0gc3RyIC0gTnVtYmVycyBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIE51bWJlcnMgYXJyYXkuXHJcbiAqL1xuXG5mdW5jdGlvbiB0b051bWJlcnMoc3RyKSB7XG4gIHZhciBtYXRjaGVzID0gKHN0ciB8fCAnJykubWF0Y2goLy0/KFxcZCsoPzpcXC5cXGQqKD86W2VFXVsrLV0/XFxkKyk/KT98XFwuXFxkKykoPz1cXER8JCkvZ20pIHx8IFtdO1xuICByZXR1cm4gbWF0Y2hlcy5tYXAocGFyc2VGbG9hdCk7XG59IC8vIE1pY3Jvc29mdCBFZGdlIGZpeFxuXG52YXIgYWxsVXBwZXJjYXNlID0gL15bQS1aLV0rJC87XG4vKipcclxuICogTm9ybWFsaXplIGF0dHJpYnV0ZSBuYW1lLlxyXG4gKiBAcGFyYW0gbmFtZSAtIEF0dHJpYnV0ZSBuYW1lLlxyXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIGF0dHJpYnV0ZSBuYW1lLlxyXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQXR0cmlidXRlTmFtZShuYW1lKSB7XG4gIGlmIChhbGxVcHBlcmNhc2UudGVzdChuYW1lKSkge1xuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gbmFtZTtcbn1cbi8qKlxyXG4gKiBQYXJzZSBleHRlcm5hbCBVUkwuXHJcbiAqIEBwYXJhbSB1cmwgLSBDU1MgdXJsIHN0cmluZy5cclxuICogQHJldHVybnMgUGFyc2VkIFVSTC5cclxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRXh0ZXJuYWxVcmwodXJsKSB7XG4gIC8vICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZSBxdW90ZXMgWzJdXG4gIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICBkb3VibGUgcXVvdGVzIFszXVxuICAvLyAgICAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgdiAgICAgICAgIG5vIHF1b3RlcyBbNF1cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgIHYgICAgICAgICB2XG4gIHZhciB1cmxNYXRjaCA9IC91cmxcXCgoJyhbXiddKyknfFwiKFteXCJdKylcInwoW14nXCIpXSspKVxcKS8uZXhlYyh1cmwpIHx8IFtdO1xuICByZXR1cm4gdXJsTWF0Y2hbMl0gfHwgdXJsTWF0Y2hbM10gfHwgdXJsTWF0Y2hbNF07XG59XG4vKipcclxuICogVHJhbnNmb3JtIGZsb2F0cyB0byBpbnRlZ2VycyBpbiByZ2IgY29sb3JzLlxyXG4gKiBAcGFyYW0gY29sb3IgLSBDb2xvciB0byBub3JtYWxpemUuXHJcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgY29sb3IuXHJcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICBpZiAoIWNvbG9yLnN0YXJ0c1dpdGgoJ3JnYicpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgdmFyIHJnYlBhcnRzID0gMztcbiAgdmFyIG5vcm1hbGl6ZWRDb2xvciA9IGNvbG9yLnJlcGxhY2UoL1xcZCsoXFwuXFxkKyk/L2csIChudW0sIGlzRmxvYXQpID0+IHJnYlBhcnRzLS0gJiYgaXNGbG9hdCA/IFN0cmluZyhNYXRoLnJvdW5kKHBhcnNlRmxvYXQobnVtKSkpIDogbnVtKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWRDb2xvcjtcbn1cblxuLy8gc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2VlZ2Fuc3RyZWV0L3NwZWNpZmljaXR5L2Jsb2IvbWFzdGVyL3NwZWNpZmljaXR5LmpzXG52YXIgYXR0cmlidXRlUmVnZXggPSAvKFxcW1teXFxdXStcXF0pL2c7XG52YXIgaWRSZWdleCA9IC8oI1teXFxzKz5+Lls6XSspL2c7XG52YXIgY2xhc3NSZWdleCA9IC8oXFwuW15cXHMrPn4uWzpdKykvZztcbnZhciBwc2V1ZG9FbGVtZW50UmVnZXggPSAvKDo6W15cXHMrPn4uWzpdK3w6Zmlyc3QtbGluZXw6Zmlyc3QtbGV0dGVyfDpiZWZvcmV8OmFmdGVyKS9naTtcbnZhciBwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4ID0gLyg6W1xcdy1dK1xcKFteKV0qXFwpKS9naTtcbnZhciBwc2V1ZG9DbGFzc1JlZ2V4ID0gLyg6W15cXHMrPn4uWzpdKykvZztcbnZhciBlbGVtZW50UmVnZXggPSAvKFteXFxzKz5+Lls6XSspL2c7XG5cbmZ1bmN0aW9uIGZpbmRTZWxlY3Rvck1hdGNoKHNlbGVjdG9yLCByZWdleCkge1xuICB2YXIgbWF0Y2hlcyA9IHJlZ2V4LmV4ZWMoc2VsZWN0b3IpO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbc2VsZWN0b3IsIDBdO1xuICB9XG5cbiAgcmV0dXJuIFtzZWxlY3Rvci5yZXBsYWNlKHJlZ2V4LCAnICcpLCBtYXRjaGVzLmxlbmd0aF07XG59XG4vKipcclxuICogTWVhc3VyZSBzZWxlY3RvciBzcGVjaWZpY2l0eS5cclxuICogQHBhcmFtIHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gbWVhc3VyZS5cclxuICogQHJldHVybnMgU3BlY2lmaWNpdHkuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoc2VsZWN0b3IpIHtcbiAgdmFyIHNwZWNpZmljaXR5ID0gWzAsIDAsIDBdO1xuICB2YXIgY3VycmVudFNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvOm5vdFxcKChbXildKilcXCkvZywgJyAgICAgJDEgJykucmVwbGFjZSgve1tcXHNcXFNdKi9nbSwgJyAnKTtcbiAgdmFyIGRlbHRhID0gMDtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBhdHRyaWJ1dGVSZWdleCk7XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGlkUmVnZXgpO1xuICBzcGVjaWZpY2l0eVswXSArPSBkZWx0YTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBjbGFzc1JlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvRWxlbWVudFJlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMl0gKz0gZGVsdGE7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCk7XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0NsYXNzUmVnZXgpO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcbiAgY3VycmVudFNlbGVjdG9yID0gY3VycmVudFNlbGVjdG9yLnJlcGxhY2UoL1sqXFxzKz5+XS9nLCAnICcpLnJlcGxhY2UoL1sjLl0vZywgJyAnKTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBlbGVtZW50UmVnZXgpOyAvLyBsZ3RtIFtqcy91c2VsZXNzLWFzc2lnbm1lbnQtdG8tbG9jYWxdXG5cbiAgc3BlY2lmaWNpdHlbMl0gKz0gZGVsdGE7XG4gIHJldHVybiBzcGVjaWZpY2l0eS5qb2luKCcnKTtcbn1cblxudmFyIFBTRVVET19aRVJPID0gLjAwMDAwMDAxO1xuLyoqXHJcbiAqIFZlY3RvciBtYWduaXR1ZGUuXHJcbiAqIEBwYXJhbSB2XHJcbiAqIEByZXR1cm5zIE51bWJlciByZXN1bHQuXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZWN0b3JNYWduaXR1ZGUodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHZbMF0sIDIpICsgTWF0aC5wb3codlsxXSwgMikpO1xufVxuLyoqXHJcbiAqIFJhdGlvIGJldHdlZW4gdHdvIHZlY3RvcnMuXHJcbiAqIEBwYXJhbSB1XHJcbiAqIEBwYXJhbSB2XHJcbiAqIEByZXR1cm5zIE51bWJlciByZXN1bHQuXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZWN0b3JzUmF0aW8odSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZlY3Rvck1hZ25pdHVkZSh1KSAqIHZlY3Rvck1hZ25pdHVkZSh2KSk7XG59XG4vKipcclxuICogQW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycy5cclxuICogQHBhcmFtIHVcclxuICogQHBhcmFtIHZcclxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cclxuICovXG5cbmZ1bmN0aW9uIHZlY3RvcnNBbmdsZSh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModmVjdG9yc1JhdGlvKHUsIHYpKTtcbn1cbmZ1bmN0aW9uIENCMSh0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBDQjIodCkge1xuICByZXR1cm4gMyAqIHQgKiB0ICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIENCMyh0KSB7XG4gIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gQ0I0KHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIFFCMSh0KSB7XG4gIHJldHVybiB0ICogdDtcbn1cbmZ1bmN0aW9uIFFCMih0KSB7XG4gIHJldHVybiAyICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBRQjModCkge1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCk7XG59XG5cbmNsYXNzIFByb3BlcnR5IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuaXNOb3JtYWxpemVkQ29sb3IgPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBlbXB0eShkb2N1bWVudCkge1xuICAgIHJldHVybiBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdFTVBUWScsICcnKTtcbiAgfVxuXG4gIHNwbGl0KCkge1xuICAgIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcgJztcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBuYW1lXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0U3RyaW5nKCkpLnRyaW0oKS5zcGxpdChzZXBhcmF0b3IpLm1hcCh2YWx1ZSA9PiBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKSk7XG4gIH1cblxuICBoYXNWYWx1ZSh6ZXJvSXNWYWx1ZSkge1xuICAgIHZhciB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgKHplcm9Jc1ZhbHVlIHx8IHZhbHVlICE9PSAwKSAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaXNTdHJpbmcocmVnZXhwKSB7XG4gICAgdmFyIHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG5cbiAgICBpZiAoIXJlc3VsdCB8fCAhcmVnZXhwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiByZWdleHAudGVzdCh2YWx1ZSk7XG4gIH1cblxuICBpc1VybERlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdHJpbmcoL151cmxcXCgvKTtcbiAgfVxuXG4gIGlzUGl4ZWxzKCkge1xuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBhc1N0cmluZy5lbmRzV2l0aCgncHgnKTpcbiAgICAgIGNhc2UgL15bMC05XSskLy50ZXN0KGFzU3RyaW5nKTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldFZhbHVlKGRlZikge1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZWY7XG4gIH1cblxuICBnZXROdW1iZXIoZGVmKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZGVmKTtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgaWYgKHRoaXMuaXNTdHJpbmcoLyUkLykpIHtcbiAgICAgIG4gLz0gMTAwLjA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG4gIH1cblxuICBnZXRTdHJpbmcoZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnZhbHVlID09PSAndW5kZWZpbmVkJyA/ICcnIDogU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcoZGVmKTtcbiAgfVxuXG4gIGdldENvbG9yKGRlZikge1xuICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0U3RyaW5nKGRlZik7XG5cbiAgICBpZiAodGhpcy5pc05vcm1hbGl6ZWRDb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cblxuICAgIHRoaXMuaXNOb3JtYWxpemVkQ29sb3IgPSB0cnVlO1xuICAgIGNvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICAgIHRoaXMudmFsdWUgPSBjb2xvcjtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBnZXREcGkoKSB7XG4gICAgcmV0dXJuIDk2LjA7IC8vIFRPRE86IGNvbXB1dGU/XG4gIH1cblxuICBnZXRSZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgfVxuXG4gIGdldEVtKCkge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmVtU2l6ZTtcbiAgfVxuXG4gIGdldFVuaXRzKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0cmluZygpLnJlcGxhY2UoL1swLTkuLV0vZywgJycpO1xuICB9XG5cbiAgZ2V0UGl4ZWxzKGF4aXNPcklzRm9udFNpemUpIHtcbiAgICB2YXIgcHJvY2Vzc1BlcmNlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBbYXhpcywgaXNGb250U2l6ZV0gPSB0eXBlb2YgYXhpc09ySXNGb250U2l6ZSA9PT0gJ2Jvb2xlYW4nID8gW3VuZGVmaW5lZCwgYXhpc09ySXNGb250U2l6ZV0gOiBbYXhpc09ySXNGb250U2l6ZV07XG4gICAgdmFyIHtcbiAgICAgIHZpZXdQb3J0XG4gICAgfSA9IHRoaXMuZG9jdW1lbnQuc2NyZWVuO1xuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZtaW4kLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwLjAgKiBNYXRoLm1pbih2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpLCB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneScpKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92bWF4JC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogTWF0aC5tYXgodmlld1BvcnQuY29tcHV0ZVNpemUoJ3gnKSwgdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKSk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdnckLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwLjAgKiB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZoJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9yZW0kLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRSZW0oKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9lbSQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZXgkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpIC8gMi4wO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3B4JC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9wdCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpICogKDEuMCAvIDcyLjApO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3BjJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIDE1O1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2NtJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyLjU0O1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL21tJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyNS40O1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2luJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvJSQvKSAmJiBpc0ZvbnRTaXplOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC8lJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKGF4aXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLmdldE51bWJlcigpO1xuXG4gICAgICAgICAgaWYgKHByb2Nlc3NQZXJjZW50ICYmIG4gPCAxLjApIHtcbiAgICAgICAgICAgIHJldHVybiBuICogdmlld1BvcnQuY29tcHV0ZVNpemUoYXhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRNaWxsaXNlY29uZHMoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU3RyaW5nKC9tcyQvKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAxMDAwO1xuICB9XG5cbiAgZ2V0UmFkaWFucygpIHtcbiAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2RlZyQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9ncmFkJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIChNYXRoLlBJIC8gMjAwLjApO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3JhZCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RGVmaW5pdGlvbigpIHtcbiAgICB2YXIgYXNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuICAgIHZhciBuYW1lID0gLyMoW14pJ1wiXSspLy5leGVjKGFzU3RyaW5nKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBuYW1lID0gbmFtZVsxXTtcbiAgICB9XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIG5hbWUgPSBhc1N0cmluZztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5kZWZpbml0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIGdldEZpbGxTdHlsZURlZmluaXRpb24oZWxlbWVudCwgb3BhY2l0eSkge1xuICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oKTtcblxuICAgIGlmICghZGVmKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGdyYWRpZW50XG5cblxuICAgIGlmICh0eXBlb2YgZGVmLmNyZWF0ZUdyYWRpZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZGVmLmNyZWF0ZUdyYWRpZW50KHRoaXMuZG9jdW1lbnQuY3R4LCBlbGVtZW50LCBvcGFjaXR5KTtcbiAgICB9IC8vIHBhdHRlcm5cblxuXG4gICAgaWYgKHR5cGVvZiBkZWYuY3JlYXRlUGF0dGVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgcGF0dGVyblRyYW5zZm9ybSA9IGRlZi5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKTtcbiAgICAgICAgZGVmID0gZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgaWYgKHBhdHRlcm5UcmFuc2Zvcm0uaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGRlZi5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nLCB0cnVlKS5zZXRWYWx1ZShwYXR0ZXJuVHJhbnNmb3JtLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmLmNyZWF0ZVBhdHRlcm4odGhpcy5kb2N1bWVudC5jdHgsIGVsZW1lbnQsIG9wYWNpdHkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0VGV4dEJhc2VsaW5lKCkge1xuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvcGVydHkudGV4dEJhc2VsaW5lTWFwcGluZ1t0aGlzLmdldFN0cmluZygpXTtcbiAgfVxuXG4gIGFkZE9wYWNpdHkob3BhY2l0eSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0Q29sb3IoKTtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgIHZhciBjb21tYXMgPSAwOyAvLyBTaW11bGF0ZSBvbGQgUkdCQ29sb3IgdmVyc2lvbiwgd2hpY2ggY2FuJ3QgcGFyc2UgcmdiYS5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJywnKSB7XG4gICAgICAgIGNvbW1hcysrO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFzID09PSAzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcGFjaXR5Lmhhc1ZhbHVlKCkgJiYgdGhpcy5pc1N0cmluZygpICYmIGNvbW1hcyAhPT0gMykge1xuICAgICAgdmFyIGNvbG9yID0gbmV3IFJHQkNvbG9yKHZhbHVlKTtcblxuICAgICAgaWYgKGNvbG9yLm9rKSB7XG4gICAgICAgIGNvbG9yLmFscGhhID0gb3BhY2l0eS5nZXROdW1iZXIoKTtcbiAgICAgICAgdmFsdWUgPSBjb2xvci50b1JHQkEoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIHRoaXMubmFtZSwgdmFsdWUpO1xuICB9XG5cbn1cblByb3BlcnR5LnRleHRCYXNlbGluZU1hcHBpbmcgPSB7XG4gICdiYXNlbGluZSc6ICdhbHBoYWJldGljJyxcbiAgJ2JlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICd0ZXh0LWJlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICdtaWRkbGUnOiAnbWlkZGxlJyxcbiAgJ2NlbnRyYWwnOiAnbWlkZGxlJyxcbiAgJ2FmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgJ3RleHQtYWZ0ZXItZWRnZSc6ICdib3R0b20nLFxuICAnaWRlb2dyYXBoaWMnOiAnaWRlb2dyYXBoaWMnLFxuICAnYWxwaGFiZXRpYyc6ICdhbHBoYWJldGljJyxcbiAgJ2hhbmdpbmcnOiAnaGFuZ2luZycsXG4gICdtYXRoZW1hdGljYWwnOiAnYWxwaGFiZXRpYydcbn07XG5cbmNsYXNzIFZpZXdQb3J0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMudmlld1BvcnRzID0gW107XG4gIH1cblxuICBzZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnZpZXdQb3J0cy5wdXNoKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVDdXJyZW50KCkge1xuICAgIHRoaXMudmlld1BvcnRzLnBvcCgpO1xuICB9XG5cbiAgZ2V0Q3VycmVudCgpIHtcbiAgICB2YXIge1xuICAgICAgdmlld1BvcnRzXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHZpZXdQb3J0c1t2aWV3UG9ydHMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudCgpLndpZHRoO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50KCkuaGVpZ2h0O1xuICB9XG5cbiAgY29tcHV0ZVNpemUoZCkge1xuICAgIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIGlmIChkID09PSAneCcpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChkID09PSAneScpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMud2lkdGgsIDIpICsgTWF0aC5wb3codGhpcy5oZWlnaHQsIDIpKSAvIE1hdGguc3FydCgyKTtcbiAgfVxuXG59XG5cbmNsYXNzIFBvaW50IHtcbiAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZShwb2ludCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIFt4ID0gZGVmYXVsdFZhbHVlLCB5ID0gZGVmYXVsdFZhbHVlXSA9IHRvTnVtYmVycyhwb2ludCk7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZVNjYWxlKHNjYWxlKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICB2YXIgW3ggPSBkZWZhdWx0VmFsdWUsIHkgPSB4XSA9IHRvTnVtYmVycyhzY2FsZSk7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZVBhdGgocGF0aCkge1xuICAgIHZhciBwb2ludHMgPSB0b051bWJlcnMocGF0aCk7XG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIHBhdGhQb2ludHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgIHBhdGhQb2ludHMucHVzaChuZXcgUG9pbnQocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhQb2ludHM7XG4gIH1cblxuICBhbmdsZVRvKHBvaW50KSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIocG9pbnQueSAtIHRoaXMueSwgcG9pbnQueCAtIHRoaXMueCk7XG4gIH1cblxuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgeHAgPSB4ICogdHJhbnNmb3JtWzBdICsgeSAqIHRyYW5zZm9ybVsyXSArIHRyYW5zZm9ybVs0XTtcbiAgICB2YXIgeXAgPSB4ICogdHJhbnNmb3JtWzFdICsgeSAqIHRyYW5zZm9ybVszXSArIHRyYW5zZm9ybVs1XTtcbiAgICB0aGlzLnggPSB4cDtcbiAgICB0aGlzLnkgPSB5cDtcbiAgfVxuXG59XG5cbmNsYXNzIE1vdXNlIHtcbiAgY29uc3RydWN0b3Ioc2NyZWVuKSB7XG4gICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgdGhpcy53b3JraW5nID0gZmFsc2U7XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuXG4gICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcblxuICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gIH1cblxuICBpc1dvcmtpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMud29ya2luZztcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLndvcmtpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgc2NyZWVuLFxuICAgICAgb25DbGljayxcbiAgICAgIG9uTW91c2VNb3ZlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGNhbnZhcyA9IHNjcmVlbi5jdHguY2FudmFzO1xuICAgIGNhbnZhcy5vbmNsaWNrID0gb25DbGljaztcbiAgICBjYW52YXMub25tb3VzZW1vdmUgPSBvbk1vdXNlTW92ZTtcbiAgICB0aGlzLndvcmtpbmcgPSB0cnVlO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAoIXRoaXMud29ya2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSB0aGlzLnNjcmVlbi5jdHguY2FudmFzO1xuICAgIHRoaXMud29ya2luZyA9IGZhbHNlO1xuICAgIGNhbnZhcy5vbmNsaWNrID0gbnVsbDtcbiAgICBjYW52YXMub25tb3VzZW1vdmUgPSBudWxsO1xuICB9XG5cbiAgaGFzRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLndvcmtpbmcgJiYgdGhpcy5ldmVudHMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIHJ1bkV2ZW50cygpIHtcbiAgICBpZiAoIXRoaXMud29ya2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBzY3JlZW46IGRvY3VtZW50LFxuICAgICAgZXZlbnRzLFxuICAgICAgZXZlbnRFbGVtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkb2N1bWVudC5jdHguY2FudmFzO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBzdHlsZS5jdXJzb3IgPSAnJztcbiAgICB9XG5cbiAgICBldmVudHMuZm9yRWFjaCgoX3JlZiwgaSkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgcnVuXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHZhciBlbGVtZW50ID0gZXZlbnRFbGVtZW50c1tpXTtcblxuICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgcnVuKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfSk7IC8vIGRvbmUgcnVubmluZywgY2xlYXJcblxuICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG4gIH1cblxuICBjaGVja1BhdGgoZWxlbWVudCwgY3R4KSB7XG4gICAgaWYgKCF0aGlzLndvcmtpbmcgfHwgIWN0eCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBldmVudHMsXG4gICAgICBldmVudEVsZW1lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgZXZlbnRzLmZvckVhY2goKF9yZWYyLCBpKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gX3JlZjI7XG5cbiAgICAgIGlmICghZXZlbnRFbGVtZW50c1tpXSAmJiBjdHguaXNQb2ludEluUGF0aCAmJiBjdHguaXNQb2ludEluUGF0aCh4LCB5KSkge1xuICAgICAgICBldmVudEVsZW1lbnRzW2ldID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNoZWNrQm91bmRpbmdCb3goZWxlbWVudCwgYm91bmRpbmdCb3gpIHtcbiAgICBpZiAoIXRoaXMud29ya2luZyB8fCAhYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgZXZlbnRzLFxuICAgICAgZXZlbnRFbGVtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIGV2ZW50cy5mb3JFYWNoKChfcmVmMywgaSkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IF9yZWYzO1xuXG4gICAgICBpZiAoIWV2ZW50RWxlbWVudHNbaV0gJiYgYm91bmRpbmdCb3guaXNQb2ludEluQm94KHgsIHkpKSB7XG4gICAgICAgIGV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwWFkoeCwgeSkge1xuICAgIHZhciB7XG4gICAgICB3aW5kb3csXG4gICAgICBjdHhcbiAgICB9ID0gdGhpcy5zY3JlZW47XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgIHZhciBlbGVtZW50ID0gY3R4LmNhbnZhcztcblxuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICBwb2ludC54IC09IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgIHBvaW50LnkgLT0gZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5zY3JvbGxYKSB7XG4gICAgICBwb2ludC54ICs9IHdpbmRvdy5zY3JvbGxYO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuc2Nyb2xsWSkge1xuICAgICAgcG9pbnQueSArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMubWFwWFkoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICB0eXBlOiAnb25jbGljaycsXG4gICAgICB4LFxuICAgICAgeSxcblxuICAgICAgcnVuKGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGlmIChldmVudFRhcmdldC5vbkNsaWNrKSB7XG4gICAgICAgICAgZXZlbnRUYXJnZXQub25DbGljaygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMubWFwWFkoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICB0eXBlOiAnb25tb3VzZW1vdmUnLFxuICAgICAgeCxcbiAgICAgIHksXG5cbiAgICAgIHJ1bihldmVudFRhcmdldCkge1xuICAgICAgICBpZiAoZXZlbnRUYXJnZXQub25Nb3VzZU1vdmUpIHtcbiAgICAgICAgICBldmVudFRhcmdldC5vbk1vdXNlTW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG59XG5cbnZhciBkZWZhdWx0V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsO1xudmFyIGRlZmF1bHRGZXRjaCQxID0gdHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJyA/IGZldGNoLmJpbmQodW5kZWZpbmVkKSAvLyBgZmV0Y2hgIGRlcGVuZHMgb24gY29udGV4dDogYHNvbWVPYmplY3QuZmV0Y2goLi4uKWAgd2lsbCB0aHJvdyBlcnJvci5cbjogbnVsbDtcbmNsYXNzIFNjcmVlbiB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBmZXRjaCA9IGRlZmF1bHRGZXRjaCQxLFxuICAgICAgd2luZG93ID0gZGVmYXVsdFdpbmRvd1xuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuRlJBTUVSQVRFID0gMzA7XG4gICAgdGhpcy5NQVhfVklSVFVBTF9QSVhFTFMgPSAzMDAwMDtcbiAgICB0aGlzLkNMSUVOVF9XSURUSCA9IDgwMDtcbiAgICB0aGlzLkNMSUVOVF9IRUlHSFQgPSA2MDA7XG4gICAgdGhpcy52aWV3UG9ydCA9IG5ldyBWaWV3UG9ydCgpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcyk7XG4gICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgdGhpcy53YWl0cyA9IFtdO1xuICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5pc1JlYWR5TG9jayA9IGZhbHNlO1xuICAgIHRoaXMuaXNGaXJzdFJlbmRlciA9IHRydWU7XG4gICAgdGhpcy5pbnRlcnZhbElkID0gbnVsbDtcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gIH1cblxuICB3YWl0KGNoZWNrZXIpIHtcbiAgICB0aGlzLndhaXRzLnB1c2goY2hlY2tlcik7XG4gIH1cblxuICByZWFkeSgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICBpZiAoIXRoaXMucmVhZHlQcm9taXNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVhZHlQcm9taXNlO1xuICB9XG5cbiAgaXNSZWFkeSgpIHtcbiAgICBpZiAodGhpcy5pc1JlYWR5TG9jaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVhZHlMb2NrID0gdGhpcy53YWl0cy5ldmVyeShfID0+IF8oKSk7XG5cbiAgICBpZiAoaXNSZWFkeUxvY2spIHtcbiAgICAgIHRoaXMud2FpdHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMucmVzb2x2ZVJlYWR5KSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZVJlYWR5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pc1JlYWR5TG9jayA9IGlzUmVhZHlMb2NrO1xuICAgIHJldHVybiBpc1JlYWR5TG9jaztcbiAgfVxuXG4gIHNldERlZmF1bHRzKGN0eCkge1xuICAgIC8vIGluaXRpYWwgdmFsdWVzIGFuZCBkZWZhdWx0c1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICBjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgIGN0eC5taXRlckxpbWl0ID0gNDtcbiAgfVxuXG4gIHNldFZpZXdCb3goX3JlZikge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGN0eCxcbiAgICAgIGFzcGVjdFJhdGlvLFxuICAgICAgd2lkdGgsXG4gICAgICBkZXNpcmVkV2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBkZXNpcmVkSGVpZ2h0LFxuICAgICAgbWluWCA9IDAsXG4gICAgICBtaW5ZID0gMCxcbiAgICAgIHJlZlgsXG4gICAgICByZWZZLFxuICAgICAgY2xpcCA9IGZhbHNlLFxuICAgICAgY2xpcFggPSAwLFxuICAgICAgY2xpcFkgPSAwXG4gICAgfSA9IF9yZWY7XG4gICAgLy8gYXNwZWN0IHJhdGlvIC0gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGVcbiAgICB2YXIgY2xlYW5Bc3BlY3RSYXRpbyA9IGNvbXByZXNzU3BhY2VzKGFzcGVjdFJhdGlvKS5yZXBsYWNlKC9eZGVmZXJcXHMvLCAnJyk7IC8vIGlnbm9yZSBkZWZlclxuXG4gICAgdmFyIFthc3BlY3RSYXRpb0FsaWduLCBhc3BlY3RSYXRpb01lZXRPclNsaWNlXSA9IGNsZWFuQXNwZWN0UmF0aW8uc3BsaXQoJyAnKTtcbiAgICB2YXIgYWxpZ24gPSBhc3BlY3RSYXRpb0FsaWduIHx8ICd4TWlkWU1pZCc7XG4gICAgdmFyIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW9NZWV0T3JTbGljZSB8fCAnbWVldCc7IC8vIGNhbGN1bGF0ZSBzY2FsZVxuXG4gICAgdmFyIHNjYWxlWCA9IHdpZHRoIC8gZGVzaXJlZFdpZHRoO1xuICAgIHZhciBzY2FsZVkgPSBoZWlnaHQgLyBkZXNpcmVkSGVpZ2h0O1xuICAgIHZhciBzY2FsZU1pbiA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcbiAgICB2YXIgc2NhbGVNYXggPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgdmFyIGZpbmFsRGVzaXJlZFdpZHRoID0gZGVzaXJlZFdpZHRoO1xuICAgIHZhciBmaW5hbERlc2lyZWRIZWlnaHQgPSBkZXNpcmVkSGVpZ2h0O1xuXG4gICAgaWYgKG1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgIGZpbmFsRGVzaXJlZFdpZHRoICo9IHNjYWxlTWluO1xuICAgICAgZmluYWxEZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWluO1xuICAgIH1cblxuICAgIGlmIChtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgZmluYWxEZXNpcmVkV2lkdGggKj0gc2NhbGVNYXg7XG4gICAgICBmaW5hbERlc2lyZWRIZWlnaHQgKj0gc2NhbGVNYXg7XG4gICAgfVxuXG4gICAgdmFyIHJlZlhQcm9wID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAncmVmWCcsIHJlZlgpO1xuICAgIHZhciByZWZZUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3JlZlknLCByZWZZKTtcbiAgICB2YXIgaGFzUmVmcyA9IHJlZlhQcm9wLmhhc1ZhbHVlKCkgJiYgcmVmWVByb3AuaGFzVmFsdWUoKTtcblxuICAgIGlmIChoYXNSZWZzKSB7XG4gICAgICBjdHgudHJhbnNsYXRlKC1zY2FsZU1pbiAqIHJlZlhQcm9wLmdldFBpeGVscygneCcpLCAtc2NhbGVNaW4gKiByZWZZUHJvcC5nZXRQaXhlbHMoJ3knKSk7XG4gICAgfVxuXG4gICAgaWYgKGNsaXApIHtcbiAgICAgIHZhciBzY2FsZWRDbGlwWCA9IHNjYWxlTWluICogY2xpcFg7XG4gICAgICB2YXIgc2NhbGVkQ2xpcFkgPSBzY2FsZU1pbiAqIGNsaXBZO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhzY2FsZWRDbGlwWCwgc2NhbGVkQ2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgc2NhbGVkQ2xpcFkpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5saW5lVG8oc2NhbGVkQ2xpcFgsIGhlaWdodCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgIH1cblxuICAgIGlmICghaGFzUmVmcykge1xuICAgICAgdmFyIGlzTWVldE1pblkgPSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnICYmIHNjYWxlTWluID09PSBzY2FsZVk7XG4gICAgICB2YXIgaXNTbGljZU1heFkgPSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PT0gc2NhbGVZO1xuICAgICAgdmFyIGlzTWVldE1pblggPSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnICYmIHNjYWxlTWluID09PSBzY2FsZVg7XG4gICAgICB2YXIgaXNTbGljZU1heFggPSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PT0gc2NhbGVYO1xuXG4gICAgICBpZiAoYWxpZ24uc3RhcnRzV2l0aCgneE1pZCcpICYmIChpc01lZXRNaW5ZIHx8IGlzU2xpY2VNYXhZKSkge1xuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC8gMi4wIC0gZmluYWxEZXNpcmVkV2lkdGggLyAyLjAsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ24uZW5kc1dpdGgoJ1lNaWQnKSAmJiAoaXNNZWV0TWluWCB8fCBpc1NsaWNlTWF4WCkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLyAyLjAgLSBmaW5hbERlc2lyZWRIZWlnaHQgLyAyLjApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ24uc3RhcnRzV2l0aCgneE1heCcpICYmIChpc01lZXRNaW5ZIHx8IGlzU2xpY2VNYXhZKSkge1xuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC0gZmluYWxEZXNpcmVkV2lkdGgsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxpZ24uZW5kc1dpdGgoJ1lNYXgnKSAmJiAoaXNNZWV0TWluWCB8fCBpc1NsaWNlTWF4WCkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLSBmaW5hbERlc2lyZWRIZWlnaHQpO1xuICAgICAgfVxuICAgIH0gLy8gc2NhbGVcblxuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIGFsaWduID09PSAnbm9uZSc6XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIG1lZXRPclNsaWNlID09PSAnbWVldCc6XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZU1pbiwgc2NhbGVNaW4pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJzpcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlTWF4LCBzY2FsZU1heCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH0gLy8gdHJhbnNsYXRlXG5cblxuICAgIGN0eC50cmFuc2xhdGUoLW1pblgsIC1taW5ZKTtcbiAgfVxuXG4gIHN0YXJ0KGVsZW1lbnQpIHtcbiAgICB2YXIge1xuICAgICAgZW5hYmxlUmVkcmF3ID0gZmFsc2UsXG4gICAgICBpZ25vcmVNb3VzZSA9IGZhbHNlLFxuICAgICAgaWdub3JlQW5pbWF0aW9uID0gZmFsc2UsXG4gICAgICBpZ25vcmVEaW1lbnNpb25zID0gZmFsc2UsXG4gICAgICBpZ25vcmVDbGVhciA9IGZhbHNlLFxuICAgICAgZm9yY2VSZWRyYXcsXG4gICAgICBzY2FsZVdpZHRoLFxuICAgICAgc2NhbGVIZWlnaHQsXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBGUkFNRVJBVEUsXG4gICAgICBtb3VzZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIEZSQU1FUkFURTtcbiAgICB0aGlzLmZyYW1lRHVyYXRpb24gPSBmcmFtZUR1cmF0aW9uO1xuICAgIHRoaXMucmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmVSZWFkeSA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgIHRoaXMucmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgaWYgKCFlbmFibGVSZWRyYXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgdGhlbiA9IG5vdztcbiAgICB2YXIgZGVsdGEgPSAwO1xuXG4gICAgdmFyIHRpY2sgPSAoKSA9PiB7XG4gICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgZGVsdGEgPSBub3cgLSB0aGVuO1xuXG4gICAgICBpZiAoZGVsdGEgPj0gZnJhbWVEdXJhdGlvbikge1xuICAgICAgICB0aGVuID0gbm93IC0gZGVsdGEgJSBmcmFtZUR1cmF0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZShpZ25vcmVBbmltYXRpb24sIGZvcmNlUmVkcmF3KSkge1xuICAgICAgICAgIHRoaXMucmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgbW91c2UucnVuRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnRlcnZhbElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgIH07XG5cbiAgICBpZiAoIWlnbm9yZU1vdXNlKSB7XG4gICAgICBtb3VzZS5zdGFydCgpO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbmNlbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgdGhpcy5pbnRlcnZhbElkID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm1vdXNlLnN0b3AoKTtcbiAgfVxuXG4gIHNob3VsZFVwZGF0ZShpZ25vcmVBbmltYXRpb24sIGZvcmNlUmVkcmF3KSB7XG4gICAgLy8gbmVlZCB1cGRhdGUgZnJvbSBhbmltYXRpb25zP1xuICAgIGlmICghaWdub3JlQW5pbWF0aW9uKSB7XG4gICAgICB2YXIge1xuICAgICAgICBmcmFtZUR1cmF0aW9uXG4gICAgICB9ID0gdGhpcztcbiAgICAgIHZhciBzaG91bGRVcGRhdGUgPSB0aGlzLmFuaW1hdGlvbnMucmVkdWNlKChzaG91bGRVcGRhdGUsIGFuaW1hdGlvbikgPT4gYW5pbWF0aW9uLnVwZGF0ZShmcmFtZUR1cmF0aW9uKSB8fCBzaG91bGRVcGRhdGUsIGZhbHNlKTtcblxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIG5lZWQgdXBkYXRlIGZyb20gcmVkcmF3P1xuXG5cbiAgICBpZiAodHlwZW9mIGZvcmNlUmVkcmF3ID09PSAnZnVuY3Rpb24nICYmIGZvcmNlUmVkcmF3KCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1JlYWR5TG9jayAmJiB0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBuZWVkIHVwZGF0ZSBmcm9tIG1vdXNlIGV2ZW50cz9cblxuXG4gICAgaWYgKHRoaXMubW91c2UuaGFzRXZlbnRzKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICB2YXIge1xuICAgICAgQ0xJRU5UX1dJRFRILFxuICAgICAgQ0xJRU5UX0hFSUdIVCxcbiAgICAgIHZpZXdQb3J0LFxuICAgICAgY3R4LFxuICAgICAgaXNGaXJzdFJlbmRlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgIHZpZXdQb3J0LmNsZWFyKCk7XG5cbiAgICBpZiAoY2FudmFzLndpZHRoICYmIGNhbnZhcy5oZWlnaHQpIHtcbiAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld1BvcnQuc2V0Q3VycmVudChDTElFTlRfV0lEVEgsIENMSUVOVF9IRUlHSFQpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnd2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdoZWlnaHQnKTtcblxuICAgIGlmICghaWdub3JlRGltZW5zaW9ucyAmJiAoaXNGaXJzdFJlbmRlciB8fCB0eXBlb2Ygc2NhbGVXaWR0aCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHNjYWxlSGVpZ2h0ICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIC8vIHNldCBjYW52YXMgc2l6ZVxuICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aFN0eWxlLmdldFBpeGVscygneCcpO1xuXG4gICAgICAgIGlmIChjYW52YXMuc3R5bGUpIHtcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChjYW52YXMud2lkdGgsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFN0eWxlLmdldFBpeGVscygneScpO1xuXG4gICAgICAgIGlmIChjYW52YXMuc3R5bGUpIHtcbiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoY2FudmFzLmhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjV2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGggfHwgY2FudmFzLndpZHRoO1xuICAgIHZhciBjSGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCB8fCBjYW52YXMuaGVpZ2h0O1xuXG4gICAgaWYgKGlnbm9yZURpbWVuc2lvbnMgJiYgd2lkdGhTdHlsZS5oYXNWYWx1ZSgpICYmIGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGNXaWR0aCA9IHdpZHRoU3R5bGUuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICBjSGVpZ2h0ID0gaGVpZ2h0U3R5bGUuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgfVxuXG4gICAgdmlld1BvcnQuc2V0Q3VycmVudChjV2lkdGgsIGNIZWlnaHQpO1xuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXRYID09PSAnbnVtYmVyJykge1xuICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gnLCB0cnVlKS5zZXRWYWx1ZShvZmZzZXRYKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9mZnNldFkgPT09ICdudW1iZXInKSB7XG4gICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScsIHRydWUpLnNldFZhbHVlKG9mZnNldFkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2NhbGVXaWR0aCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNjYWxlSGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHZpZXdCb3ggPSB0b051bWJlcnMoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRTdHJpbmcoKSk7XG4gICAgICB2YXIgeFJhdGlvID0gMDtcbiAgICAgIHZhciB5UmF0aW8gPSAwO1xuXG4gICAgICBpZiAodHlwZW9mIHNjYWxlV2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBfd2lkdGhTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3dpZHRoJyk7XG5cbiAgICAgICAgaWYgKF93aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB4UmF0aW8gPSBfd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKSAvIHNjYWxlV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbMl0pKSB7XG4gICAgICAgICAgeFJhdGlvID0gdmlld0JveFsyXSAvIHNjYWxlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzY2FsZUhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIF9oZWlnaHRTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuXG4gICAgICAgIGlmIChfaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHlSYXRpbyA9IF9oZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKSAvIHNjYWxlSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTih2aWV3Qm94WzNdKSkge1xuICAgICAgICAgIHlSYXRpbyA9IHZpZXdCb3hbM10gLyBzY2FsZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXhSYXRpbykge1xuICAgICAgICB4UmF0aW8gPSB5UmF0aW87XG4gICAgICB9XG5cbiAgICAgIGlmICgheVJhdGlvKSB7XG4gICAgICAgIHlSYXRpbyA9IHhSYXRpbztcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVXaWR0aCk7XG4gICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVIZWlnaHQpO1xuICAgICAgdmFyIHRyYW5zZm9ybVN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0cmFuc2Zvcm1TdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdCh0cmFuc2Zvcm1TdHlsZS5nZXRTdHJpbmcoKSwgXCIgc2NhbGUoXCIpLmNvbmNhdCgxLjAgLyB4UmF0aW8sIFwiLCBcIikuY29uY2F0KDEuMCAvIHlSYXRpbywgXCIpXCIpKTtcbiAgICB9IC8vIGNsZWFyIGFuZCByZW5kZXJcblxuXG4gICAgaWYgKCFpZ25vcmVDbGVhcikge1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjV2lkdGgsIGNIZWlnaHQpO1xuICAgIH1cblxuICAgIGVsZW1lbnQucmVuZGVyKGN0eCk7XG5cbiAgICBpZiAoaXNGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5pc0ZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbn1cblNjcmVlbi5kZWZhdWx0V2luZG93ID0gZGVmYXVsdFdpbmRvdztcblNjcmVlbi5kZWZhdWx0RmV0Y2ggPSBkZWZhdWx0RmV0Y2gkMTtcblxudmFyIHtcbiAgZGVmYXVsdEZldGNoXG59ID0gU2NyZWVuO1xudmFyIERlZmF1bHRET01QYXJzZXIgPSB0eXBlb2YgRE9NUGFyc2VyICE9PSAndW5kZWZpbmVkJyA/IERPTVBhcnNlciA6IG51bGw7XG5jbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIge1xuICAgICAgZmV0Y2ggPSBkZWZhdWx0RmV0Y2gsXG4gICAgICBET01QYXJzZXIgPSBEZWZhdWx0RE9NUGFyc2VyXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgIHRoaXMuRE9NUGFyc2VyID0gRE9NUGFyc2VyO1xuICB9XG5cbiAgcGFyc2UocmVzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAocmVzb3VyY2Uuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wYXJzZUZyb21TdHJpbmcocmVzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMubG9hZChyZXNvdXJjZSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHBhcnNlRnJvbVN0cmluZyh4bWwpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHRoaXMuRE9NUGFyc2VyKCk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tEb2N1bWVudChwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ2ltYWdlL3N2Zyt4bWwnKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja0RvY3VtZW50KHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAndGV4dC94bWwnKSk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tEb2N1bWVudChkb2N1bWVudCkge1xuICAgIHZhciBwYXJzZXJFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpWzBdO1xuXG4gICAgaWYgKHBhcnNlckVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyRXJyb3IudGV4dENvbnRlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBkb2N1bWVudDtcbiAgfVxuXG4gIGxvYWQodXJsKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciByZXNwb25zZSA9IHlpZWxkIF90aGlzMi5mZXRjaCh1cmwpO1xuICAgICAgdmFyIHhtbCA9IHlpZWxkIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHJldHVybiBfdGhpczIucGFyc2VGcm9tU3RyaW5nKHhtbCk7XG4gICAgfSkoKTtcbiAgfVxuXG59XG5cbmNsYXNzIFRyYW5zbGF0ZSB7XG4gIGNvbnN0cnVjdG9yKF8sIHBvaW50KSB7XG4gICAgdGhpcy50eXBlID0gJ3RyYW5zbGF0ZSc7XG4gICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgdGhpcy5wb2ludCA9IFBvaW50LnBhcnNlKHBvaW50KTtcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLnBvaW50O1xuICAgIGN0eC50cmFuc2xhdGUoeCB8fCAwLjAsIHkgfHwgMC4wKTtcbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMucG9pbnQ7XG4gICAgY3R4LnRyYW5zbGF0ZSgtMS4wICogeCB8fCAwLjAsIC0xLjAgKiB5IHx8IDAuMCk7XG4gIH1cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5wb2ludDtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgeCB8fCAwLjAsIHkgfHwgMC4wXSk7XG4gIH1cblxufVxuXG5jbGFzcyBSb3RhdGUge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgcm90YXRlLCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICB0aGlzLnR5cGUgPSAncm90YXRlJztcbiAgICB0aGlzLmFuZ2xlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblggPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWSA9IG51bGw7XG4gICAgdGhpcy5jeCA9IDA7XG4gICAgdGhpcy5jeSA9IDA7XG4gICAgdmFyIG51bWJlcnMgPSB0b051bWJlcnMocm90YXRlKTtcbiAgICB0aGlzLmFuZ2xlID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnYW5nbGUnLCBudW1iZXJzWzBdKTtcbiAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICAgIHRoaXMuY3ggPSBudW1iZXJzWzFdIHx8IDA7XG4gICAgdGhpcy5jeSA9IG51bWJlcnNbMl0gfHwgMDtcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBjeCxcbiAgICAgIGN5LFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICBhbmdsZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IGN4ICsgb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBjeSArIG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC5yb3RhdGUoYW5nbGUuZ2V0UmFkaWFucygpKTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGN4LFxuICAgICAgY3ksXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIGFuZ2xlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHR4ID0gY3ggKyBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IGN5ICsgb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnJvdGF0ZSgtMS4wICogYW5nbGUuZ2V0UmFkaWFucygpKTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgIHZhciB7XG4gICAgICBjeCxcbiAgICAgIGN5LFxuICAgICAgYW5nbGVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcmFkID0gYW5nbGUuZ2V0UmFkaWFucygpO1xuICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCBjeCB8fCAwLjAsIGN5IHx8IDAuMCAvLyB0aGlzLnAueVxuICAgIF0pO1xuICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtNYXRoLmNvcyhyYWQpLCBNYXRoLnNpbihyYWQpLCAtTWF0aC5zaW4ocmFkKSwgTWF0aC5jb3MocmFkKSwgMCwgMF0pO1xuICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCAtY3ggfHwgMC4wLCAtY3kgfHwgMC4wIC8vIC10aGlzLnAueVxuICAgIF0pO1xuICB9XG5cbn1cblxuY2xhc3MgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihfLCBzY2FsZSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdGhpcy50eXBlID0gJ3NjYWxlJztcbiAgICB0aGlzLnNjYWxlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblggPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWSA9IG51bGw7XG4gICAgdmFyIHNjYWxlU2l6ZSA9IFBvaW50LnBhcnNlU2NhbGUoc2NhbGUpOyAvLyBXb3JrYXJvdW5kIGZvciBub2RlLWNhbnZhc1xuXG4gICAgaWYgKHNjYWxlU2l6ZS54ID09PSAwIHx8IHNjYWxlU2l6ZS55ID09PSAwKSB7XG4gICAgICBzY2FsZVNpemUueCA9IFBTRVVET19aRVJPO1xuICAgICAgc2NhbGVTaXplLnkgPSBQU0VVRE9fWkVSTztcbiAgICB9XG5cbiAgICB0aGlzLnNjYWxlID0gc2NhbGVTaXplO1xuICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICB0aGlzLm9yaWdpblkgPSB0cmFuc2Zvcm1PcmlnaW5bMV07XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgc2NhbGU6IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSxcbiAgICAgIG9yaWdpblgsXG4gICAgICBvcmlnaW5ZXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBjdHguc2NhbGUoeCwgeSB8fCB4KTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0sXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnNjYWxlKDEuMCAvIHgsIDEuMCAvIHkgfHwgeCk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5zY2FsZTtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbeCB8fCAwLjAsIDAsIDAsIHkgfHwgMC4wLCAwLCAwXSk7XG4gIH1cblxufVxuXG5jbGFzcyBNYXRyaXgge1xuICBjb25zdHJ1Y3RvcihfLCBtYXRyaXgsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRoaXMudHlwZSA9ICdtYXRyaXgnO1xuICAgIHRoaXMubWF0cml4ID0gW107XG4gICAgdGhpcy5vcmlnaW5YID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblkgPSBudWxsO1xuICAgIHRoaXMubWF0cml4ID0gdG9OdW1iZXJzKG1hdHJpeCk7XG4gICAgdGhpcy5vcmlnaW5YID0gdHJhbnNmb3JtT3JpZ2luWzBdO1xuICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIG1hdHJpeFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLCBtYXRyaXhbM10sIG1hdHJpeFs0XSwgbWF0cml4WzVdKTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIHVuYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIG9yaWdpblgsXG4gICAgICBvcmlnaW5ZLFxuICAgICAgbWF0cml4XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGEgPSBtYXRyaXhbMF07XG4gICAgdmFyIGIgPSBtYXRyaXhbMl07XG4gICAgdmFyIGMgPSBtYXRyaXhbNF07XG4gICAgdmFyIGQgPSBtYXRyaXhbMV07XG4gICAgdmFyIGUgPSBtYXRyaXhbM107XG4gICAgdmFyIGYgPSBtYXRyaXhbNV07XG4gICAgdmFyIGcgPSAwLjA7XG4gICAgdmFyIGggPSAwLjA7XG4gICAgdmFyIGkgPSAxLjA7XG4gICAgdmFyIGRldCA9IDEgLyAoYSAqIChlICogaSAtIGYgKiBoKSAtIGIgKiAoZCAqIGkgLSBmICogZykgKyBjICogKGQgKiBoIC0gZSAqIGcpKTtcbiAgICB2YXIgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC50cmFuc2Zvcm0oZGV0ICogKGUgKiBpIC0gZiAqIGgpLCBkZXQgKiAoZiAqIGcgLSBkICogaSksIGRldCAqIChjICogaCAtIGIgKiBpKSwgZGV0ICogKGEgKiBpIC0gYyAqIGcpLCBkZXQgKiAoYiAqIGYgLSBjICogZSksIGRldCAqIChjICogZCAtIGEgKiBmKSk7XG4gICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gIH1cblxuICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICBwb2ludC5hcHBseVRyYW5zZm9ybSh0aGlzLm1hdHJpeCk7XG4gIH1cblxufVxuXG5jbGFzcyBTa2V3IGV4dGVuZHMgTWF0cml4IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHN1cGVyKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIHRoaXMudHlwZSA9ICdza2V3JztcbiAgICB0aGlzLmFuZ2xlID0gbnVsbDtcbiAgICB0aGlzLmFuZ2xlID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnYW5nbGUnLCBza2V3KTtcbiAgfVxuXG59XG5cbmNsYXNzIFNrZXdYIGV4dGVuZHMgU2tldyB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBzdXBlcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB0aGlzLnR5cGUgPSAnc2tld1gnO1xuICAgIHRoaXMubWF0cml4ID0gWzEsIDAsIE1hdGgudGFuKHRoaXMuYW5nbGUuZ2V0UmFkaWFucygpKSwgMSwgMCwgMF07XG4gIH1cblxufVxuXG5jbGFzcyBTa2V3WSBleHRlbmRzIFNrZXcge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgdGhpcy50eXBlID0gJ3NrZXdZJztcbiAgICB0aGlzLm1hdHJpeCA9IFsxLCBNYXRoLnRhbih0aGlzLmFuZ2xlLmdldFJhZGlhbnMoKSksIDAsIDEsIDAsIDBdO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1zKHRyYW5zZm9ybSkge1xuICByZXR1cm4gY29tcHJlc3NTcGFjZXModHJhbnNmb3JtKS50cmltKCkucmVwbGFjZSgvXFwpKFthLXpBLVpdKS9nLCAnKSAkMScpLnJlcGxhY2UoL1xcKShcXHM/LFxccz8pL2csICcpICcpLnNwbGl0KC9cXHMoPz1bYS16XSkvKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gIHZhciBbdHlwZSwgdmFsdWVdID0gdHJhbnNmb3JtLnNwbGl0KCcoJyk7XG4gIHJldHVybiBbdHlwZS50cmltKCksIHZhbHVlLnRyaW0oKS5yZXBsYWNlKCcpJywgJycpXTtcbn1cblxuY2xhc3MgVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHRyYW5zZm9ybSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICAgIHZhciBkYXRhID0gcGFyc2VUcmFuc2Zvcm1zKHRyYW5zZm9ybSk7XG4gICAgZGF0YS5mb3JFYWNoKHRyYW5zZm9ybSA9PiB7XG4gICAgICBpZiAodHJhbnNmb3JtID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgW3R5cGUsIHZhbHVlXSA9IHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICB2YXIgVHJhbnNmb3JtVHlwZSA9IFRyYW5zZm9ybS50cmFuc2Zvcm1UeXBlc1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBUcmFuc2Zvcm1UeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMucHVzaChuZXcgVHJhbnNmb3JtVHlwZSh0aGlzLmRvY3VtZW50LCB2YWx1ZSwgdHJhbnNmb3JtT3JpZ2luKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGVsZW1lbnQpIHtcbiAgICB2YXIgdHJhbnNmb3JtU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0nLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdmFyIFt0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHksIHRyYW5zZm9ybU9yaWdpbllQcm9wZXJ0eSA9IHRyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eV0gPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgZmFsc2UsIHRydWUpLnNwbGl0KCk7XG4gICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IFt0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHksIHRyYW5zZm9ybU9yaWdpbllQcm9wZXJ0eV07XG5cbiAgICBpZiAodHJhbnNmb3JtU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oZG9jdW1lbnQsIHRyYW5zZm9ybVN0eWxlLmdldFN0cmluZygpLCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHRyYW5zZm9ybXNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbGVuID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0cmFuc2Zvcm1zW2ldLmFwcGx5KGN0eCk7XG4gICAgfVxuICB9XG5cbiAgdW5hcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgdHJhbnNmb3Jtc1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdHJhbnNmb3Jtc1tpXS51bmFwcGx5KGN0eCk7XG4gICAgfVxuICB9IC8vIFRPRE86IGFwcGx5VG9Qb2ludCB1bnVzZWQgLi4uIHJlbW92ZT9cblxuXG4gIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgIHZhciB7XG4gICAgICB0cmFuc2Zvcm1zXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdHJhbnNmb3Jtc1tpXS5hcHBseVRvUG9pbnQocG9pbnQpO1xuICAgIH1cbiAgfVxuXG59XG5UcmFuc2Zvcm0udHJhbnNmb3JtVHlwZXMgPSB7XG4gIHRyYW5zbGF0ZTogVHJhbnNsYXRlLFxuICByb3RhdGU6IFJvdGF0ZSxcbiAgc2NhbGU6IFNjYWxlLFxuICBtYXRyaXg6IE1hdHJpeCxcbiAgc2tld1g6IFNrZXdYLFxuICBza2V3WTogU2tld1lcbn07XG5cbmNsYXNzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSkge1xuICAgIHZhciBjYXB0dXJlVGV4dE5vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLmNhcHR1cmVUZXh0Tm9kZXMgPSBjYXB0dXJlVGV4dE5vZGVzO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3R5bGVzU3BlY2lmaWNpdHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYW5pbWF0aW9uRnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb25Gcm96ZW5WYWx1ZSA9ICcnO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgLy8gRUxFTUVOVF9OT0RFXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBhZGQgYXR0cmlidXRlc1xuXG5cbiAgICBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyaWJ1dGUgPT4ge1xuICAgICAgdmFyIG5vZGVOYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW25vZGVOYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbm9kZU5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7IC8vIGFkZCBpbmxpbmUgc3R5bGVzXG5cbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykuaGFzVmFsdWUoKSkge1xuICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpLmdldFN0cmluZygpLnNwbGl0KCc7JykubWFwKF8gPT4gXy50cmltKCkpO1xuICAgICAgc3R5bGVzLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIFtuYW1lLCB2YWx1ZV0gPSBzdHlsZS5zcGxpdCgnOicpLm1hcChfID0+IF8udHJpbSgpKTtcbiAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBkZWZpbml0aW9uc1xuICAgIH0gPSBkb2N1bWVudDtcbiAgICB2YXIgaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTsgLy8gYWRkIGlkXG5cbiAgICBpZiAoaWQuaGFzVmFsdWUoKSkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uc1tpZC5nZXRTdHJpbmcoKV0pIHtcbiAgICAgICAgZGVmaW5pdGlvbnNbaWQuZ2V0U3RyaW5nKCldID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkTm9kZSk7IC8vIEVMRU1FTlRfTk9ERVxuICAgICAgfSBlbHNlIGlmIChjYXB0dXJlVGV4dE5vZGVzICYmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDMgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09PSA0KSkge1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZE5vZGUpO1xuXG4gICAgICAgIGlmICh0ZXh0Tm9kZS5nZXRUZXh0KCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodGV4dE5vZGUpOyAvLyBURVhUX05PREVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICB2YXIgY3JlYXRlSWZOb3RFeGlzdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBhdHRyID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgaWYgKCFhdHRyICYmIGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICB2YXIgX2F0dHIgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgbmFtZSwgJycpO1xuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBfYXR0cjtcbiAgICAgIHJldHVybiBfYXR0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0ciB8fCBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgfVxuXG4gIGdldEhyZWZBdHRyaWJ1dGUoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnIHx8IGtleS5lbmRzV2l0aCgnOmhyZWYnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb3BlcnR5LmVtcHR5KHRoaXMuZG9jdW1lbnQpO1xuICB9XG5cbiAgZ2V0U3R5bGUobmFtZSkge1xuICAgIHZhciBjcmVhdGVJZk5vdEV4aXN0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdmFyIHNraXBBbmNlc3RvcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGVzW25hbWVdO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgdmFyIGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGlmIChhdHRyICE9PSBudWxsICYmIGF0dHIgIT09IHZvaWQgMCAmJiBhdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gYXR0cjsgLy8gbW92ZSB1cCB0byBtZSB0byBjYWNoZVxuXG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG5cbiAgICBpZiAoIXNraXBBbmNlc3RvcnMpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudFN0eWxlID0gcGFyZW50LmdldFN0eWxlKG5hbWUpO1xuXG4gICAgICAgIGlmIChwYXJlbnRTdHlsZSAhPT0gbnVsbCAmJiBwYXJlbnRTdHlsZSAhPT0gdm9pZCAwICYmIHBhcmVudFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50U3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3JlYXRlSWZOb3RFeGlzdHMpIHtcbiAgICAgIHZhciBfc3R5bGUgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgbmFtZSwgJycpO1xuXG4gICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IF9zdHlsZTtcbiAgICAgIHJldHVybiBfc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlIHx8IFByb3BlcnR5LmVtcHR5KHRoaXMuZG9jdW1lbnQpO1xuICB9XG5cbiAgcmVuZGVyKGN0eCkge1xuICAgIC8vIGRvbid0IHJlbmRlciBkaXNwbGF5PW5vbmVcbiAgICAvLyBkb24ndCByZW5kZXIgdmlzaWJpbGl0eT1oaWRkZW5cbiAgICBpZiAodGhpcy5nZXRTdHlsZSgnZGlzcGxheScpLmdldFN0cmluZygpID09PSAnbm9uZScgfHwgdGhpcy5nZXRTdHlsZSgndmlzaWJpbGl0eScpLmdldFN0cmluZygpID09PSAnaGlkZGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAodGhpcy5nZXRTdHlsZSgnbWFzaycpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIC8vIG1hc2tcbiAgICAgIHZhciBtYXNrID0gdGhpcy5nZXRTdHlsZSgnbWFzaycpLmdldERlZmluaXRpb24oKTtcblxuICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTtcbiAgICAgICAgbWFzay5hcHBseShjdHgsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRTdHlsZSgnZmlsdGVyJykuZ2V0VmFsdWUoJ25vbmUnKSAhPT0gJ25vbmUnKSB7XG4gICAgICAvLyBmaWx0ZXJcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdldFN0eWxlKCdmaWx0ZXInKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTtcbiAgICAgICAgZmlsdGVyLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dChjdHgpO1xuICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihjdHgpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgc2V0Q29udGV4dChfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxuICBhcHBseUVmZmVjdHMoY3R4KSB7XG4gICAgLy8gdHJhbnNmb3JtXG4gICAgdmFyIHRyYW5zZm9ybSA9IFRyYW5zZm9ybS5mcm9tRWxlbWVudCh0aGlzLmRvY3VtZW50LCB0aGlzKTtcblxuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHRyYW5zZm9ybS5hcHBseShjdHgpO1xuICAgIH0gLy8gY2xpcFxuXG5cbiAgICB2YXIgY2xpcFBhdGhTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdjbGlwLXBhdGgnLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICBpZiAoY2xpcFBhdGhTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgdmFyIGNsaXAgPSBjbGlwUGF0aFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgIGNsaXAuYXBwbHkoY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGVhckNvbnRleHQoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNoaWxkLnJlbmRlcihjdHgpO1xuICAgIH0pO1xuICB9XG5cbiAgYWRkQ2hpbGQoY2hpbGROb2RlKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGROb2RlIGluc3RhbmNlb2YgRWxlbWVudCA/IGNoaWxkTm9kZSA6IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjaGlsZE5vZGUpO1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICBpZiAoIUVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcy5pbmNsdWRlcyhjaGlsZC50eXBlKSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICBtYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlO1xuXG4gICAgdmFyIHtcbiAgICAgIG5vZGVcbiAgICB9ID0gdGhpcztcblxuICAgIGlmICh0eXBlb2Ygbm9kZS5tYXRjaGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVDbGFzc2VzID0gKF9ub2RlJGdldEF0dHJpYnV0ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRnZXRBdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGdldEF0dHJpYnV0ZS5jYWxsKG5vZGUsICdjbGFzcycpO1xuXG4gICAgaWYgKCFzdHlsZUNsYXNzZXMgfHwgc3R5bGVDbGFzc2VzID09PSAnJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZUNsYXNzZXMuc3BsaXQoJyAnKS5zb21lKHN0eWxlQ2xhc3MgPT4gXCIuXCIuY29uY2F0KHN0eWxlQ2xhc3MpID09PSBzZWxlY3Rvcik7XG4gIH1cblxuICBhZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCkge1xuICAgIHZhciB7XG4gICAgICBzdHlsZXMsXG4gICAgICBzdHlsZXNTcGVjaWZpY2l0eVxuICAgIH0gPSB0aGlzLmRvY3VtZW50O1xuXG4gICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0AnKSAmJiB0aGlzLm1hdGNoZXNTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW3NlbGVjdG9yXTtcbiAgICAgICAgdmFyIHNwZWNpZmljaXR5ID0gc3R5bGVzU3BlY2lmaWNpdHlbc2VsZWN0b3JdO1xuXG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1NwZWNpZmljaXR5ID0gdGhpcy5zdHlsZXNTcGVjaWZpY2l0eVtuYW1lXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZ1NwZWNpZmljaXR5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBleGlzdGluZ1NwZWNpZmljaXR5ID0gJzAwMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzcGVjaWZpY2l0eSA+PSBleGlzdGluZ1NwZWNpZmljaXR5KSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzU3BlY2lmaWNpdHlbbmFtZV0gPSBzcGVjaWZpY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW1vdmVTdHlsZXMoZWxlbWVudCwgaWdub3JlU3R5bGVzKSB7XG4gICAgdmFyIHRvUmVzdG9yZSA9IGlnbm9yZVN0eWxlcy5yZWR1Y2UoKHRvUmVzdG9yZSwgbmFtZSkgPT4ge1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IGVsZW1lbnQuZ2V0U3R5bGUobmFtZSk7XG5cbiAgICAgIGlmICghc3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRvUmVzdG9yZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gc3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgc3R5bGVQcm9wLnNldFZhbHVlKCcnKTtcbiAgICAgIHJldHVybiBbLi4udG9SZXN0b3JlLCBbbmFtZSwgdmFsdWVdXTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHRvUmVzdG9yZTtcbiAgfVxuXG4gIHJlc3RvcmVTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgc3R5bGVzLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICB2YXIgW25hbWUsIHZhbHVlXSA9IF9yZWY7XG4gICAgICBlbGVtZW50LmdldFN0eWxlKG5hbWUsIHRydWUpLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlzRmlyc3RDaGlsZCgpIHtcbiAgICB2YXIgX3RoaXMkcGFyZW50O1xuXG4gICAgcmV0dXJuICgoX3RoaXMkcGFyZW50ID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF90aGlzJHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcykpID09PSAwO1xuICB9XG5cbn1cbkVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcyA9IFsndGl0bGUnXTtcblxuY2xhc3MgVW5rbm93bkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiB3cmFwRm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gIHZhciB0cmltbWVkID0gZm9udEZhbWlseS50cmltKCk7XG4gIHJldHVybiAvXignfFwiKS8udGVzdCh0cmltbWVkKSA/IHRyaW1tZWQgOiBcIlxcXCJcIi5jb25jYXQodHJpbW1lZCwgXCJcXFwiXCIpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgPyBmb250RmFtaWx5IDogZm9udEZhbWlseS50cmltKCkuc3BsaXQoJywnKS5tYXAod3JhcEZvbnRGYW1pbHkpLmpvaW4oJywnKTtcbn1cbi8qKlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC1zdHlsZVxyXG4gKiBAcGFyYW0gZm9udFN0eWxlXHJcbiAqIEByZXR1cm5zIENTUyBmb250IHN0eWxlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlRm9udFN0eWxlKGZvbnRTdHlsZSkge1xuICBpZiAoIWZvbnRTdHlsZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0YXJnZXRGb250U3R5bGUgPSBmb250U3R5bGUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoICh0YXJnZXRGb250U3R5bGUpIHtcbiAgICBjYXNlICdub3JtYWwnOlxuICAgIGNhc2UgJ2l0YWxpYyc6XG4gICAgY2FzZSAnb2JsaXF1ZSc6XG4gICAgY2FzZSAnaW5oZXJpdCc6XG4gICAgY2FzZSAnaW5pdGlhbCc6XG4gICAgY2FzZSAndW5zZXQnOlxuICAgICAgcmV0dXJuIHRhcmdldEZvbnRTdHlsZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoL15vYmxpcXVlXFxzKygtfClcXGQrZGVnJC8udGVzdCh0YXJnZXRGb250U3R5bGUpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRGb250U3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXdlaWdodFxyXG4gKiBAcGFyYW0gZm9udFdlaWdodFxyXG4gKiBAcmV0dXJucyBDU1MgZm9udCB3ZWlnaHQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHByZXBhcmVGb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgaWYgKCFmb250V2VpZ2h0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIHRhcmdldEZvbnRXZWlnaHQgPSBmb250V2VpZ2h0LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAodGFyZ2V0Rm9udFdlaWdodCkge1xuICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgY2FzZSAnYm9sZCc6XG4gICAgY2FzZSAnbGlnaHRlcic6XG4gICAgY2FzZSAnYm9sZGVyJzpcbiAgICBjYXNlICdpbmhlcml0JzpcbiAgICBjYXNlICdpbml0aWFsJzpcbiAgICBjYXNlICd1bnNldCc6XG4gICAgICByZXR1cm4gdGFyZ2V0Rm9udFdlaWdodDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoL15bXFxkLl0rJC8udGVzdCh0YXJnZXRGb250V2VpZ2h0KSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFdlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmNsYXNzIEZvbnQge1xuICBjb25zdHJ1Y3Rvcihmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCkge1xuICAgIHZhciBpbmhlcml0Rm9udCA9IGluaGVyaXQgPyB0eXBlb2YgaW5oZXJpdCA9PT0gJ3N0cmluZycgPyBGb250LnBhcnNlKGluaGVyaXQpIDogaW5oZXJpdCA6IHt9O1xuICAgIHRoaXMuZm9udEZhbWlseSA9IGZvbnRGYW1pbHkgfHwgaW5oZXJpdEZvbnQuZm9udEZhbWlseTtcbiAgICB0aGlzLmZvbnRTaXplID0gZm9udFNpemUgfHwgaW5oZXJpdEZvbnQuZm9udFNpemU7XG4gICAgdGhpcy5mb250U3R5bGUgPSBmb250U3R5bGUgfHwgaW5oZXJpdEZvbnQuZm9udFN0eWxlO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQgfHwgaW5oZXJpdEZvbnQuZm9udFdlaWdodDtcbiAgICB0aGlzLmZvbnRWYXJpYW50ID0gZm9udFZhcmlhbnQgfHwgaW5oZXJpdEZvbnQuZm9udFZhcmlhbnQ7XG4gIH1cblxuICBzdGF0aWMgcGFyc2UoKSB7XG4gICAgdmFyIGZvbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgIHZhciBpbmhlcml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGZvbnRTdHlsZSA9ICcnO1xuICAgIHZhciBmb250VmFyaWFudCA9ICcnO1xuICAgIHZhciBmb250V2VpZ2h0ID0gJyc7XG4gICAgdmFyIGZvbnRTaXplID0gJyc7XG4gICAgdmFyIGZvbnRGYW1pbHkgPSAnJztcbiAgICB2YXIgcGFydHMgPSBjb21wcmVzc1NwYWNlcyhmb250KS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICB2YXIgc2V0ID0ge1xuICAgICAgZm9udFNpemU6IGZhbHNlLFxuICAgICAgZm9udFN0eWxlOiBmYWxzZSxcbiAgICAgIGZvbnRXZWlnaHQ6IGZhbHNlLFxuICAgICAgZm9udFZhcmlhbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgIXNldC5mb250U3R5bGUgJiYgRm9udC5zdHlsZXMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgZm9udFN0eWxlID0gcGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICFzZXQuZm9udFZhcmlhbnQgJiYgRm9udC52YXJpYW50cy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBmb250VmFyaWFudCA9IHBhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICFzZXQuZm9udFdlaWdodCAmJiBGb250LndlaWdodHMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgZm9udFdlaWdodCA9IHBhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICBzZXQuZm9udFdlaWdodCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAhc2V0LmZvbnRTaXplOlxuICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIFtmb250U2l6ZV0gPSBwYXJ0LnNwbGl0KCcvJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICBzZXQuZm9udFdlaWdodCA9IHRydWU7XG4gICAgICAgICAgc2V0LmZvbnRTaXplID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgKz0gcGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEZvbnQoZm9udFN0eWxlLCBmb250VmFyaWFudCwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGluaGVyaXQpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFtwcmVwYXJlRm9udFN0eWxlKHRoaXMuZm9udFN0eWxlKSwgdGhpcy5mb250VmFyaWFudCwgcHJlcGFyZUZvbnRXZWlnaHQodGhpcy5mb250V2VpZ2h0KSwgdGhpcy5mb250U2l6ZSwgLy8gV3JhcCBmb250RmFtaWx5IG9ubHkgb24gbm9kZWpzIGFuZCBvbmx5IGZvciBjYW52YXMuY3R4XG4gICAgcHJlcGFyZUZvbnRGYW1pbHkodGhpcy5mb250RmFtaWx5KV0uam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG59XG5Gb250LnN0eWxlcyA9ICdub3JtYWx8aXRhbGljfG9ibGlxdWV8aW5oZXJpdCc7XG5Gb250LnZhcmlhbnRzID0gJ25vcm1hbHxzbWFsbC1jYXBzfGluaGVyaXQnO1xuRm9udC53ZWlnaHRzID0gJ25vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwfGluaGVyaXQnO1xuXG5jbGFzcyBCb3VuZGluZ0JveCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciB4MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogTnVtYmVyLk5hTjtcbiAgICB2YXIgeTEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE51bWJlci5OYU47XG4gICAgdmFyIHgyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBOdW1iZXIuTmFOO1xuICAgIHZhciB5MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogTnVtYmVyLk5hTjtcbiAgICB0aGlzLngxID0geDE7XG4gICAgdGhpcy55MSA9IHkxO1xuICAgIHRoaXMueDIgPSB4MjtcbiAgICB0aGlzLnkyID0geTI7XG4gICAgdGhpcy5hZGRQb2ludCh4MSwgeTEpO1xuICAgIHRoaXMuYWRkUG9pbnQoeDIsIHkyKTtcbiAgfVxuXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLngxO1xuICB9XG5cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMueTE7XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy55MiAtIHRoaXMueTE7XG4gIH1cblxuICBhZGRQb2ludCh4LCB5KSB7XG4gICAgaWYgKHR5cGVvZiB4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueDIpKSB7XG4gICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICB0aGlzLngyID0geDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPCB0aGlzLngxKSB7XG4gICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA+IHRoaXMueDIpIHtcbiAgICAgICAgdGhpcy54MiA9IHg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGlzTmFOKHRoaXMueTEpIHx8IGlzTmFOKHRoaXMueTIpKSB7XG4gICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgIH1cblxuICAgICAgaWYgKHkgPCB0aGlzLnkxKSB7XG4gICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgfVxuXG4gICAgICBpZiAoeSA+IHRoaXMueTIpIHtcbiAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRkWCh4KSB7XG4gICAgdGhpcy5hZGRQb2ludCh4LCBudWxsKTtcbiAgfVxuXG4gIGFkZFkoeSkge1xuICAgIHRoaXMuYWRkUG9pbnQobnVsbCwgeSk7XG4gIH1cblxuICBhZGRCb3VuZGluZ0JveChib3VuZGluZ0JveCkge1xuICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTJcbiAgICB9ID0gYm91bmRpbmdCb3g7XG4gICAgdGhpcy5hZGRQb2ludCh4MSwgeTEpO1xuICAgIHRoaXMuYWRkUG9pbnQoeDIsIHkyKTtcbiAgfVxuXG4gIHN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHAwICsgMyAqIE1hdGgucG93KDEgLSB0LCAyKSAqIHQgKiBwMSArIDMgKiAoMSAtIHQpICogTWF0aC5wb3codCwgMikgKiBwMiArIE1hdGgucG93KHQsIDMpICogcDM7XG4gIH1cblxuICBiZXppZXJDdXJ2ZUFkZChmb3JYLCBwMCwgcDEsIHAyLCBwMykge1xuICAgIHZhciBiID0gNiAqIHAwIC0gMTIgKiBwMSArIDYgKiBwMjtcbiAgICB2YXIgYSA9IC0zICogcDAgKyA5ICogcDEgLSA5ICogcDIgKyAzICogcDM7XG4gICAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG5cbiAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgaWYgKGIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdCA9IC1jIC8gYjtcblxuICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZFkodGhpcy5zdW1DdWJpYyh0LCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xuXG4gICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG5cbiAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgaWYgKGZvclgpIHtcbiAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModDEsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFkodGhpcy5zdW1DdWJpYyh0MSwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcblxuICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICBpZiAoZm9yWCkge1xuICAgICAgICB0aGlzLmFkZFgodGhpcy5zdW1DdWJpYyh0MiwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQyLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBmcm9tIGh0dHA6Ly9ibG9nLmhhY2tlcnMtY2FmZS5uZXQvMjAwOS8wNi9ob3ctdG8tY2FsY3VsYXRlLWJlemllci1jdXJ2ZXMtYm91bmRpbmcuaHRtbFxuXG5cbiAgYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICB0aGlzLmFkZFBvaW50KHAweCwgcDB5KTtcbiAgICB0aGlzLmFkZFBvaW50KHAzeCwgcDN5KTtcbiAgICB0aGlzLmJlemllckN1cnZlQWRkKHRydWUsIHAweCwgcDF4LCBwMngsIHAzeCk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZUFkZChmYWxzZSwgcDB5LCBwMXksIHAyeSwgcDN5KTtcbiAgfVxuXG4gIGFkZFF1YWRyYXRpY0N1cnZlKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICB2YXIgY3AxeCA9IHAweCArIDIgLyAzICogKHAxeCAtIHAweCk7IC8vIENQMSA9IFFQMCArIDIvMyAqKFFQMS1RUDApXG5cbiAgICB2YXIgY3AxeSA9IHAweSArIDIgLyAzICogKHAxeSAtIHAweSk7IC8vIENQMSA9IFFQMCArIDIvMyAqKFFQMS1RUDApXG5cbiAgICB2YXIgY3AyeCA9IGNwMXggKyAxIC8gMyAqIChwMnggLSBwMHgpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuXG4gICAgdmFyIGNwMnkgPSBjcDF5ICsgMSAvIDMgKiAocDJ5IC0gcDB5KTsgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcblxuICAgIHRoaXMuYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIGNwMXgsIGNwMngsIGNwMXksIGNwMnksIHAyeCwgcDJ5KTtcbiAgfVxuXG4gIGlzUG9pbnRJbkJveCh4LCB5KSB7XG4gICAgdmFyIHtcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHgxIDw9IHggJiYgeCA8PSB4MiAmJiB5MSA8PSB5ICYmIHkgPD0geTI7XG4gIH1cblxufVxuXG5jbGFzcyBQYXRoUGFyc2VyIGV4dGVuZHMgU1ZHUGF0aERhdGEge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgc3VwZXIocGF0aCAvLyBGaXggc3BhY2VzIGFmdGVyIHNpZ25zLlxuICAgIC5yZXBsYWNlKC8oWytcXC0uXSlcXHMrL2dtLCAnJDEnKSAvLyBSZW1vdmUgaW52YWxpZCBwYXJ0LlxuICAgIC5yZXBsYWNlKC9bXk1tWnpMbEhoVnZDY1NzUXFUdEFhZVxcZFxccy4sKy1dLiovZywgJycpKTtcbiAgICB0aGlzLmNvbnRyb2wgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5jb21tYW5kID0gbnVsbDtcbiAgICB0aGlzLmNvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICB0aGlzLmkgPSAtMTtcbiAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IG51bGw7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLmFuZ2xlcyA9IFtdO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pID0gLTE7XG4gICAgdGhpcy5jb21tYW5kID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IG51bGw7XG4gICAgdGhpcy5zdGFydCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICB0aGlzLmNvbnRyb2wgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IFBvaW50KDAsIDApO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5hbmdsZXMgPSBbXTtcbiAgfVxuXG4gIGlzRW5kKCkge1xuICAgIHZhciB7XG4gICAgICBpLFxuICAgICAgY29tbWFuZHNcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gaSA+PSBjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG5cbiAgbmV4dCgpIHtcbiAgICB2YXIgY29tbWFuZCA9IHRoaXMuY29tbWFuZHNbKyt0aGlzLmldO1xuICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gdGhpcy5jb21tYW5kO1xuICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgcmV0dXJuIGNvbW1hbmQ7XG4gIH1cblxuICBnZXRQb2ludCgpIHtcbiAgICB2YXIgeFByb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICd4JztcbiAgICB2YXIgeVByb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd5JztcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQodGhpcy5jb21tYW5kW3hQcm9wXSwgdGhpcy5jb21tYW5kW3lQcm9wXSk7XG4gICAgcmV0dXJuIHRoaXMubWFrZUFic29sdXRlKHBvaW50KTtcbiAgfVxuXG4gIGdldEFzQ29udHJvbFBvaW50KHhQcm9wLCB5UHJvcCkge1xuICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0UG9pbnQoeFByb3AsIHlQcm9wKTtcbiAgICB0aGlzLmNvbnRyb2wgPSBwb2ludDtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICBnZXRBc0N1cnJlbnRQb2ludCh4UHJvcCwgeVByb3ApIHtcbiAgICB2YXIgcG9pbnQgPSB0aGlzLmdldFBvaW50KHhQcm9wLCB5UHJvcCk7XG4gICAgdGhpcy5jdXJyZW50ID0gcG9pbnQ7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCkge1xuICAgIHZhciBwcmV2aW91c0NvbW1hbmQgPSB0aGlzLnByZXZpb3VzQ29tbWFuZC50eXBlO1xuXG4gICAgaWYgKHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuQ1VSVkVfVE8gJiYgcHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5TTU9PVEhfQ1VSVkVfVE8gJiYgcHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5RVUFEX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuU01PT1RIX1FVQURfVE8pIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfSAvLyByZWZsZWN0IHBvaW50XG5cblxuICAgIHZhciB7XG4gICAgICBjdXJyZW50OiB7XG4gICAgICAgIHg6IGN4LFxuICAgICAgICB5OiBjeVxuICAgICAgfSxcbiAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgeDogb3gsXG4gICAgICAgIHk6IG95XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KDIgKiBjeCAtIG94LCAyICogY3kgLSBveSk7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgbWFrZUFic29sdXRlKHBvaW50KSB7XG4gICAgaWYgKHRoaXMuY29tbWFuZC5yZWxhdGl2ZSkge1xuICAgICAgdmFyIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgIHBvaW50LnggKz0geDtcbiAgICAgIHBvaW50LnkgKz0geTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICBhZGRNYXJrZXIocG9pbnQsIGZyb20sIHByaW9yVG8pIHtcbiAgICB2YXIge1xuICAgICAgcG9pbnRzLFxuICAgICAgYW5nbGVzXG4gICAgfSA9IHRoaXM7IC8vIGlmIHRoZSBsYXN0IGFuZ2xlIGlzbid0IGZpbGxlZCBpbiBiZWNhdXNlIHdlIGRpZG4ndCBoYXZlIHRoaXMgcG9pbnQgeWV0IC4uLlxuXG4gICAgaWYgKHByaW9yVG8gJiYgYW5nbGVzLmxlbmd0aCA+IDAgJiYgIWFuZ2xlc1thbmdsZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgIGFuZ2xlc1thbmdsZXMubGVuZ3RoIC0gMV0gPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLmFuZ2xlVG8ocHJpb3JUbyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRNYXJrZXJBbmdsZShwb2ludCwgZnJvbSA/IGZyb20uYW5nbGVUbyhwb2ludCkgOiBudWxsKTtcbiAgfVxuXG4gIGFkZE1hcmtlckFuZ2xlKHBvaW50LCBhbmdsZSkge1xuICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIHRoaXMuYW5nbGVzLnB1c2goYW5nbGUpO1xuICB9XG5cbiAgZ2V0TWFya2VyUG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgfVxuXG4gIGdldE1hcmtlckFuZ2xlcygpIHtcbiAgICB2YXIge1xuICAgICAgYW5nbGVzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IGFuZ2xlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWFuZ2xlc1tpXSkge1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGlmIChhbmdsZXNbal0pIHtcbiAgICAgICAgICAgIGFuZ2xlc1tpXSA9IGFuZ2xlc1tqXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbmdsZXM7XG4gIH1cblxufVxuXG5jbGFzcyBSZW5kZXJlZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2sgPSBmYWxzZTtcbiAgfVxuXG4gIGNhbGN1bGF0ZU9wYWNpdHkoKSB7XG4gICAgdmFyIG9wYWNpdHkgPSAxLjA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcywgY29uc2lzdGVudC10aGlzXG5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG5cbiAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgdmFyIG9wYWNpdHlTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ29wYWNpdHknLCBmYWxzZSwgdHJ1ZSk7IC8vIG5vIGFuY2VzdG9ycyBvbiBzdHlsZSBjYWxsXG5cbiAgICAgIGlmIChvcGFjaXR5U3R5bGUuaGFzVmFsdWUodHJ1ZSkpIHtcbiAgICAgICAgb3BhY2l0eSAqPSBvcGFjaXR5U3R5bGUuZ2V0TnVtYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BhY2l0eTtcbiAgfVxuXG4gIHNldENvbnRleHQoY3R4KSB7XG4gICAgdmFyIGZyb21NZWFzdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIGlmICghZnJvbU1lYXN1cmUpIHtcbiAgICAgIC8vIGNhdXNlcyBzdGFjayBvdmVyZmxvdyB3aGVuIG1lYXN1cmluZyB0ZXh0IHdpdGggZ3JhZGllbnRzXG4gICAgICAvLyBmaWxsXG4gICAgICB2YXIgZmlsbFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZpbGwnKTtcbiAgICAgIHZhciBmaWxsT3BhY2l0eVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZpbGwtb3BhY2l0eScpO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZScpO1xuICAgICAgdmFyIHN0cm9rZU9wYWNpdHlQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLW9wYWNpdHknKTtcblxuICAgICAgaWYgKGZpbGxTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgdmFyIGZpbGxTdHlsZSA9IGZpbGxTdHlsZVByb3AuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCBmaWxsT3BhY2l0eVN0eWxlUHJvcCk7XG5cbiAgICAgICAgaWYgKGZpbGxTdHlsZSkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlsbFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGlmIChmaWxsU3R5bGVQcm9wLmdldFN0cmluZygpID09PSAnY3VycmVudENvbG9yJykge1xuICAgICAgICAgIGZpbGxTdHlsZVByb3Auc2V0VmFsdWUodGhpcy5nZXRTdHlsZSgnY29sb3InKS5nZXRDb2xvcigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZmlsbFN0eWxlID0gZmlsbFN0eWxlUHJvcC5nZXRDb2xvcigpO1xuXG4gICAgICAgIGlmIChfZmlsbFN0eWxlICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gX2ZpbGxTdHlsZSA9PT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogX2ZpbGxTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlsbE9wYWNpdHlTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgX2ZpbGxTdHlsZTIgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2ZpbGwnLCBjdHguZmlsbFN0eWxlKS5hZGRPcGFjaXR5KGZpbGxPcGFjaXR5U3R5bGVQcm9wKS5nZXRDb2xvcigpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBfZmlsbFN0eWxlMjtcbiAgICAgIH0gLy8gc3Ryb2tlXG5cblxuICAgICAgaWYgKHN0cm9rZVN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZVByb3AuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCBzdHJva2VPcGFjaXR5UHJvcCk7XG5cbiAgICAgICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3Ryb2tlU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgaWYgKHN0cm9rZVN0eWxlUHJvcC5nZXRTdHJpbmcoKSA9PT0gJ2N1cnJlbnRDb2xvcicpIHtcbiAgICAgICAgICBzdHJva2VTdHlsZVByb3Auc2V0VmFsdWUodGhpcy5nZXRTdHlsZSgnY29sb3InKS5nZXRDb2xvcigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKF9zdHJva2VTdHlsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gX3N0cm9rZVN0eWxlID09PSAnbm9uZScgPyAncmdiYSgwLDAsMCwwKScgOiBfc3Ryb2tlU3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0cm9rZU9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIF9zdHJva2VTdHlsZTIgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3N0cm9rZScsIGN0eC5zdHJva2VTdHlsZSkuYWRkT3BhY2l0eShzdHJva2VPcGFjaXR5UHJvcCkuZ2V0U3RyaW5nKCk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gX3N0cm9rZVN0eWxlMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cm9rZVdpZHRoU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLXdpZHRoJyk7XG5cbiAgICAgIGlmIChzdHJva2VXaWR0aFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBuZXdMaW5lV2lkdGggPSBzdHJva2VXaWR0aFN0eWxlUHJvcC5nZXRQaXhlbHMoKTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9ICFuZXdMaW5lV2lkdGggPyBQU0VVRE9fWkVSTyAvLyBicm93c2VycyBkb24ndCByZXNwZWN0IDAgKG9yIG5vZGUtY2FudmFzPyA6LSlcbiAgICAgICAgOiBuZXdMaW5lV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHJva2VMaW5lY2FwU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLWxpbmVjYXAnKTtcbiAgICAgIHZhciBzdHJva2VMaW5lam9pblN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1saW5lam9pbicpO1xuICAgICAgdmFyIHN0cm9rZU1pdGVybGltaXRQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLW1pdGVybGltaXQnKTsgLy8gTkVFRCBURVNUXG4gICAgICAvLyBjb25zdCBwb2ludE9yZGVyU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgncGFpbnQtb3JkZXInKTtcblxuICAgICAgdmFyIHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcbiAgICAgIHZhciBzdHJva2VEYXNob2Zmc2V0UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cbiAgICAgIGlmIChzdHJva2VMaW5lY2FwU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBzdHJva2VMaW5lY2FwU3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICBjdHgubGluZUpvaW4gPSBzdHJva2VMaW5lam9pblN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cm9rZU1pdGVybGltaXRQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSBzdHJva2VNaXRlcmxpbWl0UHJvcC5nZXROdW1iZXIoKTtcbiAgICAgIH0gLy8gTkVFRCBURVNUXG4gICAgICAvLyBpZiAocG9pbnRPcmRlclN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyBcdC8vID9cbiAgICAgIC8vIFx0Y3R4LnBhaW50T3JkZXIgPSBwb2ludE9yZGVyU3R5bGVQcm9wLmdldFZhbHVlKCk7XG4gICAgICAvLyB9XG5cblxuICAgICAgaWYgKHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5oYXNWYWx1ZSgpICYmIHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5nZXRTdHJpbmcoKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHZhciBnYXBzID0gdG9OdW1iZXJzKHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5nZXRTdHJpbmcoKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjdHguc2V0TGluZURhc2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGdhcHMpO1xuICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgaWYgKHR5cGVvZiBjdHgud2Via2l0TGluZURhc2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGN0eC53ZWJraXRMaW5lRGFzaCA9IGdhcHM7XG4gICAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgubW96RGFzaCAhPT0gJ3VuZGVmaW5lZCcgJiYgIShnYXBzLmxlbmd0aCA9PT0gMSAmJiBnYXBzWzBdID09PSAwKSkge1xuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgY3R4Lm1vekRhc2ggPSBnYXBzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSBzdHJva2VEYXNob2Zmc2V0UHJvcC5nZXRQaXhlbHMoKTtcblxuICAgICAgICBpZiAodHlwZW9mIGN0eC5saW5lRGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgY3R4LndlYmtpdExpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4Lm1vekRhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICBjdHgubW96RGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGZvbnRcblxuXG4gICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGN0eC5mb250ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGZvbnRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250Jyk7XG4gICAgICB2YXIgZm9udFN0eWxlU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1zdHlsZScpO1xuICAgICAgdmFyIGZvbnRWYXJpYW50U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC12YXJpYW50Jyk7XG4gICAgICB2YXIgZm9udFdlaWdodFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtd2VpZ2h0Jyk7XG4gICAgICB2YXIgZm9udFNpemVTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXNpemUnKTtcbiAgICAgIHZhciBmb250RmFtaWx5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1mYW1pbHknKTtcbiAgICAgIHZhciBmb250ID0gbmV3IEZvbnQoZm9udFN0eWxlU3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250VmFyaWFudFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgZm9udFdlaWdodFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgZm9udFNpemVTdHlsZVByb3AuaGFzVmFsdWUoKSA/IFwiXCIuY29uY2F0KGZvbnRTaXplU3R5bGVQcm9wLmdldFBpeGVscyh0cnVlKSwgXCJweFwiKSA6ICcnLCBmb250RmFtaWx5U3R5bGVQcm9wLmdldFN0cmluZygpLCBGb250LnBhcnNlKGZvbnRTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGN0eC5mb250KSk7XG4gICAgICBmb250U3R5bGVTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250U3R5bGUpO1xuICAgICAgZm9udFZhcmlhbnRTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250VmFyaWFudCk7XG4gICAgICBmb250V2VpZ2h0U3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFdlaWdodCk7XG4gICAgICBmb250U2l6ZVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRTaXplKTtcbiAgICAgIGZvbnRGYW1pbHlTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250RmFtaWx5KTtcbiAgICAgIGN0eC5mb250ID0gZm9udC50b1N0cmluZygpO1xuXG4gICAgICBpZiAoZm9udFNpemVTdHlsZVByb3AuaXNQaXhlbHMoKSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50LmVtU2l6ZSA9IGZvbnRTaXplU3R5bGVQcm9wLmdldFBpeGVscygpO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZnJvbU1lYXN1cmUpIHtcbiAgICAgIC8vIGVmZmVjdHNcbiAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7IC8vIG9wYWNpdHlcblxuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jYWxjdWxhdGVPcGFjaXR5KCk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJDb250ZXh0KGN0eCkge1xuICAgIHN1cGVyLmNsZWFyQ29udGV4dChjdHgpO1xuXG4gICAgaWYgKHRoaXMubW9kaWZpZWRFbVNpemVTdGFjaykge1xuICAgICAgdGhpcy5kb2N1bWVudC5wb3BFbVNpemUoKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBQYXRoRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdwYXRoJztcbiAgICB0aGlzLnBhdGhQYXJzZXIgPSBudWxsO1xuICAgIHRoaXMucGF0aFBhcnNlciA9IG5ldyBQYXRoUGFyc2VyKHRoaXMuZ2V0QXR0cmlidXRlKCdkJykuZ2V0U3RyaW5nKCkpO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgIHBhdGhQYXJzZXIucmVzZXQoKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoIXBhdGhQYXJzZXIuaXNFbmQoKSkge1xuICAgICAgc3dpdGNoIChwYXRoUGFyc2VyLm5leHQoKS50eXBlKSB7XG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aE0oY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoTChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuSE9SSVpfTElORV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhIKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5WRVJUX0xJTkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoVihjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoQyhjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX0NVUlZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aFMoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgdGhpcy5wYXRoUShjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX1FVQURfVE86XG4gICAgICAgICAgdGhpcy5wYXRoVChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgIHRoaXMucGF0aEEoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgdGhpcy5wYXRoWihjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxuICBnZXRCb3VuZGluZ0JveChfKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aCgpO1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBwb2ludHMgPSBwYXRoUGFyc2VyLmdldE1hcmtlclBvaW50cygpO1xuICAgIHZhciBhbmdsZXMgPSBwYXRoUGFyc2VyLmdldE1hcmtlckFuZ2xlcygpO1xuICAgIHZhciBtYXJrZXJzID0gcG9pbnRzLm1hcCgocG9pbnQsIGkpID0+IFtwb2ludCwgYW5nbGVzW2ldXSk7XG4gICAgcmV0dXJuIG1hcmtlcnM7XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICB0aGlzLnBhdGgoY3R4KTtcbiAgICB0aGlzLmRvY3VtZW50LnNjcmVlbi5tb3VzZS5jaGVja1BhdGgodGhpcywgY3R4KTtcbiAgICB2YXIgZmlsbFJ1bGVTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsLXJ1bGUnKTtcblxuICAgIGlmIChjdHguZmlsbFN0eWxlICE9PSAnJykge1xuICAgICAgaWYgKGZpbGxSdWxlU3R5bGVQcm9wLmdldFN0cmluZygnaW5oZXJpdCcpICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgY3R4LmZpbGwoZmlsbFJ1bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSAnJykge1xuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCd2ZWN0b3ItZWZmZWN0JykuZ2V0U3RyaW5nKCkgPT09ICdub24tc2NhbGluZy1zdHJva2UnKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xuXG4gICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgIHZhciBtYXJrZXJzTGFzdEluZGV4ID0gbWFya2Vycy5sZW5ndGggLSAxO1xuICAgICAgdmFyIG1hcmtlclN0YXJ0U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLXN0YXJ0Jyk7XG4gICAgICB2YXIgbWFya2VyTWlkU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLW1pZCcpO1xuICAgICAgdmFyIG1hcmtlckVuZFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ21hcmtlci1lbmQnKTtcblxuICAgICAgaWYgKG1hcmtlclN0YXJ0U3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJTdGFydFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIHZhciBbcG9pbnQsIGFuZ2xlXSA9IG1hcmtlcnNbMF07XG4gICAgICAgIG1hcmtlci5yZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFya2VyTWlkU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgIHZhciBfbWFya2VyID0gbWFya2VyTWlkU3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG1hcmtlcnNMYXN0SW5kZXg7IGkrKykge1xuICAgICAgICAgIHZhciBbX3BvaW50LCBfYW5nbGVdID0gbWFya2Vyc1tpXTtcblxuICAgICAgICAgIF9tYXJrZXIucmVuZGVyKGN0eCwgX3BvaW50LCBfYW5nbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrZXJFbmRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgdmFyIF9tYXJrZXIyID0gbWFya2VyRW5kU3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICB2YXIgW19wb2ludDIsIF9hbmdsZTJdID0gbWFya2Vyc1ttYXJrZXJzTGFzdEluZGV4XTtcblxuICAgICAgICBfbWFya2VyMi5yZW5kZXIoY3R4LCBfcG9pbnQyLCBfYW5nbGUyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aE0ocGF0aFBhcnNlcikge1xuICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICBwYXRoUGFyc2VyLnN0YXJ0ID0gcGF0aFBhcnNlci5jdXJyZW50O1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoTShjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgcG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aE0ocGF0aFBhcnNlcik7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHBvaW50O1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhMKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhMKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEwocGF0aFBhcnNlcik7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHBvaW50O1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhIKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1hbmRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoKGNvbW1hbmQucmVsYXRpdmUgPyBjdXJyZW50LnggOiAwKSArIGNvbW1hbmQueCwgY3VycmVudC55KTtcbiAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwb2ludDtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhIKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEgocGF0aFBhcnNlcik7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHBvaW50O1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhWKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1hbmRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoY3VycmVudC54LCAoY29tbWFuZC5yZWxhdGl2ZSA/IGN1cnJlbnQueSA6IDApICsgY29tbWFuZC55KTtcbiAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwb2ludDtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhWKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFYocGF0aFBhcnNlcik7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHBvaW50O1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhDKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0UG9pbnQoJ3gxJywgJ3kxJyk7XG4gICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gyJywgJ3kyJyk7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhDKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEMocGF0aFBhcnNlcik7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIHBvaW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRCZXppZXJDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgcG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoUyhwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xuICAgIHZhciBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ29udHJvbFBvaW50KCd4MicsICd5MicpO1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoUyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhTKHBhdGhQYXJzZXIpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgYm91bmRpbmdCb3guYWRkQmV6aWVyQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aFEocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gxJywgJ3kxJyk7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoUShjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoUShwYXRoUGFyc2VyKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgY29udHJvbFBvaW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoVChwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKTtcbiAgICBwYXRoUGFyc2VyLmNvbnRyb2wgPSBjb250cm9sUG9pbnQ7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH07XG4gIH1cblxuICBwYXRoVChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoVChwYXRoUGFyc2VyKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgY29udHJvbFBvaW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoQShwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb21tYW5kXG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHtcbiAgICAgIHJYLFxuICAgICAgclksXG4gICAgICB4Um90LFxuICAgICAgbEFyY0ZsYWcsXG4gICAgICBzd2VlcEZsYWdcbiAgICB9ID0gY29tbWFuZDtcbiAgICB2YXIgeEF4aXNSb3RhdGlvbiA9IHhSb3QgKiAoTWF0aC5QSSAvIDE4MC4wKTtcbiAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpOyAvLyBDb252ZXJzaW9uIGZyb20gZW5kcG9pbnQgdG8gY2VudGVyIHBhcmFtZXRlcml6YXRpb25cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICAvLyB4MScsIHkxJ1xuXG4gICAgdmFyIGN1cnJwID0gbmV3IFBvaW50KE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueCAtIGN1cnJlbnRQb2ludC54KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueSAtIGN1cnJlbnRQb2ludC55KSAvIDIuMCwgLU1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueCAtIGN1cnJlbnRQb2ludC54KSAvIDIuMCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueSAtIGN1cnJlbnRQb2ludC55KSAvIDIuMCk7IC8vIGFkanVzdCByYWRpaVxuXG4gICAgdmFyIGwgPSBNYXRoLnBvdyhjdXJycC54LCAyKSAvIE1hdGgucG93KHJYLCAyKSArIE1hdGgucG93KGN1cnJwLnksIDIpIC8gTWF0aC5wb3coclksIDIpO1xuXG4gICAgaWYgKGwgPiAxKSB7XG4gICAgICByWCAqPSBNYXRoLnNxcnQobCk7XG4gICAgICByWSAqPSBNYXRoLnNxcnQobCk7XG4gICAgfSAvLyBjeCcsIGN5J1xuXG5cbiAgICB2YXIgcyA9IChsQXJjRmxhZyA9PT0gc3dlZXBGbGFnID8gLTEgOiAxKSAqIE1hdGguc3FydCgoTWF0aC5wb3coclgsIDIpICogTWF0aC5wb3coclksIDIpIC0gTWF0aC5wb3coclgsIDIpICogTWF0aC5wb3coY3VycnAueSwgMikgLSBNYXRoLnBvdyhyWSwgMikgKiBNYXRoLnBvdyhjdXJycC54LCAyKSkgLyAoTWF0aC5wb3coclgsIDIpICogTWF0aC5wb3coY3VycnAueSwgMikgKyBNYXRoLnBvdyhyWSwgMikgKiBNYXRoLnBvdyhjdXJycC54LCAyKSkpO1xuXG4gICAgaWYgKGlzTmFOKHMpKSB7XG4gICAgICBzID0gMDtcbiAgICB9XG5cbiAgICB2YXIgY3BwID0gbmV3IFBvaW50KHMgKiByWCAqIGN1cnJwLnkgLyByWSwgcyAqIC1yWSAqIGN1cnJwLnggLyByWCk7IC8vIGN4LCBjeVxuXG4gICAgdmFyIGNlbnRwID0gbmV3IFBvaW50KChjdXJyZW50LnggKyBjdXJyZW50UG9pbnQueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC54IC0gTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiBjcHAueSwgKGN1cnJlbnQueSArIGN1cnJlbnRQb2ludC55KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnggKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC55KTsgLy8gaW5pdGlhbCBhbmdsZVxuXG4gICAgdmFyIGExID0gdmVjdG9yc0FuZ2xlKFsxLCAwXSwgWyhjdXJycC54IC0gY3BwLngpIC8gclgsIChjdXJycC55IC0gY3BwLnkpIC8gclldKTsgLy8gzrgxXG4gICAgLy8gYW5nbGUgZGVsdGFcblxuICAgIHZhciB1ID0gWyhjdXJycC54IC0gY3BwLngpIC8gclgsIChjdXJycC55IC0gY3BwLnkpIC8gclldO1xuICAgIHZhciB2ID0gWygtY3VycnAueCAtIGNwcC54KSAvIHJYLCAoLWN1cnJwLnkgLSBjcHAueSkgLyByWV07XG4gICAgdmFyIGFkID0gdmVjdG9yc0FuZ2xlKHUsIHYpOyAvLyDOlM64XG5cbiAgICBpZiAodmVjdG9yc1JhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICBhZCA9IE1hdGguUEk7XG4gICAgfVxuXG4gICAgaWYgKHZlY3RvcnNSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICBhZCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRQb2ludCxcbiAgICAgIHJYLFxuICAgICAgclksXG4gICAgICBzd2VlcEZsYWcsXG4gICAgICB4QXhpc1JvdGF0aW9uLFxuICAgICAgY2VudHAsXG4gICAgICBhMSxcbiAgICAgIGFkXG4gICAgfTtcbiAgfVxuXG4gIHBhdGhBKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50UG9pbnQsXG4gICAgICByWCxcbiAgICAgIHJZLFxuICAgICAgc3dlZXBGbGFnLFxuICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgIGNlbnRwLFxuICAgICAgYTEsXG4gICAgICBhZFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoQShwYXRoUGFyc2VyKTsgLy8gZm9yIG1hcmtlcnNcblxuICAgIHZhciBkaXIgPSAxIC0gc3dlZXBGbGFnID8gMS4wIDogLTEuMDtcbiAgICB2YXIgYWggPSBhMSArIGRpciAqIChhZCAvIDIuMCk7XG4gICAgdmFyIGhhbGZXYXkgPSBuZXcgUG9pbnQoY2VudHAueCArIHJYICogTWF0aC5jb3MoYWgpLCBjZW50cC55ICsgclkgKiBNYXRoLnNpbihhaCkpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyQW5nbGUoaGFsZldheSwgYWggLSBkaXIgKiBNYXRoLlBJIC8gMik7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXJBbmdsZShjdXJyZW50UG9pbnQsIGFoIC0gZGlyICogTWF0aC5QSSk7XG4gICAgYm91bmRpbmdCb3guYWRkUG9pbnQoY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTsgLy8gVE9ETzogdGhpcyBpcyB0b28gbmFpdmUsIG1ha2UgaXQgYmV0dGVyXG5cbiAgICBpZiAoY3R4ICYmICFpc05hTihhMSkgJiYgIWlzTmFOKGFkKSkge1xuICAgICAgdmFyIHIgPSByWCA+IHJZID8gclggOiByWTtcbiAgICAgIHZhciBzeCA9IHJYID4gclkgPyAxIDogclggLyByWTtcbiAgICAgIHZhciBzeSA9IHJYID4gclkgPyByWSAvIHJYIDogMTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY2VudHAueCwgY2VudHAueSk7XG4gICAgICBjdHgucm90YXRlKHhBeGlzUm90YXRpb24pO1xuICAgICAgY3R4LnNjYWxlKHN4LCBzeSk7XG4gICAgICBjdHguYXJjKDAsIDAsIHIsIGExLCBhMSArIGFkLCBCb29sZWFuKDEgLSBzd2VlcEZsYWcpKTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gc3gsIDEgLyBzeSk7XG4gICAgICBjdHgucm90YXRlKC14QXhpc1JvdGF0aW9uKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoLWNlbnRwLngsIC1jZW50cC55KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aFoocGF0aFBhcnNlcikge1xuICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBhdGhQYXJzZXIuc3RhcnQ7XG4gIH1cblxuICBwYXRoWihjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgUGF0aEVsZW1lbnQucGF0aFoodGhpcy5wYXRoUGFyc2VyKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIC8vIG9ubHkgY2xvc2UgcGF0aCBpZiBpdCBpcyBub3QgYSBzdHJhaWdodCBsaW5lXG4gICAgICBpZiAoYm91bmRpbmdCb3gueDEgIT09IGJvdW5kaW5nQm94LngyICYmIGJvdW5kaW5nQm94LnkxICE9PSBib3VuZGluZ0JveC55Mikge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgR2x5cGhFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZ2x5cGgnO1xuICAgIHRoaXMuaG9yaXpBZHZYID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hvcml6LWFkdi14JykuZ2V0TnVtYmVyKCk7XG4gICAgdGhpcy51bmljb2RlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3VuaWNvZGUnKS5nZXRTdHJpbmcoKTtcbiAgICB0aGlzLmFyYWJpY0Zvcm0gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXJhYmljLWZvcm0nKS5nZXRTdHJpbmcoKTtcbiAgfVxuXG59XG5cbmNsYXNzIFRleHRFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgbmV3LnRhcmdldCA9PT0gVGV4dEVsZW1lbnQgPyB0cnVlIDogY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3RleHQnO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLm1lYXN1cmVDYWNoZSA9IC0xO1xuICB9XG5cbiAgc2V0Q29udGV4dChjdHgpIHtcbiAgICB2YXIgZnJvbU1lYXN1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHN1cGVyLnNldENvbnRleHQoY3R4LCBmcm9tTWVhc3VyZSk7XG4gICAgdmFyIHRleHRCYXNlbGluZSA9IHRoaXMuZ2V0U3R5bGUoJ2RvbWluYW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCkgfHwgdGhpcy5nZXRTdHlsZSgnYWxpZ25tZW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCk7XG5cbiAgICBpZiAodGV4dEJhc2VsaW5lKSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxpemVDb29yZGluYXRlcygpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5sZWFmVGV4dHMgPSBbXTtcbiAgICB0aGlzLnRleHRDaHVua1N0YXJ0ID0gMDtcbiAgICB0aGlzLm1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5tYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRURWxlbWVudEJvdW5kaW5nQm94KGN0eCk7XG4gICAgfSAvLyBmaXJzdCwgY2FsY3VsYXRlIGNoaWxkIHBvc2l0aW9uc1xuXG5cbiAgICB0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpO1xuICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpO1xuICAgIHZhciBib3VuZGluZ0JveCA9IG51bGw7IC8vIHRoZW4gY2FsY3VsYXRlIGJvdW5kaW5nIGJveFxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGluZ0JveCA9IHRoaXMuZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIHRoaXMsIHRoaXMsIGkpO1xuXG4gICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgIGJvdW5kaW5nQm94ID0gY2hpbGRCb3VuZGluZ0JveDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkQm91bmRpbmdCb3gpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG4gIGdldEZvbnRTaXplKCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBpbmhlcml0Rm9udFNpemUgPSBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KS5mb250U2l6ZTtcbiAgICB2YXIgZm9udFNpemUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpLmdldE51bWJlcihpbmhlcml0Rm9udFNpemUpO1xuICAgIHJldHVybiBmb250U2l6ZTtcbiAgfVxuXG4gIGdldFRFbGVtZW50Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnkgLSBmb250U2l6ZSwgdGhpcy54ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB0aGlzLnkpO1xuICB9XG5cbiAgZ2V0R2x5cGgoZm9udCwgdGV4dCwgaSkge1xuICAgIHZhciBjaGFyID0gdGV4dFtpXTtcbiAgICB2YXIgZ2x5cGggPSBudWxsO1xuXG4gICAgaWYgKGZvbnQuaXNBcmFiaWMpIHtcbiAgICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIHZhciBwcmV2Q2hhciA9IHRleHRbaSAtIDFdO1xuICAgICAgdmFyIG5leHRDaGFyID0gdGV4dFtpICsgMV07XG4gICAgICB2YXIgYXJhYmljRm9ybSA9ICdpc29sYXRlZCc7XG5cbiAgICAgIGlmICgoaSA9PT0gMCB8fCBwcmV2Q2hhciA9PT0gJyAnKSAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgIGFyYWJpY0Zvcm0gPSAndGVybWluYWwnO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+IDAgJiYgcHJldkNoYXIgIT09ICcgJyAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgIGFyYWJpY0Zvcm0gPSAnbWVkaWFsJztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwICYmIHByZXZDaGFyICE9PSAnICcgJiYgKGkgPT09IGxlbiAtIDEgfHwgbmV4dENoYXIgPT09ICcgJykpIHtcbiAgICAgICAgYXJhYmljRm9ybSA9ICdpbml0aWFsJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmb250LmdseXBoc1tjaGFyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTkVFRCBURVNUXG4gICAgICAgIHZhciBtYXliZUdseXBoID0gZm9udC5nbHlwaHNbY2hhcl07XG4gICAgICAgIGdseXBoID0gbWF5YmVHbHlwaCBpbnN0YW5jZW9mIEdseXBoRWxlbWVudCA/IG1heWJlR2x5cGggOiBtYXliZUdseXBoW2FyYWJpY0Zvcm1dO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NoYXJdO1xuICAgIH1cblxuICAgIGlmICghZ2x5cGgpIHtcbiAgICAgIGdseXBoID0gZm9udC5taXNzaW5nR2x5cGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBnZXRUZXh0RnJvbU5vZGUobm9kZSkge1xuICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUgfHwgdGhpcy5ub2RlO1xuICAgIHZhciBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbSh0ZXh0Tm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMpO1xuICAgIHZhciBpbmRleCA9IGNoaWxkTm9kZXMuaW5kZXhPZih0ZXh0Tm9kZSk7XG4gICAgdmFyIGxhc3RJbmRleCA9IGNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgdGV4dCA9IGNvbXByZXNzU3BhY2VzKCAvLyB0ZXh0Tm9kZS52YWx1ZVxuICAgIC8vIHx8IHRleHROb2RlLnRleHRcbiAgICB0ZXh0Tm9kZS50ZXh0Q29udGVudCB8fCAnJyk7XG5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHRleHQgPSB0cmltTGVmdCh0ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xuICAgICAgdGV4dCA9IHRyaW1SaWdodCh0ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgdGhpcy5yZW5kZXJURWxlbWVudENoaWxkcmVuKGN0eCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBmaXJzdCwgY2FsY3VsYXRlIGNoaWxkIHBvc2l0aW9uc1xuXG5cbiAgICB0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpO1xuICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpOyAvLyB0aGVuIHJlbmRlclxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICB0aGlzLnJlbmRlckNoaWxkKGN0eCwgdGhpcywgdGhpcywgaSk7XG4gICAgfSk7XG4gICAgdmFyIHtcbiAgICAgIG1vdXNlXG4gICAgfSA9IHRoaXMuZG9jdW1lbnQuc2NyZWVuOyAvLyBEbyBub3QgY2FsYyBib3VuZGluZyBib3ggaWYgbW91c2UgaXMgbm90IHdvcmtpbmcuXG5cbiAgICBpZiAobW91c2UuaXNXb3JraW5nKCkpIHtcbiAgICAgIG1vdXNlLmNoZWNrQm91bmRpbmdCb3godGhpcywgdGhpcy5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXJURWxlbWVudENoaWxkcmVuKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciByZW5kZXJUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGN1c3RvbUZvbnQgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKGN1c3RvbUZvbnQpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHVuaXRzUGVyRW1cbiAgICAgIH0gPSBjdXN0b21Gb250LmZvbnRGYWNlO1xuICAgICAgdmFyIGN0eEZvbnQgPSBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KTtcbiAgICAgIHZhciBmb250U2l6ZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zaXplJykuZ2V0TnVtYmVyKGN0eEZvbnQuZm9udFNpemUpO1xuICAgICAgdmFyIGZvbnRTdHlsZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zdHlsZScpLmdldFN0cmluZyhjdHhGb250LmZvbnRTdHlsZSk7XG4gICAgICB2YXIgc2NhbGUgPSBmb250U2l6ZSAvIHVuaXRzUGVyRW07XG4gICAgICB2YXIgdGV4dCA9IGN1c3RvbUZvbnQuaXNSVEwgPyByZW5kZXJUZXh0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiByZW5kZXJUZXh0O1xuICAgICAgdmFyIGR4ID0gdG9OdW1iZXJzKHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoY3VzdG9tRm9udCwgdGV4dCwgaSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICBjdHguc2NhbGUoc2NhbGUsIC1zY2FsZSk7XG4gICAgICAgIHZhciBsdyA9IGN0eC5saW5lV2lkdGg7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBjdHgubGluZVdpZHRoICogdW5pdHNQZXJFbSAvIGZvbnRTaXplO1xuXG4gICAgICAgIGlmIChmb250U3R5bGUgPT09ICdpdGFsaWMnKSB7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAuNCwgMSwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaC5yZW5kZXIoY3R4KTtcblxuICAgICAgICBpZiAoZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgLS40LCAxLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsdztcbiAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZSwgLTEgLyBzY2FsZSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXRoaXMueCwgLXRoaXMueSk7XG4gICAgICAgIHRoaXMueCArPSBmb250U2l6ZSAqIChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpIC8gdW5pdHNQZXJFbTtcblxuICAgICAgICBpZiAodHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XG4gICAgICAgICAgdGhpcy54ICs9IGR4W2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpczsgLy8gTkVFRCBURVNUXG4gICAgLy8gaWYgKGN0eC5wYWludE9yZGVyID09PSAnc3Ryb2tlJykge1xuICAgIC8vIFx0aWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgIC8vIFx0XHRjdHguc3Ryb2tlVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAvLyBcdH1cbiAgICAvLyBcdGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgLy8gXHRcdGN0eC5maWxsVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAvLyBcdH1cbiAgICAvLyB9IGVsc2Uge1xuXG4gICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgIGN0eC5maWxsVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgICBjdHguc3Ryb2tlVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICB9IC8vIH1cblxuICB9XG5cbiAgYXBwbHlBbmNob3JpbmcoKSB7XG4gICAgaWYgKHRoaXMudGV4dENodW5rU3RhcnQgPj0gdGhpcy5sZWFmVGV4dHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGlzIGlzIGJhc2ljYWxseSB0aGUgXCJBcHBseSBhbmNob3JpbmdcIiBwYXJ0IG9mIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcyL3RleHQuaHRtbCNUZXh0TGF5b3V0QWxnb3JpdGhtLlxuICAgIC8vIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgd2UgYXBwbHkgdGhlIGFuY2hvcmluZyBhcyBzb29uIGFzIGEgY2h1bmsgaXMgZmluaXNoZWQuIFRoaXMgc2F2ZXMgc29tZSBleHRyYSBsb29waW5nLlxuICAgIC8vIFZlcnRpY2FsIHRleHQgaXMgbm90IHN1cHBvcnRlZC5cblxuXG4gICAgdmFyIGZpcnN0RWxlbWVudCA9IHRoaXMubGVhZlRleHRzW3RoaXMudGV4dENodW5rU3RhcnRdO1xuICAgIHZhciB0ZXh0QW5jaG9yID0gZmlyc3RFbGVtZW50LmdldFN0eWxlKCd0ZXh0LWFuY2hvcicpLmdldFN0cmluZygnc3RhcnQnKTtcbiAgICB2YXIgaXNSVEwgPSBmYWxzZTsgLy8gd2UgdHJlYXQgUlRMIGxpa2UgTFRSXG5cbiAgICB2YXIgc2hpZnQgPSAwO1xuXG4gICAgaWYgKHRleHRBbmNob3IgPT09ICdzdGFydCcgJiYgIWlzUlRMIHx8IHRleHRBbmNob3IgPT09ICdlbmQnICYmIGlzUlRMKSB7XG4gICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5taW5YO1xuICAgIH0gZWxzZSBpZiAodGV4dEFuY2hvciA9PT0gJ2VuZCcgJiYgIWlzUlRMIHx8IHRleHRBbmNob3IgPT09ICdzdGFydCcgJiYgaXNSVEwpIHtcbiAgICAgIHNoaWZ0ID0gZmlyc3RFbGVtZW50LnggLSB0aGlzLm1heFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoaWZ0ID0gZmlyc3RFbGVtZW50LnggLSAodGhpcy5taW5YICsgdGhpcy5tYXhYKSAvIDI7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMudGV4dENodW5rU3RhcnQ7IGkgPCB0aGlzLmxlYWZUZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5sZWFmVGV4dHNbaV0ueCArPSBzaGlmdDtcbiAgICB9IC8vIHN0YXJ0IG5ldyBjaHVua1xuXG5cbiAgICB0aGlzLm1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5tYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIHRoaXMudGV4dENodW5rU3RhcnQgPSB0aGlzLmxlYWZUZXh0cy5sZW5ndGg7XG4gIH1cblxuICBhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlKGN0eCkge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRoaXMsIHRoaXMsIGkpO1xuICAgIH0pO1xuICAgIHRoaXMuYXBwbHlBbmNob3JpbmcoKTtcbiAgfVxuXG4gIGFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgICAgdGV4dFBhcmVudC5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvbmx5IGxlYWZzIGFyZSByZWxldmFudFxuICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKTtcbiAgICB9XG4gIH1cblxuICBhZGp1c3RDaGlsZENvb3JkaW5hdGVzKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZC5tZWFzdXJlVGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY2hpbGQuc2V0Q29udGV4dChjdHgsIHRydWUpO1xuICAgIHZhciB4QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgIHZhciB5QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgneScpO1xuICAgIHZhciBkeEF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2R4Jyk7XG4gICAgdmFyIGR5QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnZHknKTtcbiAgICB2YXIgY3VzdG9tRm9udCA9IGNoaWxkLmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcbiAgICB2YXIgaXNSVEwgPSBCb29sZWFuKGN1c3RvbUZvbnQpICYmIGN1c3RvbUZvbnQuaXNSVEw7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgLy8gRmlyc3QgY2hpbGRyZW4gaW5oZXJpdCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50KHMpLiBQb3NpdGlvbmFsIGF0dHJpYnV0ZXNcbiAgICAgIC8vIGFyZSBvbmx5IGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IHRvIGl0J3MgZmlyc3QgY2hpbGQuXG4gICAgICBpZiAoIXhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgeEF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd4JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgeUF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd5JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGR4QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R4JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGR5QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R5JykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGNoaWxkLm1lYXN1cmVUZXh0KGN0eCk7XG5cbiAgICBpZiAoaXNSVEwpIHtcbiAgICAgIHRleHRQYXJlbnQueCAtPSB3aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgLy8gYW4gXCJ4XCIgYXR0cmlidXRlIG1hcmtzIHRoZSBzdGFydCBvZiBhIG5ldyBjaHVua1xuICAgICAgdGV4dFBhcmVudC5hcHBseUFuY2hvcmluZygpO1xuICAgICAgY2hpbGQueCA9IHhBdHRyLmdldFBpeGVscygneCcpO1xuXG4gICAgICBpZiAoZHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY2hpbGQueCArPSBkeEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICB0ZXh0UGFyZW50LnggKz0gZHhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZC54ID0gdGV4dFBhcmVudC54O1xuICAgIH1cblxuICAgIHRleHRQYXJlbnQueCA9IGNoaWxkLng7XG5cbiAgICBpZiAoIWlzUlRMKSB7XG4gICAgICB0ZXh0UGFyZW50LnggKz0gd2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGNoaWxkLnkgPSB5QXR0ci5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgaWYgKGR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNoaWxkLnkgKz0gZHlBdHRyLmdldFBpeGVscygneScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGV4dFBhcmVudC55ICs9IGR5QXR0ci5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQueSA9IHRleHRQYXJlbnQueTtcbiAgICB9XG5cbiAgICB0ZXh0UGFyZW50LnkgPSBjaGlsZC55OyAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgY2h1bmsgYW5kIGl0J3MgYm91bmRzXG5cbiAgICB0ZXh0UGFyZW50LmxlYWZUZXh0cy5wdXNoKGNoaWxkKTtcbiAgICB0ZXh0UGFyZW50Lm1pblggPSBNYXRoLm1pbih0ZXh0UGFyZW50Lm1pblgsIGNoaWxkLngsIGNoaWxkLnggKyB3aWR0aCk7XG4gICAgdGV4dFBhcmVudC5tYXhYID0gTWF0aC5tYXgodGV4dFBhcmVudC5tYXhYLCBjaGlsZC54LCBjaGlsZC54ICsgd2lkdGgpO1xuICAgIGNoaWxkLmNsZWFyQ29udGV4dChjdHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTsgLy8gbm90IGEgdGV4dCBub2RlP1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZC5nZXRCb3VuZGluZ0JveCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kaW5nQm94ID0gY2hpbGQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcblxuICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgIHZhciBjaGlsZEJvdW5kaW5nQm94ID0gdGV4dFBhcmVudC5nZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGRCb3VuZGluZ0JveCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICB9XG5cbiAgcmVuZGVyQ2hpbGQoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgdGV4dFBhcmVudC5yZW5kZXJDaGlsZChjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1lYXN1cmVUZXh0KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBtZWFzdXJlQ2FjaGVcbiAgICB9ID0gdGhpcztcblxuICAgIGlmICh+bWVhc3VyZUNhY2hlKSB7XG4gICAgICByZXR1cm4gbWVhc3VyZUNhY2hlO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIG1lYXN1cmUgPSB0aGlzLm1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgcmVuZGVyVGV4dCk7XG4gICAgdGhpcy5tZWFzdXJlQ2FjaGUgPSBtZWFzdXJlO1xuICAgIHJldHVybiBtZWFzdXJlO1xuICB9XG5cbiAgbWVhc3VyZVRhcmdldFRleHQoY3R4LCB0YXJnZXRUZXh0KSB7XG4gICAgaWYgKCF0YXJnZXRUZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBjdXN0b21Gb250ID0gcGFyZW50LmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcblxuICAgIGlmIChjdXN0b21Gb250KSB7XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICB2YXIgdGV4dCA9IGN1c3RvbUZvbnQuaXNSVEwgPyB0YXJnZXRUZXh0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiB0YXJnZXRUZXh0O1xuICAgICAgdmFyIGR4ID0gdG9OdW1iZXJzKHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgdmFyIF9tZWFzdXJlID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xuICAgICAgICBfbWVhc3VyZSArPSAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAqIGZvbnRTaXplIC8gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICBfbWVhc3VyZSArPSBkeFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX21lYXN1cmU7XG4gICAgfVxuXG4gICAgaWYgKCFjdHgubWVhc3VyZVRleHQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRUZXh0Lmxlbmd0aCAqIDEwO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgdGhpcy5zZXRDb250ZXh0KGN0eCwgdHJ1ZSk7XG4gICAgdmFyIHtcbiAgICAgIHdpZHRoOiBtZWFzdXJlXG4gICAgfSA9IGN0eC5tZWFzdXJlVGV4dCh0YXJnZXRUZXh0KTtcbiAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIG1lYXN1cmU7XG4gIH1cbiAgLyoqXHJcbiAgICogSW5oZXJpdHMgcG9zaXRpb25hbCBhdHRyaWJ1dGVzIGZyb20ge0BsaW5rIFRleHRFbGVtZW50fSBwYXJlbnQocykuIEF0dHJpYnV0ZXNcclxuICAgKiBhcmUgb25seSBpbmhlcml0ZWQgZnJvbSBhIHBhcmVudCB0byBpdHMgZmlyc3QgY2hpbGQuXHJcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgYXR0cmlidXRlIG5hbWUuXHJcbiAgICogQHJldHVybnMgVGhlIGF0dHJpYnV0ZSB2YWx1ZSBvciBudWxsLlxyXG4gICAqL1xuXG5cbiAgZ2V0SW5oZXJpdGVkQXR0cmlidXRlKG5hbWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsY29uc2lzdGVudC10aGlzXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQgaW5zdGFuY2VvZiBUZXh0RWxlbWVudCAmJiBjdXJyZW50LmlzRmlyc3RDaGlsZCgpKSB7XG4gICAgICB2YXIgcGFyZW50QXR0ciA9IGN1cnJlbnQucGFyZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgICAgaWYgKHBhcmVudEF0dHIuaGFzVmFsdWUodHJ1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudEF0dHIuZ2V0VmFsdWUoJzAnKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbn1cblxuY2xhc3MgVFNwYW5FbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBuZXcudGFyZ2V0ID09PSBUU3BhbkVsZW1lbnQgPyB0cnVlIDogY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3RzcGFuJzsgLy8gaWYgdGhpcyBub2RlIGhhcyBjaGlsZHJlbiwgdGhlbiB0aGV5IG93biB0aGUgdGV4dFxuXG4gICAgdGhpcy50ZXh0ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwID8gJycgOiB0aGlzLmdldFRleHRGcm9tTm9kZSgpO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG5cbn1cblxuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBUU3BhbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICd0ZXh0Tm9kZSc7XG4gIH1cblxufVxuXG5jbGFzcyBTVkdFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnc3ZnJztcbiAgICB0aGlzLnJvb3QgPSBmYWxzZTtcbiAgfVxuXG4gIHNldENvbnRleHQoY3R4KSB7XG4gICAgdmFyIF90aGlzJG5vZGUkcGFyZW50Tm9kZTtcblxuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBzY3JlZW4sXG4gICAgICB3aW5kb3dcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgdmFyIGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgc2NyZWVuLnNldERlZmF1bHRzKGN0eCk7XG5cbiAgICBpZiAoY2FudmFzLnN0eWxlICYmIHR5cGVvZiBjdHguZm9udCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGN0eC5mb250ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2FudmFzKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250Jyk7XG4gICAgICB2YXIgZm9udFNpemVQcm9wID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZm9udFNpemUnLCBGb250LnBhcnNlKGN0eC5mb250KS5mb250U2l6ZSk7XG5cbiAgICAgIGlmIChmb250U2l6ZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICBkb2N1bWVudC5yb290RW1TaXplID0gZm9udFNpemVQcm9wLmdldFBpeGVscygneScpO1xuICAgICAgICBkb2N1bWVudC5lbVNpemUgPSBkb2N1bWVudC5yb290RW1TaXplO1xuICAgICAgfVxuICAgIH0gLy8gY3JlYXRlIG5ldyB2aWV3IHBvcnRcblxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd4JywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5JywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHNjcmVlbi52aWV3UG9ydDtcblxuICAgIGlmICghdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldFN0eWxlKCd3aWR0aCcsIHRydWUpLnNldFZhbHVlKCcxMDAlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCB0cnVlKS5zZXRWYWx1ZSgnMTAwJScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRTdHlsZSgnY29sb3InKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldFN0eWxlKCdjb2xvcicsIHRydWUpLnNldFZhbHVlKCdibGFjaycpO1xuICAgIH1cblxuICAgIHZhciByZWZYQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZYJyk7XG4gICAgdmFyIHJlZllBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlknKTtcbiAgICB2YXIgdmlld0JveEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgIHZhciB2aWV3Qm94ID0gdmlld0JveEF0dHIuaGFzVmFsdWUoKSA/IHRvTnVtYmVycyh2aWV3Qm94QXR0ci5nZXRTdHJpbmcoKSkgOiBudWxsO1xuICAgIHZhciBjbGlwID0gIXRoaXMucm9vdCAmJiB0aGlzLmdldFN0eWxlKCdvdmVyZmxvdycpLmdldFZhbHVlKCdoaWRkZW4nKSAhPT0gJ3Zpc2libGUnO1xuICAgIHZhciBtaW5YID0gMDtcbiAgICB2YXIgbWluWSA9IDA7XG4gICAgdmFyIGNsaXBYID0gMDtcbiAgICB2YXIgY2xpcFkgPSAwO1xuXG4gICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgIG1pblggPSB2aWV3Qm94WzBdO1xuICAgICAgbWluWSA9IHZpZXdCb3hbMV07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbWFya2VyJykge1xuICAgICAgICBjbGlwWCA9IG1pblg7XG4gICAgICAgIGNsaXBZID0gbWluWTtcbiAgICAgICAgbWluWCA9IDA7XG4gICAgICAgIG1pblkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNjcmVlbi52aWV3UG9ydC5zZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpOyAvLyBEZWZhdWx0IHZhbHVlIG9mIHRyYW5zZm9ybS1vcmlnaW4gaXMgY2VudGVyIG9ubHkgZm9yIHJvb3QgU1ZHIGVsZW1lbnRzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS90cmFuc2Zvcm0tb3JpZ2luXG5cbiAgICBpZiAodGhpcy5ub2RlIC8vIGlzIG5vdCB0ZW1wb3JhcnkgU1ZHRWxlbWVudFxuICAgICYmICghdGhpcy5wYXJlbnQgfHwgKChfdGhpcyRub2RlJHBhcmVudE5vZGUgPSB0aGlzLm5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX3RoaXMkbm9kZSRwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRub2RlJHBhcmVudE5vZGUubm9kZU5hbWUpID09PSAnZm9yZWlnbk9iamVjdCcpICYmIHRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCB0cnVlLCB0cnVlKS5zZXRWYWx1ZSgnNTAlIDUwJScpO1xuICAgIH1cblxuICAgIHN1cGVyLnNldENvbnRleHQoY3R4KTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5JykpO1xuXG4gICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgIHdpZHRoID0gdmlld0JveFsyXTtcbiAgICAgIGhlaWdodCA9IHZpZXdCb3hbM107XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuc2V0Vmlld0JveCh7XG4gICAgICBjdHgsXG4gICAgICBhc3BlY3RSYXRpbzogdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSxcbiAgICAgIHdpZHRoOiBzY3JlZW4udmlld1BvcnQud2lkdGgsXG4gICAgICBkZXNpcmVkV2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBzY3JlZW4udmlld1BvcnQuaGVpZ2h0LFxuICAgICAgZGVzaXJlZEhlaWdodDogaGVpZ2h0LFxuICAgICAgbWluWCxcbiAgICAgIG1pblksXG4gICAgICByZWZYOiByZWZYQXR0ci5nZXRWYWx1ZSgpLFxuICAgICAgcmVmWTogcmVmWUF0dHIuZ2V0VmFsdWUoKSxcbiAgICAgIGNsaXAsXG4gICAgICBjbGlwWCxcbiAgICAgIGNsaXBZXG4gICAgfSk7XG5cbiAgICBpZiAodmlld0JveCkge1xuICAgICAgc2NyZWVuLnZpZXdQb3J0LnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgIHNjcmVlbi52aWV3UG9ydC5zZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyQ29udGV4dChjdHgpIHtcbiAgICBzdXBlci5jbGVhckNvbnRleHQoY3R4KTtcbiAgICB0aGlzLmRvY3VtZW50LnNjcmVlbi52aWV3UG9ydC5yZW1vdmVDdXJyZW50KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzaXplIFNWRyB0byBmaXQgaW4gZ2l2ZW4gc2l6ZS5cclxuICAgKiBAcGFyYW0gd2lkdGhcclxuICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICogQHBhcmFtIHByZXNlcnZlQXNwZWN0UmF0aW9cclxuICAgKi9cblxuXG4gIHJlc2l6ZSh3aWR0aCkge1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHdpZHRoO1xuICAgIHZhciBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB2YXIgd2lkdGhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSk7XG4gICAgdmFyIGhlaWdodEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSk7XG4gICAgdmFyIHZpZXdCb3hBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcbiAgICB2YXIgc3R5bGVBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgdmFyIG9yaWdpbldpZHRoID0gd2lkdGhBdHRyLmdldE51bWJlcigwKTtcbiAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gaGVpZ2h0QXR0ci5nZXROdW1iZXIoMCk7XG5cbiAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgaWYgKHR5cGVvZiBwcmVzZXJ2ZUFzcGVjdFJhdGlvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRydWUpLnNldFZhbHVlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKTtcblxuICAgICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpb0F0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLnNldFZhbHVlKHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLmdldFN0cmluZygpLnJlcGxhY2UoL15cXHMqKFxcUy4qXFxTKVxccyokLywgJyQxJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2lkdGhBdHRyLnNldFZhbHVlKHdpZHRoKTtcbiAgICBoZWlnaHRBdHRyLnNldFZhbHVlKGhlaWdodCk7XG5cbiAgICBpZiAoIXZpZXdCb3hBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZpZXdCb3hBdHRyLnNldFZhbHVlKFwiMCAwIFwiLmNvbmNhdChvcmlnaW5XaWR0aCB8fCB3aWR0aCwgXCIgXCIpLmNvbmNhdChvcmlnaW5IZWlnaHQgfHwgaGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICB2YXIgd2lkdGhTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJyk7XG4gICAgICB2YXIgaGVpZ2h0U3R5bGUgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKTtcblxuICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICB3aWR0aFN0eWxlLnNldFZhbHVlKFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgaGVpZ2h0U3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBSZWN0RWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAncmVjdCc7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCBmYWxzZSwgdHJ1ZSkuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIGZhbHNlLCB0cnVlKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgcnhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J4Jyk7XG4gICAgdmFyIHJ5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeScpO1xuICAgIHZhciByeCA9IHJ4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgcnkgPSByeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICBpZiAocnhBdHRyLmhhc1ZhbHVlKCkgJiYgIXJ5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICByeSA9IHJ4O1xuICAgIH1cblxuICAgIGlmIChyeUF0dHIuaGFzVmFsdWUoKSAmJiAhcnhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJ4ID0gcnk7XG4gICAgfVxuXG4gICAgcnggPSBNYXRoLm1pbihyeCwgd2lkdGggLyAyLjApO1xuICAgIHJ5ID0gTWF0aC5taW4ocnksIGhlaWdodCAvIDIuMCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICB2YXIgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpOyAvLyBhbHdheXMgc3RhcnQgdGhlIHBhdGggc28gd2UgZG9uJ3QgZmlsbCBwcmlvciBwYXRoc1xuXG4gICAgICBpZiAoaGVpZ2h0ID4gMCAmJiB3aWR0aCA+IDApIHtcbiAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcngsIHkpO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJ4LCB5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHdpZHRoIC0gcnggKyBLQVBQQSAqIHJ4LCB5LCB4ICsgd2lkdGgsIHkgKyByeSAtIEtBUFBBICogcnksIHggKyB3aWR0aCwgeSArIHJ5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5ICsgS0FQUEEgKiByeSwgeCArIHdpZHRoIC0gcnggKyBLQVBQQSAqIHJ4LCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByeCwgeSArIGhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHJ4IC0gS0FQUEEgKiByeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJ5ICsgS0FQUEEgKiByeSwgeCwgeSArIGhlaWdodCAtIHJ5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5ICsgcnkgLSBLQVBQQSAqIHJ5LCB4ICsgcnggLSBLQVBQQSAqIHJ4LCB5LCB4ICsgcngsIHkpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG5cbmNsYXNzIENpcmNsZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2NpcmNsZSc7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciBjeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBjeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuICAgIHZhciByID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5nZXRQaXhlbHMoKTtcblxuICAgIGlmIChjdHggJiYgciA+IDApIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMoY3gsIGN5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goY3ggLSByLCBjeSAtIHIsIGN4ICsgciwgY3kgKyByKTtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuXG5jbGFzcyBFbGxpcHNlRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZWxsaXBzZSc7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XG4gICAgdmFyIHJ4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHJ5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIGN4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGN5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICBpZiAoY3R4ICYmIHJ4ID4gMCAmJiByeSA+IDApIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oY3ggKyByeCwgY3kpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggKyByeCwgY3kgKyBLQVBQQSAqIHJ5LCBjeCArIEtBUFBBICogcngsIGN5ICsgcnksIGN4LCBjeSArIHJ5KTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gS0FQUEEgKiByeCwgY3kgKyByeSwgY3ggLSByeCwgY3kgKyBLQVBQQSAqIHJ5LCBjeCAtIHJ4LCBjeSk7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCAtIHJ4LCBjeSAtIEtBUFBBICogcnksIGN4IC0gS0FQUEEgKiByeCwgY3kgLSByeSwgY3gsIGN5IC0gcnkpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggKyBLQVBQQSAqIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSAtIEtBUFBBICogcnksIGN4ICsgcngsIGN5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGN4IC0gcngsIGN5IC0gcnksIGN4ICsgcngsIGN5ICsgcnkpO1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG5cbmNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdsaW5lJztcbiAgfVxuXG4gIGdldFBvaW50cygpIHtcbiAgICByZXR1cm4gW25ldyBQb2ludCh0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXRQaXhlbHMoJ3gnKSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0UGl4ZWxzKCd5JykpLCBuZXcgUG9pbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmdldFBpeGVscygneScpKV07XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciBbe1xuICAgICAgeDogeDAsXG4gICAgICB5OiB5MFxuICAgIH0sIHtcbiAgICAgIHg6IHgxLFxuICAgICAgeTogeTFcbiAgICB9XSA9IHRoaXMuZ2V0UG9pbnRzKCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHgwLCB5MCk7XG4gICAgICBjdHgubGluZVRvKHgxLCB5MSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSk7XG4gIH1cblxuICBnZXRNYXJrZXJzKCkge1xuICAgIHZhciBbcDAsIHAxXSA9IHRoaXMuZ2V0UG9pbnRzKCk7XG4gICAgdmFyIGEgPSBwMC5hbmdsZVRvKHAxKTtcbiAgICByZXR1cm4gW1twMCwgYV0sIFtwMSwgYV1dO1xuICB9XG5cbn1cblxuY2xhc3MgUG9seWxpbmVFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAncG9seWxpbmUnO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5wb2ludHMgPSBQb2ludC5wYXJzZVBhdGgodGhpcy5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLmdldFN0cmluZygpKTtcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50c1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBbe1xuICAgICAgeDogeDAsXG4gICAgICB5OiB5MFxuICAgIH1dID0gcG9pbnRzO1xuICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCh4MCwgeTApO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh4MCwgeTApO1xuICAgIH1cblxuICAgIHBvaW50cy5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IF9yZWY7XG4gICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50c1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXggPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgIHBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xuICAgICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1hcmtlcnMucHVzaChbcG9pbnQsIHBvaW50LmFuZ2xlVG8ocG9pbnRzW2kgKyAxXSldKTtcbiAgICB9KTtcblxuICAgIGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hcmtlcnMucHVzaChbcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdWzFdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmtlcnM7XG4gIH1cblxufVxuXG5jbGFzcyBQb2x5Z29uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3BvbHlnb24nO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBzdXBlci5wYXRoKGN0eCk7XG4gICAgdmFyIFt7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH1dID0gdGhpcy5wb2ludHM7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG59XG5cbmNsYXNzIFBhdHRlcm5FbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3BhdHRlcm4nO1xuICB9XG5cbiAgY3JlYXRlUGF0dGVybihjdHgsIF8sIHBhcmVudE9wYWNpdHlQcm9wKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnLCB0cnVlKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5JywgdHJ1ZSk7IC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuXG4gICAgdmFyIHBhdHRlcm5TdmcgPSBuZXcgU1ZHRWxlbWVudCh0aGlzLmRvY3VtZW50LCBudWxsKTtcbiAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMudmlld0JveCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAndmlld0JveCcsIHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0VmFsdWUoKSk7XG4gICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd3aWR0aCcsIFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpKTtcbiAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdoZWlnaHQnLCBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIikpO1xuICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3RyYW5zZm9ybScsIHRoaXMuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJykuZ2V0VmFsdWUoKSk7XG4gICAgcGF0dGVyblN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHBhdHRlcm5DYW52YXMgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgIHZhciB5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5Jyk7XG5cbiAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSAmJiB5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICBwYXR0ZXJuQ3R4LnRyYW5zbGF0ZSh4QXR0ci5nZXRQaXhlbHMoJ3gnLCB0cnVlKSwgeUF0dHIuZ2V0UGl4ZWxzKCd5JywgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLnN0eWxlc1snZmlsbC1vcGFjaXR5J10gPSBwYXJlbnRPcGFjaXR5UHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0aGlzLnN0eWxlcywgJ2ZpbGwtb3BhY2l0eScpO1xuICAgIH0gLy8gcmVuZGVyIDN4MyBncmlkIHNvIHdoZW4gd2UgdHJhbnNmb3JtIHRoZXJlJ3Mgbm8gd2hpdGUgc3BhY2Ugb24gZWRnZXNcblxuXG4gICAgZm9yICh2YXIgeCA9IC0xOyB4IDw9IDE7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IC0xOyB5IDw9IDE7IHkrKykge1xuICAgICAgICBwYXR0ZXJuQ3R4LnNhdmUoKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3gnLCB4ICogcGF0dGVybkNhbnZhcy53aWR0aCk7XG4gICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd5JywgeSAqIHBhdHRlcm5DYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgcGF0dGVyblN2Zy5yZW5kZXIocGF0dGVybkN0eCk7XG4gICAgICAgIHBhdHRlcm5DdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4ocGF0dGVybkNhbnZhcywgJ3JlcGVhdCcpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG5cbn1cblxuY2xhc3MgTWFya2VyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdtYXJrZXInO1xuICB9XG5cbiAgcmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKSB7XG4gICAgaWYgKCFwb2ludCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yaWVudCcpLmdldFN0cmluZygnYXV0bycpO1xuICAgIHZhciBtYXJrZXJVbml0cyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXJrZXJVbml0cycpLmdldFN0cmluZygnc3Ryb2tlV2lkdGgnKTtcbiAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgaWYgKG9yaWVudCA9PT0gJ2F1dG8nKSB7XG4gICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICB9XG5cbiAgICBpZiAobWFya2VyVW5pdHMgPT09ICdzdHJva2VXaWR0aCcpIHtcbiAgICAgIGN0eC5zY2FsZShjdHgubGluZVdpZHRoLCBjdHgubGluZVdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpOyAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnRcblxuICAgIHZhciBtYXJrZXJTdmcgPSBuZXcgU1ZHRWxlbWVudCh0aGlzLmRvY3VtZW50LCBudWxsKTtcbiAgICBtYXJrZXJTdmcudHlwZSA9IHRoaXMudHlwZTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy52aWV3Qm94ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd2aWV3Qm94JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5yZWZYID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdyZWZYJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlgnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5yZWZZID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdyZWZZJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlknKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnd2lkdGgnLCB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VyV2lkdGgnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2hlaWdodCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdtYXJrZXJIZWlnaHQnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5vdmVyZmxvdyA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnb3ZlcmZsb3cnLCB0aGlzLmdldEF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5maWxsID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdmaWxsJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKS5nZXRDb2xvcignYmxhY2snKSk7XG4gICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuc3Ryb2tlID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdzdHJva2UnLCB0aGlzLmdldEF0dHJpYnV0ZSgnc3Ryb2tlJykuZ2V0VmFsdWUoJ25vbmUnKSk7XG4gICAgbWFya2VyU3ZnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBtYXJrZXJTdmcucmVuZGVyKGN0eCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIGlmIChtYXJrZXJVbml0cyA9PT0gJ3N0cm9rZVdpZHRoJykge1xuICAgICAgY3R4LnNjYWxlKDEgLyBjdHgubGluZVdpZHRoLCAxIC8gY3R4LmxpbmVXaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKG9yaWVudCA9PT0gJ2F1dG8nKSB7XG4gICAgICBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgfVxuXG4gICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG5cbn1cblxuY2xhc3MgRGVmc0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnZGVmcyc7XG4gIH1cblxuICByZW5kZXIoKSB7Ly8gTk9PUFxuICB9XG5cbn1cblxuY2xhc3MgR0VsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdnJztcbiAgfVxuXG4gIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxufVxuXG5jbGFzcyBHcmFkaWVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0ID0gWydncmFkaWVudFVuaXRzJ107XG4gICAgdGhpcy5zdG9wcyA9IFtdO1xuICAgIHZhciB7XG4gICAgICBzdG9wcyxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IHRoaXM7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3N0b3AnKSB7XG4gICAgICAgIHN0b3BzLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0R3JhZGllbnRVbml0cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnKS5nZXRTdHJpbmcoJ29iamVjdEJvdW5kaW5nQm94Jyk7XG4gIH1cblxuICBjcmVhdGVHcmFkaWVudChjdHgsIGVsZW1lbnQsIHBhcmVudE9wYWNpdHlQcm9wKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLCBjb25zaXN0ZW50LXRoaXNcbiAgICB2YXIgc3RvcHNDb250YWluZXIgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHN0b3BzQ29udGFpbmVyID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgdGhpcy5pbmhlcml0U3RvcENvbnRhaW5lcihzdG9wc0NvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHN0b3BzXG4gICAgfSA9IHN0b3BzQ29udGFpbmVyO1xuICAgIHZhciBncmFkaWVudCA9IHRoaXMuZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KTtcblxuICAgIGlmICghZ3JhZGllbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdLmNvbG9yKTtcbiAgICB9XG5cbiAgICBzdG9wcy5mb3JFYWNoKHN0b3AgPT4ge1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3Aub2Zmc2V0LCB0aGlzLmFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIHN0b3AuY29sb3IpKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyByZW5kZXIgYXMgdHJhbnNmb3JtZWQgcGF0dGVybiBvbiB0ZW1wb3JhcnkgY2FudmFzXG4gICAgICB2YXIge1xuICAgICAgICBkb2N1bWVudFxuICAgICAgfSA9IHRoaXM7XG4gICAgICB2YXIge1xuICAgICAgICBNQVhfVklSVFVBTF9QSVhFTFMsXG4gICAgICAgIHZpZXdQb3J0XG4gICAgICB9ID0gZG9jdW1lbnQuc2NyZWVuO1xuICAgICAgdmFyIFtyb290Vmlld10gPSB2aWV3UG9ydC52aWV3UG9ydHM7XG4gICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0RWxlbWVudChkb2N1bWVudCwgbnVsbCk7XG4gICAgICByZWN0LmF0dHJpYnV0ZXMueCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3gnLCAtTUFYX1ZJUlRVQUxfUElYRUxTIC8gMy4wKTtcbiAgICAgIHJlY3QuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneScsIC1NQVhfVklSVFVBTF9QSVhFTFMgLyAzLjApO1xuICAgICAgcmVjdC5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCBNQVhfVklSVFVBTF9QSVhFTFMpO1xuICAgICAgcmVjdC5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIE1BWF9WSVJUVUFMX1BJWEVMUyk7XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgR0VsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgZ3JvdXAuYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKS5nZXRWYWx1ZSgpKTtcbiAgICAgIGdyb3VwLmNoaWxkcmVuID0gW3JlY3RdO1xuICAgICAgdmFyIHBhdHRlcm5TdmcgPSBuZXcgU1ZHRWxlbWVudChkb2N1bWVudCwgbnVsbCk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3gnLCAwKTtcbiAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneScsIDApO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCByb290Vmlldy53aWR0aCk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnaGVpZ2h0Jywgcm9vdFZpZXcuaGVpZ2h0KTtcbiAgICAgIHBhdHRlcm5TdmcuY2hpbGRyZW4gPSBbZ3JvdXBdO1xuICAgICAgdmFyIHBhdHRlcm5DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXMocm9vdFZpZXcud2lkdGgsIHJvb3RWaWV3LmhlaWdodCk7XG4gICAgICB2YXIgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICBwYXR0ZXJuU3ZnLnJlbmRlcihwYXR0ZXJuQ3R4KTtcbiAgICAgIHJldHVybiBwYXR0ZXJuQ3R4LmNyZWF0ZVBhdHRlcm4ocGF0dGVybkNhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBncmFkaWVudDtcbiAgfVxuXG4gIGluaGVyaXRTdG9wQ29udGFpbmVyKHN0b3BzQ29udGFpbmVyKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LmZvckVhY2goYXR0cmlidXRlVG9Jbmhlcml0ID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpICYmIHN0b3BzQ29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0LCB0cnVlKS5zZXRWYWx1ZShzdG9wc0NvbnRhaW5lci5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIGNvbG9yKSB7XG4gICAgaWYgKHBhcmVudE9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciBjb2xvclByb3AgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2NvbG9yJywgY29sb3IpO1xuICAgICAgcmV0dXJuIGNvbG9yUHJvcC5hZGRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wKS5nZXRDb2xvcigpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG59XG5cbmNsYXNzIExpbmVhckdyYWRpZW50RWxlbWVudCBleHRlbmRzIEdyYWRpZW50RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdsaW5lYXJHcmFkaWVudCc7XG4gICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJyk7XG4gIH1cblxuICBnZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXNCb3VuZGluZ0JveFVuaXRzID0gdGhpcy5nZXRHcmFkaWVudFVuaXRzKCkgPT09ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpIDogbnVsbDtcblxuICAgIGlmIChpc0JvdW5kaW5nQm94VW5pdHMgJiYgIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd4MScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneDInLCB0cnVlKS5zZXRWYWx1ZSgxKTtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicsIHRydWUpLnNldFZhbHVlKDApO1xuICAgIH1cblxuICAgIHZhciB4MSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkxID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHgyID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeTIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgIGlmICh4MSA9PT0geDIgJiYgeTEgPT09IHkyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKTtcbiAgfVxuXG59XG5cbmNsYXNzIFJhZGlhbEdyYWRpZW50RWxlbWVudCBleHRlbmRzIEdyYWRpZW50RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdyYWRpYWxHcmFkaWVudCc7XG4gICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ2N4JywgJ2N5JywgJ3InLCAnZngnLCAnZnknLCAnZnInKTtcbiAgfVxuXG4gIGdldEdyYWRpZW50KGN0eCwgZWxlbWVudCkge1xuICAgIHZhciBpc0JvdW5kaW5nQm94VW5pdHMgPSB0aGlzLmdldEdyYWRpZW50VW5pdHMoKSA9PT0gJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCk7XG5cbiAgICBpZiAoaXNCb3VuZGluZ0JveFVuaXRzICYmICFib3VuZGluZ0JveCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnY3knLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgncicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdyJywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgIH1cblxuICAgIHZhciBjeCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGN5ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIGZ4ID0gY3g7XG4gICAgdmFyIGZ5ID0gY3k7XG5cbiAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuaGFzVmFsdWUoKSkge1xuICAgICAgZnggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdmeCcpLmdldFBpeGVscygneCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICBmeSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdmeScpLmdldFBpeGVscygneScpO1xuICAgIH1cblxuICAgIHZhciByID0gaXNCb3VuZGluZ0JveFVuaXRzID8gKGJvdW5kaW5nQm94LndpZHRoICsgYm91bmRpbmdCb3guaGVpZ2h0KSAvIDIuMCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgncicpLmdldFBpeGVscygpO1xuICAgIHZhciBmciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmcicpLmdldFBpeGVscygpO1xuICAgIHJldHVybiBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoZngsIGZ5LCBmciwgY3gsIGN5LCByKTtcbiAgfVxuXG59XG5cbmNsYXNzIFN0b3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdzdG9wJztcbiAgICB2YXIgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpLmdldE51bWJlcigpKSk7XG4gICAgdmFyIHN0b3BPcGFjaXR5ID0gdGhpcy5nZXRTdHlsZSgnc3RvcC1vcGFjaXR5Jyk7XG4gICAgdmFyIHN0b3BDb2xvciA9IHRoaXMuZ2V0U3R5bGUoJ3N0b3AtY29sb3InLCB0cnVlKTtcblxuICAgIGlmIChzdG9wQ29sb3IuZ2V0U3RyaW5nKCkgPT09ICcnKSB7XG4gICAgICBzdG9wQ29sb3Iuc2V0VmFsdWUoJyMwMDAnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RvcE9wYWNpdHkuaGFzVmFsdWUoKSkge1xuICAgICAgc3RvcENvbG9yID0gc3RvcENvbG9yLmFkZE9wYWNpdHkoc3RvcE9wYWNpdHkpO1xuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMuY29sb3IgPSBzdG9wQ29sb3IuZ2V0Q29sb3IoKTtcbiAgfVxuXG59XG5cbmNsYXNzIEFuaW1hdGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdhbmltYXRlJztcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsVW5pdHMgPSAnJztcbiAgICB0aGlzLnJlbW92ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xuICAgIGRvY3VtZW50LnNjcmVlbi5hbmltYXRpb25zLnB1c2godGhpcyk7XG4gICAgdGhpcy5iZWdpbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdiZWdpbicpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIHRoaXMubWF4RHVyYXRpb24gPSB0aGlzLmJlZ2luICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ2R1cicpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIHRoaXMuZnJvbSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmcm9tJyk7XG4gICAgdGhpcy50byA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0bycpO1xuICAgIHRoaXMudmFsdWVzID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndmFsdWVzJywgbnVsbCk7XG4gICAgdmFyIHZhbHVlc0F0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWVzJyk7XG5cbiAgICBpZiAodmFsdWVzQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICB0aGlzLnZhbHVlcy5zZXRWYWx1ZSh2YWx1ZXNBdHRyLmdldFN0cmluZygpLnNwbGl0KCc7JykpO1xuICAgIH1cbiAgfVxuXG4gIGdldFByb3BlcnR5KCkge1xuICAgIHZhciBhdHRyaWJ1dGVUeXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F0dHJpYnV0ZVR5cGUnKS5nZXRTdHJpbmcoKTtcbiAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdHRyaWJ1dGVOYW1lJykuZ2V0U3RyaW5nKCk7XG5cbiAgICBpZiAoYXR0cmlidXRlVHlwZSA9PT0gJ0NTUycpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRTdHlsZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xuICB9XG5cbiAgY2FsY1ZhbHVlKCkge1xuICAgIHZhciB7XG4gICAgICBpbml0aWFsVW5pdHNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIge1xuICAgICAgcHJvZ3Jlc3MsXG4gICAgICBmcm9tLFxuICAgICAgdG9cbiAgICB9ID0gdGhpcy5nZXRQcm9ncmVzcygpOyAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuXG4gICAgdmFyIG5ld1ZhbHVlID0gZnJvbS5nZXROdW1iZXIoKSArICh0by5nZXROdW1iZXIoKSAtIGZyb20uZ2V0TnVtYmVyKCkpICogcHJvZ3Jlc3M7XG5cbiAgICBpZiAoaW5pdGlhbFVuaXRzID09PSAnJScpIHtcbiAgICAgIG5ld1ZhbHVlICo9IDEwMC4wOyAvLyBudW1WYWx1ZSgpIHJldHVybnMgMC0xIHdoZXJlYXMgcHJvcGVydGllcyBhcmUgMC0xMDBcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQobmV3VmFsdWUpLmNvbmNhdChpbml0aWFsVW5pdHMpO1xuICB9XG5cbiAgdXBkYXRlKGRlbHRhKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBwcm9wID0gdGhpcy5nZXRQcm9wZXJ0eSgpOyAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuXG4gICAgaWYgKCF0aGlzLmluaXRpYWxWYWx1ZSkge1xuICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBwcm9wLmdldFN0cmluZygpO1xuICAgICAgdGhpcy5pbml0aWFsVW5pdHMgPSBwcm9wLmdldFVuaXRzKCk7XG4gICAgfSAvLyBpZiB3ZSdyZSBwYXN0IHRoZSBlbmQgdGltZVxuXG5cbiAgICBpZiAodGhpcy5kdXJhdGlvbiA+IHRoaXMubWF4RHVyYXRpb24pIHtcbiAgICAgIHZhciBmaWxsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKS5nZXRTdHJpbmcoJ3JlbW92ZScpOyAvLyBsb29wIGZvciBpbmRlZmluaXRlbHkgcmVwZWF0aW5nIGFuaW1hdGlvbnNcblxuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdyZXBlYXRDb3VudCcpLmdldFN0cmluZygpID09PSAnaW5kZWZpbml0ZScgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcGVhdER1cicpLmdldFN0cmluZygpID09PSAnaW5kZWZpbml0ZScpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGZpbGwgPT09ICdmcmVlemUnICYmICF0aGlzLmZyb3plbikge1xuICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gICAgICAgIHBhcmVudC5hbmltYXRpb25Gcm96ZW4gPSB0cnVlO1xuICAgICAgICBwYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSBwcm9wLmdldFN0cmluZygpO1xuICAgICAgfSBlbHNlIGlmIChmaWxsID09PSAncmVtb3ZlJyAmJiAhdGhpcy5yZW1vdmVkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIHByb3Auc2V0VmFsdWUocGFyZW50LmFuaW1hdGlvbkZyb3plbiA/IHBhcmVudC5hbmltYXRpb25Gcm96ZW5WYWx1ZSA6IHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmR1cmF0aW9uICs9IGRlbHRhOyAvLyBpZiB3ZSdyZSBwYXN0IHRoZSBiZWdpbiB0aW1lXG5cbiAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuYmVnaW4gPCB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNhbGNWYWx1ZSgpOyAvLyB0d2VlblxuXG4gICAgICB2YXIgdHlwZUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuXG4gICAgICBpZiAodHlwZUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAvLyBmb3IgdHJhbnNmb3JtLCBldGMuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZUF0dHIuZ2V0U3RyaW5nKCk7XG4gICAgICAgIG5ld1ZhbHVlID0gXCJcIi5jb25jYXQodHlwZSwgXCIoXCIpLmNvbmNhdChuZXdWYWx1ZSwgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVkO1xuICB9XG5cbiAgZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgdmFsdWVzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHByb2dyZXNzOiAodGhpcy5kdXJhdGlvbiAtIHRoaXMuYmVnaW4pIC8gKHRoaXMubWF4RHVyYXRpb24gLSB0aGlzLmJlZ2luKVxuICAgIH07XG5cbiAgICBpZiAodmFsdWVzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnByb2dyZXNzICogKHZhbHVlcy5nZXRWYWx1ZSgpLmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIGxiID0gTWF0aC5mbG9vcihwKTtcbiAgICAgIHZhciB1YiA9IE1hdGguY2VpbChwKTtcbiAgICAgIHJlc3VsdC5mcm9tID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZnJvbScsIHBhcnNlRmxvYXQodmFsdWVzLmdldFZhbHVlKClbbGJdKSk7XG4gICAgICByZXN1bHQudG8gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd0bycsIHBhcnNlRmxvYXQodmFsdWVzLmdldFZhbHVlKClbdWJdKSk7XG4gICAgICByZXN1bHQucHJvZ3Jlc3MgPSAocCAtIGxiKSAvICh1YiAtIGxiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LmZyb20gPSB0aGlzLmZyb207XG4gICAgICByZXN1bHQudG8gPSB0aGlzLnRvO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlQ29sb3JFbGVtZW50IGV4dGVuZHMgQW5pbWF0ZUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdhbmltYXRlQ29sb3InO1xuICB9XG5cbiAgY2FsY1ZhbHVlKCkge1xuICAgIHZhciB7XG4gICAgICBwcm9ncmVzcyxcbiAgICAgIGZyb20sXG4gICAgICB0b1xuICAgIH0gPSB0aGlzLmdldFByb2dyZXNzKCk7XG4gICAgdmFyIGNvbG9yRnJvbSA9IG5ldyBSR0JDb2xvcihmcm9tLmdldENvbG9yKCkpO1xuICAgIHZhciBjb2xvclRvID0gbmV3IFJHQkNvbG9yKHRvLmdldENvbG9yKCkpO1xuXG4gICAgaWYgKGNvbG9yRnJvbS5vayAmJiBjb2xvclRvLm9rKSB7XG4gICAgICAvLyB0d2VlbiBjb2xvciBsaW5lYXJseVxuICAgICAgdmFyIHIgPSBjb2xvckZyb20uciArIChjb2xvclRvLnIgLSBjb2xvckZyb20ucikgKiBwcm9ncmVzcztcbiAgICAgIHZhciBnID0gY29sb3JGcm9tLmcgKyAoY29sb3JUby5nIC0gY29sb3JGcm9tLmcpICogcHJvZ3Jlc3M7XG4gICAgICB2YXIgYiA9IGNvbG9yRnJvbS5iICsgKGNvbG9yVG8uYiAtIGNvbG9yRnJvbS5iKSAqIHByb2dyZXNzOyAvLyA/IGFscGhhXG5cbiAgICAgIHJldHVybiBcInJnYihcIi5jb25jYXQoTWF0aC5mbG9vcihyKSwgXCIsIFwiKS5jb25jYXQoTWF0aC5mbG9vcihnKSwgXCIsIFwiKS5jb25jYXQoTWF0aC5mbG9vcihiKSwgXCIpXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZnJvbScpLmdldENvbG9yKCk7XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCBleHRlbmRzIEFuaW1hdGVFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnYW5pbWF0ZVRyYW5zZm9ybSc7XG4gIH1cblxuICBjYWxjVmFsdWUoKSB7XG4gICAgdmFyIHtcbiAgICAgIHByb2dyZXNzLFxuICAgICAgZnJvbSxcbiAgICAgIHRvXG4gICAgfSA9IHRoaXMuZ2V0UHJvZ3Jlc3MoKTsgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcblxuICAgIHZhciB0cmFuc2Zvcm1Gcm9tID0gdG9OdW1iZXJzKGZyb20uZ2V0U3RyaW5nKCkpO1xuICAgIHZhciB0cmFuc2Zvcm1UbyA9IHRvTnVtYmVycyh0by5nZXRTdHJpbmcoKSk7XG4gICAgdmFyIG5ld1ZhbHVlID0gdHJhbnNmb3JtRnJvbS5tYXAoKGZyb20sIGkpID0+IHtcbiAgICAgIHZhciB0byA9IHRyYW5zZm9ybVRvW2ldO1xuICAgICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIHByb2dyZXNzO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgICByZXR1cm4gbmV3VmFsdWU7XG4gIH1cblxufVxuXG5jbGFzcyBGb250RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZm9udCc7XG4gICAgdGhpcy5nbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuaG9yaXpBZHZYID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hvcml6LWFkdi14JykuZ2V0TnVtYmVyKCk7XG4gICAgdmFyIHtcbiAgICAgIGRlZmluaXRpb25zXG4gICAgfSA9IGRvY3VtZW50O1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIHN3aXRjaCAoY2hpbGQudHlwZSkge1xuICAgICAgICBjYXNlICdmb250LWZhY2UnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZm9udEZhY2UgPSBjaGlsZDtcbiAgICAgICAgICAgIHZhciBmb250RmFtaWx5U3R5bGUgPSBjaGlsZC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKTtcblxuICAgICAgICAgICAgaWYgKGZvbnRGYW1pbHlTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgIGRlZmluaXRpb25zW2ZvbnRGYW1pbHlTdHlsZS5nZXRTdHJpbmcoKV0gPSB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICAgICAgdGhpcy5taXNzaW5nR2x5cGggPSBjaGlsZDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdnbHlwaCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gY2hpbGQ7XG5cbiAgICAgICAgICAgIGlmIChnbHlwaC5hcmFiaWNGb3JtKSB7XG4gICAgICAgICAgICAgIHRoaXMuaXNSVEwgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmlzQXJhYmljID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2dseXBoLnVuaWNvZGVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2dseXBoLnVuaWNvZGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2dseXBoLnVuaWNvZGVdW2dseXBoLmFyYWJpY0Zvcm1dID0gZ2x5cGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmdseXBoc1tnbHlwaC51bmljb2RlXSA9IGdseXBoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkgey8vIE5PIFJFTkRFUlxuICB9XG5cbn1cblxuY2xhc3MgRm9udEZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuYXNjZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FzY2VudCcpLmdldE51bWJlcigpO1xuICAgIHRoaXMuZGVzY2VudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkZXNjZW50JykuZ2V0TnVtYmVyKCk7XG4gICAgdGhpcy51bml0c1BlckVtID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3VuaXRzLXBlci1lbScpLmdldE51bWJlcigpO1xuICB9XG5cbn1cblxuY2xhc3MgTWlzc2luZ0dseXBoRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnbWlzc2luZy1nbHlwaCc7XG4gICAgdGhpcy5ob3JpekFkdlggPSAwO1xuICB9XG5cbn1cblxuY2xhc3MgVFJlZkVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3RyZWYnO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG5cbiAgICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICAgIHJldHVybiBmaXJzdENoaWxkLmdldFRleHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxufVxuXG5jbGFzcyBBRWxlbWVudCBleHRlbmRzIFRleHRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2EnO1xuICAgIHZhciB7XG4gICAgICBjaGlsZE5vZGVzXG4gICAgfSA9IG5vZGU7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBjaGlsZE5vZGVzWzBdO1xuICAgIHZhciBoYXNUZXh0ID0gY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmIEFycmF5LmZyb20oY2hpbGROb2RlcykuZXZlcnkobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSAzKTtcbiAgICB0aGlzLmhhc1RleHQgPSBoYXNUZXh0O1xuICAgIHRoaXMudGV4dCA9IGhhc1RleHQgPyB0aGlzLmdldFRleHRGcm9tTm9kZShmaXJzdENoaWxkKSA6ICcnO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgaWYgKHRoaXMuaGFzVGV4dCkge1xuICAgICAgLy8gcmVuZGVyIGFzIHRleHQgZWxlbWVudFxuICAgICAgc3VwZXIucmVuZGVyQ2hpbGRyZW4oY3R4KTtcbiAgICAgIHZhciB7XG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcztcbiAgICAgIHZhciB7XG4gICAgICAgIG1vdXNlXG4gICAgICB9ID0gZG9jdW1lbnQuc2NyZWVuO1xuICAgICAgdmFyIGZvbnRTaXplID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZm9udFNpemUnLCBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KS5mb250U2l6ZSk7IC8vIERvIG5vdCBjYWxjIGJvdW5kaW5nIGJveCBpZiBtb3VzZSBpcyBub3Qgd29ya2luZy5cblxuICAgICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICAgIG1vdXNlLmNoZWNrQm91bmRpbmdCb3godGhpcywgbmV3IEJvdW5kaW5nQm94KHgsIHkgLSBmb250U2l6ZS5nZXRQaXhlbHMoJ3knKSwgeCArIHRoaXMubWVhc3VyZVRleHQoY3R4KSwgeSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyByZW5kZXIgYXMgdGVtcG9yYXJ5IGdyb3VwXG4gICAgICB2YXIgZyA9IG5ldyBHRWxlbWVudCh0aGlzLmRvY3VtZW50LCBudWxsKTtcbiAgICAgIGcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgZy5wYXJlbnQgPSB0aGlzO1xuICAgICAgZy5yZW5kZXIoY3R4KTtcbiAgICB9XG4gIH1cblxuICBvbkNsaWNrKCkge1xuICAgIHZhciB7XG4gICAgICB3aW5kb3dcbiAgICB9ID0gdGhpcy5kb2N1bWVudDtcblxuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5vcGVuKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldFN0cmluZygpKTtcbiAgICB9XG4gIH1cblxuICBvbk1vdXNlTW92ZSgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5kb2N1bWVudC5jdHg7XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmNsYXNzIFRleHRQYXRoRWxlbWVudCBleHRlbmRzIFRleHRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3RleHRQYXRoJztcbiAgICB0aGlzLnRleHRXaWR0aCA9IDA7XG4gICAgdGhpcy50ZXh0SGVpZ2h0ID0gMDtcbiAgICB0aGlzLnBhdGhMZW5ndGggPSAtMTtcbiAgICB0aGlzLmdseXBoSW5mbyA9IG51bGw7XG4gICAgdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGUgPSBbXTtcbiAgICB0aGlzLm1lYXN1cmVzQ2FjaGUgPSBuZXcgTWFwKFtbJycsIDBdXSk7XG4gICAgdmFyIHBhdGhFbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgIHRoaXMudGV4dCA9IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKCk7XG4gICAgdGhpcy5kYXRhQXJyYXkgPSB0aGlzLnBhcnNlUGF0aERhdGEocGF0aEVsZW1lbnQpO1xuICB9XG5cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZGF0YUFycmF5XG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgZGF0YUFycmF5LmZvckVhY2goX3JlZiA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gPSBfcmVmO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgW2N4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzXSA9IHBvaW50cztcbiAgICAgICAgICAgIHZhciByID0gcnggPiByeSA/IHJ4IDogcnk7XG4gICAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgICAgdmFyIHNjYWxlWSA9IHJ4ID4gcnkgPyByeSAvIHJ4IDogMTtcblxuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIEJvb2xlYW4oMSAtIGZzKSk7XG4gICAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ0xPU0VfUEFUSDpcbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICB0aGlzLnNldFRleHREYXRhKGN0eCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICB2YXIgdGV4dERlY29yYXRpb24gPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgndGV4dC1kZWNvcmF0aW9uJykuZ2V0U3RyaW5nKCk7XG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgIHZhciB7XG4gICAgICBnbHlwaEluZm9cbiAgICB9ID0gdGhpcztcbiAgICB2YXIgZmlsbCA9IGN0eC5maWxsU3R5bGU7XG5cbiAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgZ2x5cGhJbmZvLmZvckVhY2goKGdseXBoLCBpKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBwMCxcbiAgICAgICAgcDEsXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICB0ZXh0OiBwYXJ0aWFsVGV4dFxuICAgICAgfSA9IGdseXBoO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUocDAueCwgcDAueSk7XG4gICAgICBjdHgucm90YXRlKHJvdGF0aW9uKTtcblxuICAgICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgICBjdHguc3Ryb2tlVGV4dChwYXJ0aWFsVGV4dCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBjdHgubW92ZVRvKHAwLngsIHAwLnkgKyBmb250U2l6ZSAvIDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55ICsgZm9udFNpemUgLyA1KTtcbiAgICAgIH0gLy8gLy8gVG8gYXNzaXN0IHdpdGggZGVidWdnaW5nIHZpc3VhbGx5LCB1bmNvbW1lbnQgZm9sbG93aW5nXG4gICAgICAvL1xuICAgICAgLy8gY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgLy8gaWYgKGkgJSAyKVxuICAgICAgLy8gXHRjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgIC8vIGVsc2VcbiAgICAgIC8vIFx0Y3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgIC8vIGN0eC5tb3ZlVG8ocDAueCwgcDAueSk7XG4gICAgICAvLyBjdHgubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgLy8gY3R4LnN0cm9rZSgpO1xuICAgICAgLy8gY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgfSk7XG5cbiAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gZm9udFNpemUgLyAyMDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGZpbGw7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGdldExldHRlclNwYWNpbmdBdCgpIHtcbiAgICB2YXIgaWR4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHJldHVybiB0aGlzLmxldHRlclNwYWNpbmdDYWNoZVtpZHhdIHx8IDA7XG4gIH1cblxuICBmaW5kU2VnbWVudFRvRml0Q2hhcihjdHgsIGFuY2hvciwgdGV4dEZ1bGxXaWR0aCwgZnVsbFBhdGhXaWR0aCwgc3BhY2VzTnVtYmVyLCBpbnB1dE9mZnNldCwgZHksIGMsIGNoYXJJKSB7XG4gICAgdmFyIG9mZnNldCA9IGlucHV0T2Zmc2V0O1xuICAgIHZhciBnbHlwaFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChjdHgsIGMpO1xuXG4gICAgaWYgKGMgPT09ICcgJyAmJiBhbmNob3IgPT09ICdqdXN0aWZ5JyAmJiB0ZXh0RnVsbFdpZHRoIDwgZnVsbFBhdGhXaWR0aCkge1xuICAgICAgZ2x5cGhXaWR0aCArPSAoZnVsbFBhdGhXaWR0aCAtIHRleHRGdWxsV2lkdGgpIC8gc3BhY2VzTnVtYmVyO1xuICAgIH1cblxuICAgIGlmIChjaGFySSA+IC0xKSB7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5nZXRMZXR0ZXJTcGFjaW5nQXQoY2hhckkpO1xuICAgIH1cblxuICAgIHZhciBzcGxpbmVTdGVwID0gdGhpcy50ZXh0SGVpZ2h0IC8gMjA7XG4gICAgdmFyIHAwID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKG9mZnNldCwgc3BsaW5lU3RlcCwgMCk7XG4gICAgdmFyIHAxID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKG9mZnNldCArIGdseXBoV2lkdGgsIHNwbGluZVN0ZXAsIDApO1xuICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgcDAsXG4gICAgICBwMVxuICAgIH07XG4gICAgdmFyIHJvdGF0aW9uID0gcDAgJiYgcDEgPyBNYXRoLmF0YW4yKHAxLnkgLSBwMC55LCBwMS54IC0gcDAueCkgOiAwO1xuXG4gICAgaWYgKGR5KSB7XG4gICAgICB2YXIgZHlYID0gTWF0aC5jb3MoTWF0aC5QSSAvIDIgKyByb3RhdGlvbikgKiBkeTtcbiAgICAgIHZhciBkeVkgPSBNYXRoLmNvcygtcm90YXRpb24pICogZHk7XG4gICAgICBzZWdtZW50LnAwID0gX29iamVjdFNwcmVhZCQyKF9vYmplY3RTcHJlYWQkMih7fSwgcDApLCB7fSwge1xuICAgICAgICB4OiBwMC54ICsgZHlYLFxuICAgICAgICB5OiBwMC55ICsgZHlZXG4gICAgICB9KTtcbiAgICAgIHNlZ21lbnQucDEgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBwMSksIHt9LCB7XG4gICAgICAgIHg6IHAxLnggKyBkeVgsXG4gICAgICAgIHk6IHAxLnkgKyBkeVlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBnbHlwaFdpZHRoO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQsXG4gICAgICBzZWdtZW50LFxuICAgICAgcm90YXRpb25cbiAgICB9O1xuICB9XG5cbiAgbWVhc3VyZVRleHQoY3R4LCB0ZXh0KSB7XG4gICAgdmFyIHtcbiAgICAgIG1lYXN1cmVzQ2FjaGVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdGFyZ2V0VGV4dCA9IHRleHQgfHwgdGhpcy5nZXRUZXh0KCk7XG5cbiAgICBpZiAobWVhc3VyZXNDYWNoZS5oYXModGFyZ2V0VGV4dCkpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlc0NhY2hlLmdldCh0YXJnZXRUZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgbWVhc3VyZSA9IHRoaXMubWVhc3VyZVRhcmdldFRleHQoY3R4LCB0YXJnZXRUZXh0KTtcbiAgICBtZWFzdXJlc0NhY2hlLnNldCh0YXJnZXRUZXh0LCBtZWFzdXJlKTtcbiAgICByZXR1cm4gbWVhc3VyZTtcbiAgfSAvLyBUaGlzIG1ldGhvZCBzdXBwb3NlcyB3aGF0IGFsbCBjdXN0b20gZm9udHMgYWxyZWFkeSBsb2FkZWQuXG4gIC8vIElmIHNvbWUgZm9udCB3aWxsIGJlIGxvYWRlZCBhZnRlciB0aGlzIG1ldGhvZCBjYWxsLCA8dGV4dFBhdGg+IHdpbGwgbm90IGJlIHJlbmRlcmVkIGNvcnJlY3RseS5cbiAgLy8gWW91IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBtYW51YWxseSB0byB1cGRhdGUgZ2x5cGhzIGNhY2hlLlxuXG5cbiAgc2V0VGV4dERhdGEoY3R4KSB7XG4gICAgaWYgKHRoaXMuZ2x5cGhJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlclRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICB2YXIgY2hhcnMgPSByZW5kZXJUZXh0LnNwbGl0KCcnKTtcbiAgICB2YXIgc3BhY2VzTnVtYmVyID0gcmVuZGVyVGV4dC5zcGxpdCgnICcpLmxlbmd0aCAtIDE7XG4gICAgdmFyIGR4ID0gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLnNwbGl0KCkubWFwKF8gPT4gXy5nZXRQaXhlbHMoJ3gnKSk7XG4gICAgdmFyIGR5ID0gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCdkeScpLmdldFBpeGVscygneScpO1xuICAgIHZhciBhbmNob3IgPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgndGV4dC1hbmNob3InKS5nZXRTdHJpbmcoJ3N0YXJ0Jyk7XG4gICAgdmFyIHRoaXNTcGFjaW5nID0gdGhpcy5nZXRTdHlsZSgnbGV0dGVyLXNwYWNpbmcnKTtcbiAgICB2YXIgcGFyZW50U3BhY2luZyA9IHRoaXMucGFyZW50LmdldFN0eWxlKCdsZXR0ZXItc3BhY2luZycpO1xuICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gMDtcblxuICAgIGlmICghdGhpc1NwYWNpbmcuaGFzVmFsdWUoKSB8fCB0aGlzU3BhY2luZy5nZXRWYWx1ZSgpID09PSAnaW5oZXJpdCcpIHtcbiAgICAgIGxldHRlclNwYWNpbmcgPSBwYXJlbnRTcGFjaW5nLmdldFBpeGVscygpO1xuICAgIH0gZWxzZSBpZiAodGhpc1NwYWNpbmcuaGFzVmFsdWUoKSkge1xuICAgICAgaWYgKHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgIT09ICdpbml0aWFsJyAmJiB0aGlzU3BhY2luZy5nZXRWYWx1ZSgpICE9PSAndW5zZXQnKSB7XG4gICAgICAgIGxldHRlclNwYWNpbmcgPSB0aGlzU3BhY2luZy5nZXRQaXhlbHMoKTtcbiAgICAgIH1cbiAgICB9IC8vIGZpbGwgbGV0dGVyLXNwYWNpbmcgY2FjaGVcblxuXG4gICAgdmFyIGxldHRlclNwYWNpbmdDYWNoZSA9IFtdO1xuICAgIHZhciB0ZXh0TGVuID0gcmVuZGVyVGV4dC5sZW5ndGg7XG4gICAgdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGUgPSBsZXR0ZXJTcGFjaW5nQ2FjaGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMZW47IGkrKykge1xuICAgICAgbGV0dGVyU3BhY2luZ0NhY2hlLnB1c2godHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyA/IGR4W2ldIDogbGV0dGVyU3BhY2luZyk7XG4gICAgfVxuXG4gICAgdmFyIGR4U3VtID0gbGV0dGVyU3BhY2luZ0NhY2hlLnJlZHVjZSgoYWNjLCBjdXIsIGkpID0+IGkgPT09IDAgPyAwIDogYWNjICsgY3VyIHx8IDAsIDApO1xuICAgIHZhciB0ZXh0V2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGN0eCk7XG4gICAgdmFyIHRleHRGdWxsV2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGggKyBkeFN1bSwgMCk7XG4gICAgdGhpcy50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgdGhpcy50ZXh0SGVpZ2h0ID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgIHRoaXMuZ2x5cGhJbmZvID0gW107XG4gICAgdmFyIGZ1bGxQYXRoV2lkdGggPSB0aGlzLmdldFBhdGhMZW5ndGgoKTtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLmdldFN0eWxlKCdzdGFydE9mZnNldCcpLmdldE51bWJlcigwKSAqIGZ1bGxQYXRoV2lkdGg7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICBpZiAoYW5jaG9yID09PSAnbWlkZGxlJyB8fCBhbmNob3IgPT09ICdjZW50ZXInKSB7XG4gICAgICBvZmZzZXQgPSAtdGV4dEZ1bGxXaWR0aCAvIDI7XG4gICAgfVxuXG4gICAgaWYgKGFuY2hvciA9PT0gJ2VuZCcgfHwgYW5jaG9yID09PSAncmlnaHQnKSB7XG4gICAgICBvZmZzZXQgPSAtdGV4dEZ1bGxXaWR0aDtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gc3RhcnRPZmZzZXQ7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhciwgaSkgPT4ge1xuICAgICAgLy8gRmluZCBzdWNoIHNlZ21lbnQgd2hhdCBkaXN0YW5jZSBiZXR3ZWVuIHAwIGFuZCBwMSBpcyBhcHByb3guIHdpZHRoIG9mIGdseXBoXG4gICAgICB2YXIge1xuICAgICAgICBvZmZzZXQ6IG5leHRPZmZzZXQsXG4gICAgICAgIHNlZ21lbnQsXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9ID0gdGhpcy5maW5kU2VnbWVudFRvRml0Q2hhcihjdHgsIGFuY2hvciwgdGV4dEZ1bGxXaWR0aCwgZnVsbFBhdGhXaWR0aCwgc3BhY2VzTnVtYmVyLCBvZmZzZXQsIGR5LCBjaGFyLCBpKTtcbiAgICAgIG9mZnNldCA9IG5leHRPZmZzZXQ7XG5cbiAgICAgIGlmICghc2VnbWVudC5wMCB8fCAhc2VnbWVudC5wMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRMaW5lTGVuZ3RoKFxuICAgICAgLy8gXHRzZWdtZW50LnAwLngsXG4gICAgICAvLyBcdHNlZ21lbnQucDAueSxcbiAgICAgIC8vIFx0c2VnbWVudC5wMS54LFxuICAgICAgLy8gXHRzZWdtZW50LnAxLnlcbiAgICAgIC8vICk7XG4gICAgICAvLyBOb3RlOiBTaW5jZSBnbHlwaHMgYXJlIHJlbmRlcmVkIG9uZSBhdCBhIHRpbWUsIGFueSBrZXJuaW5nIHBhaXIgZGF0YSBidWlsdCBpbnRvIHRoZSBmb250IHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAvLyBDYW4gZm9yZXNlZSBoYXZpbmcgYSByb3VnaCBwYWlyIHRhYmxlIGJ1aWx0IGluIHRoYXQgdGhlIGRldmVsb3BlciBjYW4gb3ZlcnJpZGUgYXMgbmVlZGVkLlxuICAgICAgLy8gT3IgdXNlIFwiZHhcIiBhdHRyaWJ1dGUgb2YgdGhlIDx0ZXh0PiBub2RlIGFzIGEgbmFpdmUgcmVwbGFjZW1lbnRcbiAgICAgIC8vIGNvbnN0IGtlcm4gPSAwO1xuICAgICAgLy8gcGxhY2Vob2xkZXIgZm9yIGZ1dHVyZSBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gY29uc3QgbWlkcG9pbnQgPSB0aGlzLmdldFBvaW50T25MaW5lKFxuICAgICAgLy8gXHRrZXJuICsgd2lkdGggLyAyLjAsXG4gICAgICAvLyBcdHNlZ21lbnQucDAueCwgc2VnbWVudC5wMC55LCBzZWdtZW50LnAxLngsIHNlZ21lbnQucDEueVxuICAgICAgLy8gKTtcblxuXG4gICAgICB0aGlzLmdseXBoSW5mby5wdXNoKHtcbiAgICAgICAgLy8gdHJhbnNwb3NlWDogbWlkcG9pbnQueCxcbiAgICAgICAgLy8gdHJhbnNwb3NlWTogbWlkcG9pbnQueSxcbiAgICAgICAgdGV4dDogY2hhcnNbaV0sXG4gICAgICAgIHAwOiBzZWdtZW50LnAwLFxuICAgICAgICBwMTogc2VnbWVudC5wMSxcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcGFyc2VQYXRoRGF0YShwYXRoKSB7XG4gICAgdGhpcy5wYXRoTGVuZ3RoID0gLTE7IC8vIHJlc2V0IHBhdGggbGVuZ3RoXG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aENvbW1hbmRzID0gW107XG4gICAgdmFyIHtcbiAgICAgIHBhdGhQYXJzZXJcbiAgICB9ID0gcGF0aDtcbiAgICBwYXRoUGFyc2VyLnJlc2V0KCk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgd2hpbGUgKCFwYXRoUGFyc2VyLmlzRW5kKCkpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgdmFyIHN0YXJ0WCA9IGN1cnJlbnQgPyBjdXJyZW50LnggOiAwO1xuICAgICAgdmFyIHN0YXJ0WSA9IGN1cnJlbnQgPyBjdXJyZW50LnkgOiAwO1xuICAgICAgdmFyIGNvbW1hbmQgPSBwYXRoUGFyc2VyLm5leHQoKTtcbiAgICAgIHZhciBuZXh0Q29tbWFuZFR5cGUgPSBjb21tYW5kLnR5cGU7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG5cbiAgICAgIHN3aXRjaCAoY29tbWFuZC50eXBlKSB7XG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aE0ocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhMKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkhPUklaX0xJTkVfVE86XG4gICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoSChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5WRVJUX0xJTkVfVE86XG4gICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoVihwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhDKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9DVVJWRV9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhTKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgdGhpcy5wYXRoUShwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfUVVBRF9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhUKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICBwb2ludHMgPSB0aGlzLnBhdGhBKHBhdGhQYXJzZXIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgIFBhdGhFbGVtZW50LnBhdGhaKHBhdGhQYXJzZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFuZC50eXBlICE9PSBQYXRoUGFyc2VyLkNMT1NFX1BBVEgpIHtcbiAgICAgICAgcGF0aENvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IG5leHRDb21tYW5kVHlwZSxcbiAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IHN0YXJ0WVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGF0aExlbmd0aDogdGhpcy5jYWxjTGVuZ3RoKHN0YXJ0WCwgc3RhcnRZLCBuZXh0Q29tbWFuZFR5cGUsIHBvaW50cylcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoQ29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogUGF0aFBhcnNlci5DTE9TRV9QQVRILFxuICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgcGF0aExlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aENvbW1hbmRzO1xuICB9XG5cbiAgcGF0aE0ocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhNKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICB9XG5cbiAgcGF0aEwocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gIH1cblxuICBwYXRoSChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEgocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgcmV0dXJuIFBhdGhQYXJzZXIuTElORV9UTztcbiAgfVxuXG4gIHBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoVihwYXRoUGFyc2VyKS5wb2ludDtcbiAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICB9XG5cbiAgcGF0aEMocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhDKHBhdGhQYXJzZXIpO1xuICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgfVxuXG4gIHBhdGhTKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoUyhwYXRoUGFyc2VyKTtcbiAgICBwb2ludHMucHVzaChwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgcmV0dXJuIFBhdGhQYXJzZXIuQ1VSVkVfVE87XG4gIH1cblxuICBwYXRoUShwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhRKHBhdGhQYXJzZXIpO1xuICAgIHBvaW50cy5wdXNoKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgfVxuXG4gIHBhdGhUKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFQocGF0aFBhcnNlcik7XG4gICAgcG9pbnRzLnB1c2goY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIHJldHVybiBQYXRoUGFyc2VyLlFVQURfVE87XG4gIH1cblxuICBwYXRoQShwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIHJYLFxuICAgICAgclksXG4gICAgICBzd2VlcEZsYWcsXG4gICAgICB4QXhpc1JvdGF0aW9uLFxuICAgICAgY2VudHAsXG4gICAgICBhMSxcbiAgICAgIGFkXG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhBKHBhdGhQYXJzZXIpO1xuXG4gICAgaWYgKHN3ZWVwRmxhZyA9PT0gMCAmJiBhZCA+IDApIHtcbiAgICAgIGFkIC09IDIgKiBNYXRoLlBJO1xuICAgIH1cblxuICAgIGlmIChzd2VlcEZsYWcgPT09IDEgJiYgYWQgPCAwKSB7XG4gICAgICBhZCArPSAyICogTWF0aC5QSTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2NlbnRwLngsIGNlbnRwLnksIHJYLCByWSwgYTEsIGFkLCB4QXhpc1JvdGF0aW9uLCBzd2VlcEZsYWddO1xuICB9XG5cbiAgY2FsY0xlbmd0aCh4LCB5LCBjb21tYW5kVHlwZSwgcG9pbnRzKSB7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgdmFyIHAxID0gbnVsbDtcbiAgICB2YXIgcDIgPSBudWxsO1xuICAgIHZhciB0ID0gMDtcblxuICAgIHN3aXRjaCAoY29tbWFuZFR5cGUpIHtcbiAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lTGVuZ3RoKHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uQ3ViaWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG5cbiAgICAgICAgZm9yICh0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZW47XG5cbiAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKDAsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG5cbiAgICAgICAgZm9yICh0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZW47XG5cbiAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byBsaW5lIHNlZ21lbnRzXG4gICAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50c1s0XTsgLy8gNCA9IHRoZXRhXG5cbiAgICAgICAgICB2YXIgZFRoZXRhID0gcG9pbnRzWzVdOyAvLyA1ID0gZFRoZXRhXG5cbiAgICAgICAgICB2YXIgZW5kID0gcG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgIHZhciBpbmMgPSBNYXRoLlBJIC8gMTgwLjA7IC8vIDEgZGVncmVlIHJlc29sdXRpb25cblxuICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydCAtIGVuZCkgPCBpbmMpIHtcbiAgICAgICAgICAgIGluYyA9IE1hdGguYWJzKHN0YXJ0IC0gZW5kKTtcbiAgICAgICAgICB9IC8vIE5vdGU6IGZvciBwdXJwb3NlIG9mIGNhbGN1bGF0aW5nIGFyYyBsZW5ndGgsIG5vdCBnb2luZyB0byB3b3JyeSBhYm91dCByb3RhdGluZyBYLWF4aXMgYnkgYW5nbGUgcHNpXG5cblxuICAgICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHN0YXJ0LCAwKTtcblxuICAgICAgICAgIGlmIChkVGhldGEgPCAwKSB7XG4gICAgICAgICAgICAvLyBjbG9ja3dpc2VcbiAgICAgICAgICAgIGZvciAodCA9IHN0YXJ0IC0gaW5jOyB0ID4gZW5kOyB0IC09IGluYykge1xuICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCB0LCAwKTtcbiAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY291bnRlci1jbG9ja3dpc2VcbiAgICAgICAgICAgIGZvciAodCA9IHN0YXJ0ICsgaW5jOyB0IDwgZW5kOyB0ICs9IGluYykge1xuICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCB0LCAwKTtcbiAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBlbmQsIDApO1xuICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0UG9pbnRPbkxpbmUoZGlzdCwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgdmFyIGZyb21YID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBwMXg7XG4gICAgdmFyIGZyb21ZID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBwMXk7XG4gICAgdmFyIG0gPSAocDJ5IC0gcDF5KSAvIChwMnggLSBwMXggKyBQU0VVRE9fWkVSTyk7XG4gICAgdmFyIHJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAvICgxICsgbSAqIG0pKTtcblxuICAgIGlmIChwMnggPCBwMXgpIHtcbiAgICAgIHJ1biAqPSAtMTtcbiAgICB9XG5cbiAgICB2YXIgcmlzZSA9IG0gKiBydW47XG4gICAgdmFyIHB0ID0gbnVsbDtcblxuICAgIGlmIChwMnggPT09IHAxeCkge1xuICAgICAgLy8gdmVydGljYWwgbGluZVxuICAgICAgcHQgPSB7XG4gICAgICAgIHg6IGZyb21YLFxuICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICgoZnJvbVkgLSBwMXkpIC8gKGZyb21YIC0gcDF4ICsgUFNFVURPX1pFUk8pID09PSBtKSB7XG4gICAgICBwdCA9IHtcbiAgICAgICAgeDogZnJvbVggKyBydW4sXG4gICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl4ID0gMDtcbiAgICAgIHZhciBpeSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxeCwgcDF5LCBwMngsIHAyeSk7XG5cbiAgICAgIGlmIChsZW4gPCBQU0VVRE9fWkVSTykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHUgPSAoZnJvbVggLSBwMXgpICogKHAyeCAtIHAxeCkgKyAoZnJvbVkgLSBwMXkpICogKHAyeSAtIHAxeSk7XG4gICAgICB1IC89IGxlbiAqIGxlbjtcbiAgICAgIGl4ID0gcDF4ICsgdSAqIChwMnggLSBwMXgpO1xuICAgICAgaXkgPSBwMXkgKyB1ICogKHAyeSAtIHAxeSk7XG4gICAgICB2YXIgcFJpc2UgPSB0aGlzLmdldExpbmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBpeCwgaXkpO1xuICAgICAgdmFyIHBSdW4gPSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgLSBwUmlzZSAqIHBSaXNlKTtcbiAgICAgIHJ1biA9IE1hdGguc3FydChwUnVuICogcFJ1biAvICgxICsgbSAqIG0pKTtcblxuICAgICAgaWYgKHAyeCA8IHAxeCkge1xuICAgICAgICBydW4gKj0gLTE7XG4gICAgICB9XG5cbiAgICAgIHJpc2UgPSBtICogcnVuO1xuICAgICAgcHQgPSB7XG4gICAgICAgIHg6IGl4ICsgcnVuLFxuICAgICAgICB5OiBpeSArIHJpc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHB0O1xuICB9XG5cbiAgZ2V0UG9pbnRPblBhdGgoZGlzdGFuY2UpIHtcbiAgICB2YXIgZnVsbExlbiA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgIHZhciBjdW11bGF0aXZlUGF0aExlbmd0aCA9IDA7XG4gICAgdmFyIHAgPSBudWxsO1xuXG4gICAgaWYgKGRpc3RhbmNlIDwgLTAuMDAwMDUgfHwgZGlzdGFuY2UgLSAwLjAwMDA1ID4gZnVsbExlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGRhdGFBcnJheVxuICAgIH0gPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgY29tbWFuZCBvZiBkYXRhQXJyYXkpIHtcbiAgICAgIGlmIChjb21tYW5kICYmIChjb21tYW5kLnBhdGhMZW5ndGggPCAwLjAwMDA1IHx8IGN1bXVsYXRpdmVQYXRoTGVuZ3RoICsgY29tbWFuZC5wYXRoTGVuZ3RoICsgMC4wMDAwNSA8IGRpc3RhbmNlKSkge1xuICAgICAgICBjdW11bGF0aXZlUGF0aExlbmd0aCArPSBjb21tYW5kLnBhdGhMZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsdGEgPSBkaXN0YW5jZSAtIGN1bXVsYXRpdmVQYXRoTGVuZ3RoO1xuICAgICAgdmFyIGN1cnJlbnRUID0gMDtcblxuICAgICAgc3dpdGNoIChjb21tYW5kLnR5cGUpIHtcbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkxpbmUoZGVsdGEsIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55LCBjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGNvbW1hbmQucG9pbnRzWzRdOyAvLyA0ID0gdGhldGFcblxuICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGNvbW1hbmQucG9pbnRzWzVdOyAvLyA1ID0gZFRoZXRhXG5cbiAgICAgICAgICAgIHZhciBlbmQgPSBjb21tYW5kLnBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICAgIGN1cnJlbnRUID0gc3RhcnQgKyBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aCAqIGRUaGV0YTtcblxuICAgICAgICAgICAgaWYgKGRUaGV0YSA8IDAgJiYgY3VycmVudFQgPCBlbmQgfHwgZFRoZXRhID49IDAgJiYgY3VycmVudFQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdLCBjdXJyZW50VCwgY29tbWFuZC5wb2ludHNbNl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICBjdXJyZW50VCA9IGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRUID4gMSkge1xuICAgICAgICAgICAgY3VycmVudFQgPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25DdWJpY0JlemllcihjdXJyZW50VCwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdLCBjb21tYW5kLnBvaW50c1s0XSwgY29tbWFuZC5wb2ludHNbNV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgIGN1cnJlbnRUID0gZGVsdGEgLyBjb21tYW5kLnBhdGhMZW5ndGg7XG5cbiAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICBjdXJyZW50VCA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihjdXJyZW50VCwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHApIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0TGluZUxlbmd0aCh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfVxuXG4gIGdldFBhdGhMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMucGF0aExlbmd0aCA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGF0aExlbmd0aCA9IHRoaXMuZGF0YUFycmF5LnJlZHVjZSgobGVuZ3RoLCBjb21tYW5kKSA9PiBjb21tYW5kLnBhdGhMZW5ndGggPiAwID8gbGVuZ3RoICsgY29tbWFuZC5wYXRoTGVuZ3RoIDogbGVuZ3RoLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXRoTGVuZ3RoO1xuICB9XG5cbiAgZ2V0UG9pbnRPbkN1YmljQmV6aWVyKHBjdCwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICB2YXIgeCA9IHA0eCAqIENCMShwY3QpICsgcDN4ICogQ0IyKHBjdCkgKyBwMnggKiBDQjMocGN0KSArIHAxeCAqIENCNChwY3QpO1xuICAgIHZhciB5ID0gcDR5ICogQ0IxKHBjdCkgKyBwM3kgKiBDQjIocGN0KSArIHAyeSAqIENCMyhwY3QpICsgcDF5ICogQ0I0KHBjdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxuXG4gIGdldFBvaW50T25RdWFkcmF0aWNCZXppZXIocGN0LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgdmFyIHggPSBwM3ggKiBRQjEocGN0KSArIHAyeCAqIFFCMihwY3QpICsgcDF4ICogUUIzKHBjdCk7XG4gICAgdmFyIHkgPSBwM3kgKiBRQjEocGN0KSArIHAyeSAqIFFCMihwY3QpICsgcDF5ICogUUIzKHBjdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxuXG4gIGdldFBvaW50T25FbGxpcHRpY2FsQXJjKGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgcHNpKSB7XG4gICAgdmFyIGNvc1BzaSA9IE1hdGguY29zKHBzaSk7XG4gICAgdmFyIHNpblBzaSA9IE1hdGguc2luKHBzaSk7XG4gICAgdmFyIHB0ID0ge1xuICAgICAgeDogcnggKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICB5OiByeSAqIE1hdGguc2luKHRoZXRhKVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGN4ICsgKHB0LnggKiBjb3NQc2kgLSBwdC55ICogc2luUHNpKSxcbiAgICAgIHk6IGN5ICsgKHB0LnggKiBzaW5Qc2kgKyBwdC55ICogY29zUHNpKVxuICAgIH07XG4gIH0gLy8gVE9ETyBuZWVkIHNvbWUgb3B0aW1pc2F0aW9ucy4gcG9zc2libHkgYnVpbGQgY2FjaGUgb25seSBmb3IgY3VydmVkIHNlZ21lbnRzP1xuXG5cbiAgYnVpbGRFcXVpZGlzdGFudENhY2hlKGlucHV0U3RlcCwgaW5wdXRQcmVjaXNpb24pIHtcbiAgICB2YXIgZnVsbExlbiA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgIHZhciBwcmVjaXNpb24gPSBpbnB1dFByZWNpc2lvbiB8fCAwLjI1OyAvLyBhY2N1cmFjeSB2cyBwZXJmb3JtYW5jZVxuXG4gICAgdmFyIHN0ZXAgPSBpbnB1dFN0ZXAgfHwgZnVsbExlbiAvIDEwMDtcblxuICAgIGlmICghdGhpcy5lcXVpZGlzdGFudENhY2hlIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5zdGVwICE9PSBzdGVwIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wcmVjaXNpb24gIT09IHByZWNpc2lvbikge1xuICAgICAgLy8gUHJlcGFyZSBjYWNoZVxuICAgICAgdGhpcy5lcXVpZGlzdGFudENhY2hlID0ge1xuICAgICAgICBzdGVwLFxuICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgIHBvaW50czogW11cbiAgICAgIH07IC8vIENhbGN1bGF0ZSBwb2ludHNcblxuICAgICAgdmFyIHMgPSAwO1xuXG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8PSBmdWxsTGVuOyBsICs9IHByZWNpc2lvbikge1xuICAgICAgICB2YXIgcDAgPSB0aGlzLmdldFBvaW50T25QYXRoKGwpO1xuICAgICAgICB2YXIgcDEgPSB0aGlzLmdldFBvaW50T25QYXRoKGwgKyBwcmVjaXNpb24pO1xuXG4gICAgICAgIGlmICghcDAgfHwgIXAxKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwMS54LCBwMS55KTtcblxuICAgICAgICBpZiAocyA+PSBzdGVwKSB7XG4gICAgICAgICAgdGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgIHg6IHAwLngsXG4gICAgICAgICAgICB5OiBwMC55LFxuICAgICAgICAgICAgZGlzdGFuY2U6IGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzIC09IHN0ZXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKHRhcmdldERpc3RhbmNlLCBzdGVwLCBwcmVjaXNpb24pIHtcbiAgICB0aGlzLmJ1aWxkRXF1aWRpc3RhbnRDYWNoZShzdGVwLCBwcmVjaXNpb24pO1xuXG4gICAgaWYgKHRhcmdldERpc3RhbmNlIDwgMCB8fCB0YXJnZXREaXN0YW5jZSAtIHRoaXMuZ2V0UGF0aExlbmd0aCgpID4gMC4wMDAwNSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IE1hdGgucm91bmQodGFyZ2V0RGlzdGFuY2UgLyB0aGlzLmdldFBhdGhMZW5ndGgoKSAqICh0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gdGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50c1tpZHhdIHx8IG51bGw7XG4gIH1cblxufVxuXG52YXIgZGF0YVVyaVJlZ2V4ID0gL15cXHMqZGF0YTooKFteLyw7XStcXC9bXi8sO10rKSg/OjsoW14sOz1dKz1bXiw7PV0rKSk/KT8oPzo7KGJhc2U2NCkpPywoLiopJC9pO1xuY2xhc3MgSW1hZ2VFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ltYWdlJztcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHZhciBocmVmID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCk7XG5cbiAgICBpZiAoIWhyZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXNTdmcgPSBocmVmLmVuZHNXaXRoKCcuc3ZnJykgfHwgL15cXHMqZGF0YTppbWFnZVxcL3N2Z1xcK3htbC9pLnRlc3QoaHJlZik7XG4gICAgZG9jdW1lbnQuaW1hZ2VzLnB1c2godGhpcyk7XG5cbiAgICBpZiAoIWlzU3ZnKSB7XG4gICAgICB2b2lkIHRoaXMubG9hZEltYWdlKGhyZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2b2lkIHRoaXMubG9hZFN2ZyhocmVmKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzU3ZnID0gaXNTdmc7XG4gIH1cblxuICBsb2FkSW1hZ2UoaHJlZikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpbWFnZSA9IHlpZWxkIF90aGlzLmRvY3VtZW50LmNyZWF0ZUltYWdlKGhyZWYpO1xuICAgICAgICBfdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlIFxcXCJcIi5jb25jYXQoaHJlZiwgXCJcXFwiOlwiKSwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB9KSgpO1xuICB9XG5cbiAgbG9hZFN2ZyhocmVmKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBtYXRjaCA9IGRhdGFVcmlSZWdleC5leGVjKGhyZWYpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaFs1XTtcblxuICAgICAgICBpZiAobWF0Y2hbNF0gPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgX3RoaXMyLmltYWdlID0gYXRvYihkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuaW1hZ2UgPSBkZWNvZGVVUklDb21wb25lbnQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJlc3BvbnNlID0geWllbGQgX3RoaXMyLmRvY3VtZW50LmZldGNoKGhyZWYpO1xuICAgICAgICAgIHZhciBzdmcgPSB5aWVsZCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgX3RoaXMyLmltYWdlID0gc3ZnO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgbG9hZGluZyBpbWFnZSBcXFwiXCIuY29uY2F0KGhyZWYsIFwiXFxcIjpcIiksIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMyLmxvYWRlZCA9IHRydWU7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGltYWdlLFxuICAgICAgbG9hZGVkXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgIGlmICghbG9hZGVkIHx8ICFpbWFnZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgIGlmICh0aGlzLmlzU3ZnKSB7XG4gICAgICB2YXIgc3ViRG9jdW1lbnQgPSBkb2N1bWVudC5jYW52Zy5mb3JrU3RyaW5nKGN0eCwgdGhpcy5pbWFnZSwge1xuICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBpZ25vcmVEaW1lbnNpb25zOiB0cnVlLFxuICAgICAgICBpZ25vcmVDbGVhcjogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgc2NhbGVXaWR0aDogd2lkdGgsXG4gICAgICAgIHNjYWxlSGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgc3ViRG9jdW1lbnQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnBhcmVudCA9IHRoaXM7XG4gICAgICB2b2lkIHN1YkRvY3VtZW50LnJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2ltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgIGRvY3VtZW50LnNldFZpZXdCb3goe1xuICAgICAgICBjdHgsXG4gICAgICAgIGFzcGVjdFJhdGlvOiB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLmdldFN0cmluZygpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgZGVzaXJlZFdpZHRoOiBfaW1hZ2Uud2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZGVzaXJlZEhlaWdodDogX2ltYWdlLmhlaWdodFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmxvYWRlZCkge1xuICAgICAgICBpZiAodHlwZW9mIF9pbWFnZS5jb21wbGV0ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgX2ltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShfaW1hZ2UsIDAsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGdldEJvdW5kaW5nQm94KCkge1xuICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICB9XG5cbn1cblxuY2xhc3MgU3ltYm9sRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3N5bWJvbCc7XG4gIH1cblxuICByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbn1cblxuY2xhc3MgU1ZHRm9udExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50KSB7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgZG9jdW1lbnQuZm9udHMucHVzaCh0aGlzKTtcbiAgfVxuXG4gIGxvYWQoZm9udEZhbWlseSwgdXJsKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBkb2N1bWVudFxuICAgICAgICB9ID0gX3RoaXM7XG4gICAgICAgIHZhciBzdmdEb2N1bWVudCA9IHlpZWxkIGRvY3VtZW50LmNhbnZnLnBhcnNlci5sb2FkKHVybCk7XG4gICAgICAgIHZhciBmb250cyA9IHN2Z0RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb250Jyk7XG4gICAgICAgIEFycmF5LmZyb20oZm9udHMpLmZvckVhY2goZm9udE5vZGUgPT4ge1xuICAgICAgICAgIHZhciBmb250ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChmb250Tm9kZSk7XG4gICAgICAgICAgZG9jdW1lbnQuZGVmaW5pdGlvbnNbZm9udEZhbWlseV0gPSBmb250O1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgbG9hZGluZyBmb250IFxcXCJcIi5jb25jYXQodXJsLCBcIlxcXCI6XCIpLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH0pKCk7XG4gIH1cblxufVxuXG5jbGFzcyBTdHlsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3N0eWxlJztcbiAgICB2YXIgY3NzID0gY29tcHJlc3NTcGFjZXMoQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpIC8vIE5FRUQgVEVTVFxuICAgIC5tYXAoXyA9PiBfLnRleHRDb250ZW50KS5qb2luKCcnKS5yZXBsYWNlKC8oXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qL118W1xcclxcbl0pKSkqXFwqK1xcLyl8KF5bXFxzXSpcXC9cXC8uKikvZ20sICcnKSAvLyByZW1vdmUgY29tbWVudHNcbiAgICAucmVwbGFjZSgvQGltcG9ydC4qOy9nLCAnJykgLy8gcmVtb3ZlIGltcG9ydHNcbiAgICApO1xuICAgIHZhciBjc3NEZWZzID0gY3NzLnNwbGl0KCd9Jyk7XG4gICAgY3NzRGVmcy5mb3JFYWNoKF8gPT4ge1xuICAgICAgdmFyIGRlZiA9IF8udHJpbSgpO1xuXG4gICAgICBpZiAoIWRlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjc3NQYXJ0cyA9IGRlZi5zcGxpdCgneycpO1xuICAgICAgdmFyIGNzc0NsYXNzZXMgPSBjc3NQYXJ0c1swXS5zcGxpdCgnLCcpO1xuICAgICAgdmFyIGNzc1Byb3BzID0gY3NzUGFydHNbMV0uc3BsaXQoJzsnKTtcbiAgICAgIGNzc0NsYXNzZXMuZm9yRWFjaChfID0+IHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gXy50cmltKCk7XG5cbiAgICAgICAgaWYgKCFjc3NDbGFzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wcyA9IGRvY3VtZW50LnN0eWxlc1tjc3NDbGFzc10gfHwge307XG4gICAgICAgIGNzc1Byb3BzLmZvckVhY2goY3NzUHJvcCA9PiB7XG4gICAgICAgICAgdmFyIHByb3AgPSBjc3NQcm9wLmluZGV4T2YoJzonKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGNzc1Byb3Auc3Vic3RyKDAsIHByb3ApLnRyaW0oKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjc3NQcm9wLnN1YnN0cihwcm9wICsgMSwgY3NzUHJvcC5sZW5ndGggLSBwcm9wKS50cmltKCk7XG5cbiAgICAgICAgICBpZiAobmFtZSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5zdHlsZXNbY3NzQ2xhc3NdID0gcHJvcHM7XG4gICAgICAgIGRvY3VtZW50LnN0eWxlc1NwZWNpZmljaXR5W2Nzc0NsYXNzXSA9IGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoY3NzQ2xhc3MpO1xuXG4gICAgICAgIGlmIChjc3NDbGFzcyA9PT0gJ0Bmb250LWZhY2UnKSB7XG4gICAgICAgICAgLy8gICYmICFub2RlRW52XG4gICAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBwcm9wc1snZm9udC1mYW1pbHknXS5nZXRTdHJpbmcoKS5yZXBsYWNlKC9cInwnL2csICcnKTtcbiAgICAgICAgICB2YXIgc3JjcyA9IHByb3BzLnNyYy5nZXRTdHJpbmcoKS5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNyY3MuZm9yRWFjaChzcmMgPT4ge1xuICAgICAgICAgICAgaWYgKHNyYy5pbmRleE9mKCdmb3JtYXQoXCJzdmdcIiknKSA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHVybCA9IHBhcnNlRXh0ZXJuYWxVcmwoc3JjKTtcblxuICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgdm9pZCBuZXcgU1ZHRm9udExvYWRlcihkb2N1bWVudCkubG9hZChmb250RmFtaWx5LCB1cmwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cblN0eWxlRWxlbWVudC5wYXJzZUV4dGVybmFsVXJsID0gcGFyc2VFeHRlcm5hbFVybDtcblxuY2xhc3MgVXNlRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3VzZSc7XG4gIH1cblxuICBzZXRDb250ZXh0KGN0eCkge1xuICAgIHN1cGVyLnNldENvbnRleHQoY3R4KTtcbiAgICB2YXIgeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgIHZhciB5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5Jyk7XG5cbiAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4QXR0ci5nZXRQaXhlbHMoJ3gnKSwgMCk7XG4gICAgfVxuXG4gICAgaWYgKHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGN0eC50cmFuc2xhdGUoMCwgeUF0dHIuZ2V0UGl4ZWxzKCd5JykpO1xuICAgIH1cbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnBhdGgoY3R4KTtcbiAgICB9XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBlbGVtZW50XG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIHRlbXBTdmcgPSBlbGVtZW50O1xuXG4gICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnQgaW4gc3ltYm9sIGNhc2VzIChodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjVXNlRWxlbWVudClcbiAgICAgICAgdGVtcFN2ZyA9IG5ldyBTVkdFbGVtZW50KGRvY3VtZW50LCBudWxsKTtcbiAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd2aWV3Qm94JywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5wcmVzZXJ2ZUFzcGVjdFJhdGlvID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAncHJlc2VydmVBc3BlY3RSYXRpbycsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMub3ZlcmZsb3cgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdvdmVyZmxvdycsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvdmVyZmxvdycpLmdldFN0cmluZygpKTtcbiAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47IC8vIGVsZW1lbnQgaXMgc3RpbGwgdGhlIHBhcmVudCBvZiB0aGUgY2hpbGRyZW5cblxuICAgICAgICBlbGVtZW50LnN0eWxlcy5vcGFjaXR5ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnb3BhY2l0eScsIHRoaXMuY2FsY3VsYXRlT3BhY2l0eSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRlbXBTdmcudHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgdmFyIHdpZHRoU3R5bGUgPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdmFyIGhlaWdodFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JywgZmFsc2UsIHRydWUpOyAvLyBpZiBzeW1ib2wgb3Igc3ZnLCBpbmhlcml0IHdpZHRoL2hlaWdodCBmcm9tIG1lXG5cbiAgICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgd2lkdGhTdHlsZS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdoZWlnaHQnLCBoZWlnaHRTdHlsZS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG9sZFBhcmVudCA9IHRlbXBTdmcucGFyZW50O1xuICAgICAgdGVtcFN2Zy5wYXJlbnQgPSB0aGlzO1xuICAgICAgdGVtcFN2Zy5yZW5kZXIoY3R4KTtcbiAgICAgIHRlbXBTdmcucGFyZW50ID0gb2xkUGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGVsZW1lbnRUcmFuc2Zvcm0oKSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgZWxlbWVudFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGVsZW1lbnQpO1xuICB9XG5cbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlZEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY2FjaGVkRWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jYWNoZWRFbGVtZW50O1xuICB9XG5cbn1cblxuZnVuY3Rpb24gaW1HZXQoaW1nLCB4LCB5LCB3aWR0aCwgX2hlaWdodCwgcmdiYSkge1xuICByZXR1cm4gaW1nW3kgKiB3aWR0aCAqIDQgKyB4ICogNCArIHJnYmFdO1xufVxuXG5mdW5jdGlvbiBpbVNldChpbWcsIHgsIHksIHdpZHRoLCBfaGVpZ2h0LCByZ2JhLCB2YWwpIHtcbiAgaW1nW3kgKiB3aWR0aCAqIDQgKyB4ICogNCArIHJnYmFdID0gdmFsO1xufVxuXG5mdW5jdGlvbiBtKG1hdHJpeCwgaSwgdikge1xuICB2YXIgbWkgPSBtYXRyaXhbaV07XG4gIHJldHVybiBtaSAqIHY7XG59XG5cbmZ1bmN0aW9uIGMoYSwgbTEsIG0yLCBtMykge1xuICByZXR1cm4gbTEgKyBNYXRoLmNvcyhhKSAqIG0yICsgTWF0aC5zaW4oYSkgKiBtMztcbn1cblxuY2xhc3MgRmVDb2xvck1hdHJpeEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlQ29sb3JNYXRyaXgnO1xuICAgIHZhciBtYXRyaXggPSB0b051bWJlcnModGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlcycpLmdldFN0cmluZygpKTtcblxuICAgIHN3aXRjaCAodGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKS5nZXRTdHJpbmcoJ21hdHJpeCcpKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvZmlsdGVycy5odG1sI2ZlQ29sb3JNYXRyaXhFbGVtZW50XG4gICAgICBjYXNlICdzYXR1cmF0ZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcyA9IG1hdHJpeFswXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICAgIG1hdHJpeCA9IFswLjIxMyArIDAuNzg3ICogcywgMC43MTUgLSAwLjcxNSAqIHMsIDAuMDcyIC0gMC4wNzIgKiBzLCAwLCAwLCAwLjIxMyAtIDAuMjEzICogcywgMC43MTUgKyAwLjI4NSAqIHMsIDAuMDcyIC0gMC4wNzIgKiBzLCAwLCAwLCAwLjIxMyAtIDAuMjEzICogcywgMC43MTUgLSAwLjcxNSAqIHMsIDAuMDcyICsgMC45MjggKiBzLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaHVlUm90YXRlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBhID0gbWF0cml4WzBdICogTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgbWF0cml4ID0gW2MoYSwgMC4yMTMsIDAuNzg3LCAtMC4yMTMpLCBjKGEsIDAuNzE1LCAtMC43MTUsIC0wLjcxNSksIGMoYSwgMC4wNzIsIC0wLjA3MiwgMC45MjgpLCAwLCAwLCBjKGEsIDAuMjEzLCAtMC4yMTMsIDAuMTQzKSwgYyhhLCAwLjcxNSwgMC4yODUsIDAuMTQwKSwgYyhhLCAwLjA3MiwgLTAuMDcyLCAtMC4yODMpLCAwLCAwLCBjKGEsIDAuMjEzLCAtMC4yMTMsIC0wLjc4NyksIGMoYSwgMC43MTUsIC0wLjcxNSwgMC43MTUpLCBjKGEsIDAuMDcyLCAwLjkyOCwgMC4wNzIpLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbHVtaW5hbmNlVG9BbHBoYSc6XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuICAgICAgICBtYXRyaXggPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSwgMCwgMCwgMCwgMCwgMCwgMCwgMV07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgdGhpcy5pbmNsdWRlT3BhY2l0eSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpbmNsdWRlT3BhY2l0eScpLmhhc1ZhbHVlKCk7XG4gIH1cblxuICBhcHBseShjdHgsIF94LCBfeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIC8vIGFzc3VtaW5nIHg9PTAgJiYgeT09MCBmb3Igbm93XG4gICAgdmFyIHtcbiAgICAgIGluY2x1ZGVPcGFjaXR5LFxuICAgICAgbWF0cml4XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHNyY0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIHZhciByID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwKTtcbiAgICAgICAgdmFyIGcgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEpO1xuICAgICAgICB2YXIgYiA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMik7XG4gICAgICAgIHZhciBhID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzKTtcbiAgICAgICAgdmFyIG5yID0gbShtYXRyaXgsIDAsIHIpICsgbShtYXRyaXgsIDEsIGcpICsgbShtYXRyaXgsIDIsIGIpICsgbShtYXRyaXgsIDMsIGEpICsgbShtYXRyaXgsIDQsIDEpO1xuICAgICAgICB2YXIgbmcgPSBtKG1hdHJpeCwgNSwgcikgKyBtKG1hdHJpeCwgNiwgZykgKyBtKG1hdHJpeCwgNywgYikgKyBtKG1hdHJpeCwgOCwgYSkgKyBtKG1hdHJpeCwgOSwgMSk7XG4gICAgICAgIHZhciBuYiA9IG0obWF0cml4LCAxMCwgcikgKyBtKG1hdHJpeCwgMTEsIGcpICsgbShtYXRyaXgsIDEyLCBiKSArIG0obWF0cml4LCAxMywgYSkgKyBtKG1hdHJpeCwgMTQsIDEpO1xuICAgICAgICB2YXIgbmEgPSBtKG1hdHJpeCwgMTUsIHIpICsgbShtYXRyaXgsIDE2LCBnKSArIG0obWF0cml4LCAxNywgYikgKyBtKG1hdHJpeCwgMTgsIGEpICsgbShtYXRyaXgsIDE5LCAxKTtcblxuICAgICAgICBpZiAoaW5jbHVkZU9wYWNpdHkpIHtcbiAgICAgICAgICBuciA9IDA7XG4gICAgICAgICAgbmcgPSAwO1xuICAgICAgICAgIG5iID0gMDtcbiAgICAgICAgICBuYSAqPSBhIC8gMjU1O1xuICAgICAgICB9XG5cbiAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCBucik7XG4gICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSwgbmcpO1xuICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIsIG5iKTtcbiAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzLCBuYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKHNyY0RhdGEsIDAsIDApO1xuICB9XG5cbn1cblxuY2xhc3MgTWFza0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnbWFzayc7XG4gIH1cblxuICBhcHBseShjdHgsIGVsZW1lbnQpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRcbiAgICB9ID0gdGhpczsgLy8gcmVuZGVyIGFzIHRlbXAgc3ZnXG5cbiAgICB2YXIgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuXG4gICAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCkpO1xuICAgICAgfSk7XG4gICAgICB4ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC54MSk7XG4gICAgICB5ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC55MSk7XG4gICAgICB3aWR0aCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gud2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC5oZWlnaHQpO1xuICAgIH1cblxuICAgIHZhciBpZ25vcmVkU3R5bGVzID0gdGhpcy5yZW1vdmVTdHlsZXMoZWxlbWVudCwgTWFza0VsZW1lbnQuaWdub3JlU3R5bGVzKTtcbiAgICB2YXIgbWFza0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIHZhciBtYXNrQ3R4ID0gbWFza0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyhtYXNrQ3R4KTtcbiAgICB0aGlzLnJlbmRlckNoaWxkcmVuKG1hc2tDdHgpOyAvLyBjb252ZXJ0IG1hc2sgdG8gYWxwaGEgd2l0aCBhIGZha2Ugbm9kZVxuICAgIC8vIFRPRE86IHJlZmFjdG9yIG91dCBhcHBseSBmcm9tIGZlQ29sb3JNYXRyaXhcblxuICAgIG5ldyBGZUNvbG9yTWF0cml4RWxlbWVudChkb2N1bWVudCwge1xuICAgICAgbm9kZVR5cGU6IDEsXG4gICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgIGF0dHJpYnV0ZXM6IFt7XG4gICAgICAgIG5vZGVOYW1lOiAndHlwZScsXG4gICAgICAgIHZhbHVlOiAnbHVtaW5hbmNlVG9BbHBoYSdcbiAgICAgIH0sIHtcbiAgICAgICAgbm9kZU5hbWU6ICdpbmNsdWRlT3BhY2l0eScsXG4gICAgICAgIHZhbHVlOiAndHJ1ZSdcbiAgICAgIH1dXG4gICAgfSkuYXBwbHkobWFza0N0eCwgMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB2YXIgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyh0bXBDdHgpO1xuICAgIGVsZW1lbnQucmVuZGVyKHRtcEN0eCk7XG4gICAgdG1wQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgdG1wQ3R4LmZpbGxTdHlsZSA9IG1hc2tDdHguY3JlYXRlUGF0dGVybihtYXNrQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRtcEN0eC5jcmVhdGVQYXR0ZXJuKHRtcENhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpOyAvLyByZWFzc2lnbiBtYXNrXG5cbiAgICB0aGlzLnJlc3RvcmVTdHlsZXMoZWxlbWVudCwgaWdub3JlZFN0eWxlcyk7XG4gIH1cblxuICByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbn1cbk1hc2tFbGVtZW50Lmlnbm9yZVN0eWxlcyA9IFsnbWFzaycsICd0cmFuc2Zvcm0nLCAnY2xpcC1wYXRoJ107XG5cbnZhciBub29wID0gKCkgPT4gey8vIE5PT1Bcbn07XG5cbmNsYXNzIENsaXBQYXRoRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdjbGlwUGF0aCc7XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgY29udGV4dFByb3RvID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihjdHgpO1xuICAgIHZhciB7XG4gICAgICBiZWdpblBhdGgsXG4gICAgICBjbG9zZVBhdGhcbiAgICB9ID0gY3R4O1xuXG4gICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgY29udGV4dFByb3RvLmJlZ2luUGF0aCA9IG5vb3A7XG4gICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gbm9vcDtcbiAgICB9XG5cbiAgICBSZWZsZWN0LmFwcGx5KGJlZ2luUGF0aCwgY3R4LCBbXSk7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQucGF0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhbnNmb3JtID0gdHlwZW9mIGNoaWxkLmVsZW1lbnRUcmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnID8gY2hpbGQuZWxlbWVudFRyYW5zZm9ybSgpIDogbnVsbDsgLy8gaGFuZGxlIDx1c2UgLz5cblxuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtID0gVHJhbnNmb3JtLmZyb21FbGVtZW50KGRvY3VtZW50LCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLnBhdGgoY3R4KTtcblxuICAgICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gY2xvc2VQYXRoO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRyYW5zZm9ybS51bmFwcGx5KGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgUmVmbGVjdC5hcHBseShjbG9zZVBhdGgsIGN0eCwgW10pO1xuICAgIGN0eC5jbGlwKCk7XG5cbiAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICBjb250ZXh0UHJvdG8uYmVnaW5QYXRoID0gYmVnaW5QYXRoO1xuICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IGNsb3NlUGF0aDtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICB9XG5cbn1cblxuY2xhc3MgRmlsdGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdmaWx0ZXInO1xuICB9XG5cbiAgYXBwbHkoY3R4LCBlbGVtZW50KSB7XG4gICAgLy8gcmVuZGVyIGFzIHRlbXAgc3ZnXG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gdGhpcztcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCk7XG5cbiAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHB4ID0gMDtcbiAgICB2YXIgcHkgPSAwO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgdmFyIGVmZCA9IGNoaWxkLmV4dHJhRmlsdGVyRGlzdGFuY2UgfHwgMDtcbiAgICAgIHB4ID0gTWF0aC5tYXgocHgsIGVmZCk7XG4gICAgICBweSA9IE1hdGgubWF4KHB5LCBlZmQpO1xuICAgIH0pO1xuICAgIHZhciB3aWR0aCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gud2lkdGgpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgdmFyIHRtcENhbnZhc1dpZHRoID0gd2lkdGggKyAyICogcHg7XG4gICAgdmFyIHRtcENhbnZhc0hlaWdodCA9IGhlaWdodCArIDIgKiBweTtcblxuICAgIGlmICh0bXBDYW52YXNXaWR0aCA8IDEgfHwgdG1wQ2FudmFzSGVpZ2h0IDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC54KTtcbiAgICB2YXIgeSA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueSk7XG4gICAgdmFyIGlnbm9yZWRTdHlsZXMgPSB0aGlzLnJlbW92ZVN0eWxlcyhlbGVtZW50LCBGaWx0ZXJFbGVtZW50Lmlnbm9yZVN0eWxlcyk7XG4gICAgdmFyIHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKHRtcEN0eCk7XG4gICAgdG1wQ3R4LnRyYW5zbGF0ZSgteCArIHB4LCAteSArIHB5KTtcbiAgICBlbGVtZW50LnJlbmRlcih0bXBDdHgpOyAvLyBhcHBseSBmaWx0ZXJzXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQuYXBwbHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2hpbGQuYXBwbHkodG1wQ3R4LCAwLCAwLCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gcmVuZGVyIG9uIG1lXG5cbiAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgMCwgMCwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCwgeCAtIHB4LCB5IC0gcHksIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgIHRoaXMucmVzdG9yZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVkU3R5bGVzKTtcbiAgfVxuXG4gIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuRmlsdGVyRWxlbWVudC5pZ25vcmVTdHlsZXMgPSBbJ2ZpbHRlcicsICd0cmFuc2Zvcm0nLCAnY2xpcC1wYXRoJ107XG5cbmNsYXNzIEZlRHJvcFNoYWRvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlRHJvcFNoYWRvdyc7XG4gICAgdGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XG4gIH1cblxuICBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkgey8vIFRPRE86IGltcGxlbWVudFxuICB9XG5cbn1cblxuY2xhc3MgRmVNb3JwaG9sb2d5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdmZU1vcnBob2xvZ3knO1xuICB9XG5cbiAgYXBwbHkoXywgX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpIHsvLyBUT0RPOiBpbXBsZW1lbnRcbiAgfVxuXG59XG5cbmNsYXNzIEZlQ29tcG9zaXRlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdmZUNvbXBvc2l0ZSc7XG4gIH1cblxuICBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkgey8vIFRPRE86IGltcGxlbWVudFxuICB9XG5cbn1cblxuY2xhc3MgRmVHYXVzc2lhbkJsdXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdmZUdhdXNzaWFuQmx1cic7XG4gICAgdGhpcy5ibHVyUmFkaXVzID0gTWF0aC5mbG9vcih0aGlzLmdldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJykuZ2V0TnVtYmVyKCkpO1xuICAgIHRoaXMuZXh0cmFGaWx0ZXJEaXN0YW5jZSA9IHRoaXMuYmx1clJhZGl1cztcbiAgfVxuXG4gIGFwcGx5KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGJsdXJSYWRpdXNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LndpbmRvdyA/IGRvY3VtZW50LndpbmRvdy5kb2N1bWVudC5ib2R5IDogbnVsbDtcbiAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhczsgLy8gU3RhY2tCbHVyIHJlcXVpcmVzIGNhbnZhcyBiZSBvbiBkb2N1bWVudFxuXG4gICAgY2FudmFzLmlkID0gZG9jdW1lbnQuZ2V0VW5pcXVlSWQoKTtcblxuICAgIGlmIChib2R5KSB7XG4gICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICB9XG5cbiAgICBjYW52YXNSR0JBKGNhbnZhcywgeCwgeSwgd2lkdGgsIGhlaWdodCwgYmx1clJhZGl1cyk7XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgYm9keS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgIH1cbiAgfVxuXG59XG5cbmNsYXNzIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICd0aXRsZSc7XG4gIH1cblxufVxuXG5jbGFzcyBEZXNjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdkZXNjJztcbiAgfVxuXG59XG5cbnZhciBlbGVtZW50cyA9IHtcbiAgJ3N2Zyc6IFNWR0VsZW1lbnQsXG4gICdyZWN0JzogUmVjdEVsZW1lbnQsXG4gICdjaXJjbGUnOiBDaXJjbGVFbGVtZW50LFxuICAnZWxsaXBzZSc6IEVsbGlwc2VFbGVtZW50LFxuICAnbGluZSc6IExpbmVFbGVtZW50LFxuICAncG9seWxpbmUnOiBQb2x5bGluZUVsZW1lbnQsXG4gICdwb2x5Z29uJzogUG9seWdvbkVsZW1lbnQsXG4gICdwYXRoJzogUGF0aEVsZW1lbnQsXG4gICdwYXR0ZXJuJzogUGF0dGVybkVsZW1lbnQsXG4gICdtYXJrZXInOiBNYXJrZXJFbGVtZW50LFxuICAnZGVmcyc6IERlZnNFbGVtZW50LFxuICAnbGluZWFyR3JhZGllbnQnOiBMaW5lYXJHcmFkaWVudEVsZW1lbnQsXG4gICdyYWRpYWxHcmFkaWVudCc6IFJhZGlhbEdyYWRpZW50RWxlbWVudCxcbiAgJ3N0b3AnOiBTdG9wRWxlbWVudCxcbiAgJ2FuaW1hdGUnOiBBbmltYXRlRWxlbWVudCxcbiAgJ2FuaW1hdGVDb2xvcic6IEFuaW1hdGVDb2xvckVsZW1lbnQsXG4gICdhbmltYXRlVHJhbnNmb3JtJzogQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQsXG4gICdmb250JzogRm9udEVsZW1lbnQsXG4gICdmb250LWZhY2UnOiBGb250RmFjZUVsZW1lbnQsXG4gICdtaXNzaW5nLWdseXBoJzogTWlzc2luZ0dseXBoRWxlbWVudCxcbiAgJ2dseXBoJzogR2x5cGhFbGVtZW50LFxuICAndGV4dCc6IFRleHRFbGVtZW50LFxuICAndHNwYW4nOiBUU3BhbkVsZW1lbnQsXG4gICd0cmVmJzogVFJlZkVsZW1lbnQsXG4gICdhJzogQUVsZW1lbnQsXG4gICd0ZXh0UGF0aCc6IFRleHRQYXRoRWxlbWVudCxcbiAgJ2ltYWdlJzogSW1hZ2VFbGVtZW50LFxuICAnZyc6IEdFbGVtZW50LFxuICAnc3ltYm9sJzogU3ltYm9sRWxlbWVudCxcbiAgJ3N0eWxlJzogU3R5bGVFbGVtZW50LFxuICAndXNlJzogVXNlRWxlbWVudCxcbiAgJ21hc2snOiBNYXNrRWxlbWVudCxcbiAgJ2NsaXBQYXRoJzogQ2xpcFBhdGhFbGVtZW50LFxuICAnZmlsdGVyJzogRmlsdGVyRWxlbWVudCxcbiAgJ2ZlRHJvcFNoYWRvdyc6IEZlRHJvcFNoYWRvd0VsZW1lbnQsXG4gICdmZU1vcnBob2xvZ3knOiBGZU1vcnBob2xvZ3lFbGVtZW50LFxuICAnZmVDb21wb3NpdGUnOiBGZUNvbXBvc2l0ZUVsZW1lbnQsXG4gICdmZUNvbG9yTWF0cml4JzogRmVDb2xvck1hdHJpeEVsZW1lbnQsXG4gICdmZUdhdXNzaWFuQmx1cic6IEZlR2F1c3NpYW5CbHVyRWxlbWVudCxcbiAgJ3RpdGxlJzogVGl0bGVFbGVtZW50LFxuICAnZGVzYyc6IERlc2NFbGVtZW50XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW1hZ2UoX3gpIHtcbiAgcmV0dXJuIF9jcmVhdGVJbWFnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlSW1hZ2UoKSB7XG4gIF9jcmVhdGVJbWFnZSA9IF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoc3JjKSB7XG4gICAgdmFyIGFub255bW91c0Nyb3NzT3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgIGlmIChhbm9ueW1vdXNDcm9zc09yaWdpbikge1xuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGltYWdlKTtcbiAgICAgIH07XG5cbiAgICAgIGltYWdlLm9uZXJyb3IgPSAoX2V2ZW50LCBfc291cmNlLCBfbGluZW5vLCBfY29sbm8sIGVycm9yKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9O1xuXG4gICAgICBpbWFnZS5zcmMgPSBzcmM7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gX2NyZWF0ZUltYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmNsYXNzIERvY3VtZW50IHtcbiAgY29uc3RydWN0b3IoY2FudmcpIHtcbiAgICB2YXIge1xuICAgICAgcm9vdEVtU2l6ZSA9IDEyLFxuICAgICAgZW1TaXplID0gMTIsXG4gICAgICBjcmVhdGVDYW52YXMgPSBEb2N1bWVudC5jcmVhdGVDYW52YXMsXG4gICAgICBjcmVhdGVJbWFnZSA9IERvY3VtZW50LmNyZWF0ZUltYWdlLFxuICAgICAgYW5vbnltb3VzQ3Jvc3NPcmlnaW5cbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmNhbnZnID0gY2Fudmc7XG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3R5bGVzU3BlY2lmaWNpdHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuaW1hZ2VzID0gW107XG4gICAgdGhpcy5mb250cyA9IFtdO1xuICAgIHRoaXMuZW1TaXplU3RhY2sgPSBbXTtcbiAgICB0aGlzLnVuaXF1ZUlkID0gMDtcbiAgICB0aGlzLnNjcmVlbiA9IGNhbnZnLnNjcmVlbjtcbiAgICB0aGlzLnJvb3RFbVNpemUgPSByb290RW1TaXplO1xuICAgIHRoaXMuZW1TaXplID0gZW1TaXplO1xuICAgIHRoaXMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuICAgIHRoaXMuY3JlYXRlSW1hZ2UgPSB0aGlzLmJpbmRDcmVhdGVJbWFnZShjcmVhdGVJbWFnZSwgYW5vbnltb3VzQ3Jvc3NPcmlnaW4pO1xuICAgIHRoaXMuc2NyZWVuLndhaXQodGhpcy5pc0ltYWdlc0xvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNjcmVlbi53YWl0KHRoaXMuaXNGb250c0xvYWRlZC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGJpbmRDcmVhdGVJbWFnZShjcmVhdGVJbWFnZSwgYW5vbnltb3VzQ3Jvc3NPcmlnaW4pIHtcbiAgICBpZiAodHlwZW9mIGFub255bW91c0Nyb3NzT3JpZ2luID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiAoc291cmNlLCBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luKSA9PiBjcmVhdGVJbWFnZShzb3VyY2UsIHR5cGVvZiBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luID09PSAnYm9vbGVhbicgPyBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luIDogYW5vbnltb3VzQ3Jvc3NPcmlnaW4pO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVJbWFnZTtcbiAgfVxuXG4gIGdldCB3aW5kb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLndpbmRvdztcbiAgfVxuXG4gIGdldCBmZXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4uZmV0Y2g7XG4gIH1cblxuICBnZXQgY3R4KCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi5jdHg7XG4gIH1cblxuICBnZXQgZW1TaXplKCkge1xuICAgIHZhciB7XG4gICAgICBlbVNpemVTdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBlbVNpemVTdGFja1tlbVNpemVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHNldCBlbVNpemUodmFsdWUpIHtcbiAgICB2YXIge1xuICAgICAgZW1TaXplU3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBlbVNpemVTdGFjay5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHBvcEVtU2l6ZSgpIHtcbiAgICB2YXIge1xuICAgICAgZW1TaXplU3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBlbVNpemVTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGdldFVuaXF1ZUlkKCkge1xuICAgIHJldHVybiBcImNhbnZnXCIuY29uY2F0KCsrdGhpcy51bmlxdWVJZCk7XG4gIH1cblxuICBpc0ltYWdlc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZXMuZXZlcnkoXyA9PiBfLmxvYWRlZCk7XG4gIH1cblxuICBpc0ZvbnRzTG9hZGVkKCkge1xuICAgIHJldHVybiB0aGlzLmZvbnRzLmV2ZXJ5KF8gPT4gXy5sb2FkZWQpO1xuICB9XG5cbiAgY3JlYXRlRG9jdW1lbnRFbGVtZW50KGRvY3VtZW50KSB7XG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IHRoaXMuY3JlYXRlRWxlbWVudChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIGRvY3VtZW50RWxlbWVudC5yb290ID0gdHJ1ZTtcbiAgICBkb2N1bWVudEVsZW1lbnQuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpO1xuICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnRFbGVtZW50O1xuICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICBjcmVhdGVFbGVtZW50KG5vZGUpIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBub2RlLm5vZGVOYW1lLnJlcGxhY2UoL15bXjpdKzovLCAnJyk7XG4gICAgdmFyIEVsZW1lbnRUeXBlID0gRG9jdW1lbnQuZWxlbWVudFR5cGVzW2VsZW1lbnRUeXBlXTtcblxuICAgIGlmICh0eXBlb2YgRWxlbWVudFR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IEVsZW1lbnRUeXBlKHRoaXMsIG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVW5rbm93bkVsZW1lbnQodGhpcywgbm9kZSk7XG4gIH1cblxuICBjcmVhdGVUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLCBub2RlKTtcbiAgfVxuXG4gIHNldFZpZXdCb3goY29uZmlnKSB7XG4gICAgdGhpcy5zY3JlZW4uc2V0Vmlld0JveChfb2JqZWN0U3ByZWFkJDEoe1xuICAgICAgZG9jdW1lbnQ6IHRoaXNcbiAgICB9LCBjb25maWcpKTtcbiAgfVxuXG59XG5Eb2N1bWVudC5jcmVhdGVDYW52YXMgPSBjcmVhdGVDYW52YXM7XG5Eb2N1bWVudC5jcmVhdGVJbWFnZSA9IGNyZWF0ZUltYWdlO1xuRG9jdW1lbnQuZWxlbWVudFR5cGVzID0gZWxlbWVudHM7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBTVkcgcmVuZGVyZXIgb24gY2FudmFzLlxyXG4gKi9cblxuY2xhc3MgQ2Fudmcge1xuICAvKipcclxuICAgKiBNYWluIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIERvY3VtZW50LlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGN0eCwgc3ZnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICB0aGlzLnNjcmVlbiA9IG5ldyBTY3JlZW4oY3R4LCBvcHRpb25zKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBkb2N1bWVudCA9IG5ldyBEb2N1bWVudCh0aGlzLCBvcHRpb25zKTtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRFbGVtZW50KHN2Zyk7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBDYW52ZyBpbnN0YW5jZSBmcm9tIFNWRyBzb3VyY2Ugc3RyaW5nIG9yIFVSTC5cclxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nIG9yIFVSTC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxyXG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb20oY3R4LCBzdmcpIHtcbiAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gX2FyZ3VtZW50cy5sZW5ndGggPiAyICYmIF9hcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgdmFyIHN2Z0RvY3VtZW50ID0geWllbGQgcGFyc2VyLnBhcnNlKHN2Zyk7XG4gICAgICByZXR1cm4gbmV3IENhbnZnKGN0eCwgc3ZnRG9jdW1lbnQsIG9wdGlvbnMpO1xuICAgIH0pKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIENhbnZnIGluc3RhbmNlIGZyb20gU1ZHIHNvdXJjZSBzdHJpbmcuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZy5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxyXG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21TdHJpbmcoY3R4LCBzdmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgdmFyIHN2Z0RvY3VtZW50ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmcpO1xuICAgIHJldHVybiBuZXcgQ2FudmcoY3R4LCBzdmdEb2N1bWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBDYW52ZyBpbnN0YW5jZSB3aXRoIGluaGVyaXRlZCBvcHRpb25zLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBmb3JrKGN0eCwgc3ZnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBDYW52Zy5mcm9tKGN0eCwgc3ZnLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IENhbnZnIGluc3RhbmNlIHdpdGggaW5oZXJpdGVkIG9wdGlvbnMuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZy5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxyXG4gICAqL1xuXG5cbiAgZm9ya1N0cmluZyhjdHgsIHN2Zykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gQ2FudmcuZnJvbVN0cmluZyhjdHgsIHN2ZywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRG9jdW1lbnQgaXMgcmVhZHkgcHJvbWlzZS5cclxuICAgKiBAcmV0dXJucyBSZWFkeSBwcm9taXNlLlxyXG4gICAqL1xuXG5cbiAgcmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLnJlYWR5KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogRG9jdW1lbnQgaXMgcmVhZHkgdmFsdWUuXHJcbiAgICogQHJldHVybnMgSXMgcmVhZHkgb3Igbm90LlxyXG4gICAqL1xuXG5cbiAgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4uaXNSZWFkeSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbmRlciBvbmx5IGZpcnN0IGZyYW1lLCBpZ25vcmluZyBhbmltYXRpb25zIGFuZCBtb3VzZS5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqL1xuXG5cbiAgcmVuZGVyKCkge1xuICAgIHZhciBfYXJndW1lbnRzMiA9IGFyZ3VtZW50cyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IF9hcmd1bWVudHMyLmxlbmd0aCA+IDAgJiYgX2FyZ3VtZW50czJbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmd1bWVudHMyWzBdIDoge307XG5cbiAgICAgIF90aGlzLnN0YXJ0KF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBlbmFibGVSZWRyYXc6IHRydWUsXG4gICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgaWdub3JlTW91c2U6IHRydWVcbiAgICAgIH0sIG9wdGlvbnMpKTtcblxuICAgICAgeWllbGQgX3RoaXMucmVhZHkoKTtcblxuICAgICAgX3RoaXMuc3RvcCgpO1xuICAgIH0pKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RhcnQgcmVuZGVyaW5nLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyIG9wdGlvbnMuXHJcbiAgICovXG5cblxuICBzdGFydCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNjcmVlbixcbiAgICAgIG9wdGlvbnM6IGJhc2VPcHRpb25zXG4gICAgfSA9IHRoaXM7XG4gICAgc2NyZWVuLnN0YXJ0KGRvY3VtZW50RWxlbWVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIGVuYWJsZVJlZHJhdzogdHJ1ZVxuICAgIH0sIGJhc2VPcHRpb25zKSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0b3AgcmVuZGVyaW5nLlxyXG4gICAqL1xuXG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnNjcmVlbi5zdG9wKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzaXplIFNWRyB0byBmaXQgaW4gZ2l2ZW4gc2l6ZS5cclxuICAgKiBAcGFyYW0gd2lkdGhcclxuICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICogQHBhcmFtIHByZXNlcnZlQXNwZWN0UmF0aW9cclxuICAgKi9cblxuXG4gIHJlc2l6ZSh3aWR0aCkge1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHdpZHRoO1xuICAgIHZhciBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudC5yZXNpemUod2lkdGgsIGhlaWdodCwgcHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gIH1cblxufVxuXG5leHBvcnQgeyBBRWxlbWVudCwgQW5pbWF0ZUNvbG9yRWxlbWVudCwgQW5pbWF0ZUVsZW1lbnQsIEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50LCBCb3VuZGluZ0JveCwgQ0IxLCBDQjIsIENCMywgQ0I0LCBDYW52ZywgQ2lyY2xlRWxlbWVudCwgQ2xpcFBhdGhFbGVtZW50LCBEZWZzRWxlbWVudCwgRGVzY0VsZW1lbnQsIERvY3VtZW50LCBFbGVtZW50LCBFbGxpcHNlRWxlbWVudCwgRmVDb2xvck1hdHJpeEVsZW1lbnQsIEZlQ29tcG9zaXRlRWxlbWVudCwgRmVEcm9wU2hhZG93RWxlbWVudCwgRmVHYXVzc2lhbkJsdXJFbGVtZW50LCBGZU1vcnBob2xvZ3lFbGVtZW50LCBGaWx0ZXJFbGVtZW50LCBGb250LCBGb250RWxlbWVudCwgRm9udEZhY2VFbGVtZW50LCBHRWxlbWVudCwgR2x5cGhFbGVtZW50LCBHcmFkaWVudEVsZW1lbnQsIEltYWdlRWxlbWVudCwgTGluZUVsZW1lbnQsIExpbmVhckdyYWRpZW50RWxlbWVudCwgTWFya2VyRWxlbWVudCwgTWFza0VsZW1lbnQsIE1hdHJpeCwgTWlzc2luZ0dseXBoRWxlbWVudCwgTW91c2UsIFBTRVVET19aRVJPLCBQYXJzZXIsIFBhdGhFbGVtZW50LCBQYXRoUGFyc2VyLCBQYXR0ZXJuRWxlbWVudCwgUG9pbnQsIFBvbHlnb25FbGVtZW50LCBQb2x5bGluZUVsZW1lbnQsIFByb3BlcnR5LCBRQjEsIFFCMiwgUUIzLCBSYWRpYWxHcmFkaWVudEVsZW1lbnQsIFJlY3RFbGVtZW50LCBSZW5kZXJlZEVsZW1lbnQsIFJvdGF0ZSwgU1ZHRWxlbWVudCwgU1ZHRm9udExvYWRlciwgU2NhbGUsIFNjcmVlbiwgU2tldywgU2tld1gsIFNrZXdZLCBTdG9wRWxlbWVudCwgU3R5bGVFbGVtZW50LCBTeW1ib2xFbGVtZW50LCBUUmVmRWxlbWVudCwgVFNwYW5FbGVtZW50LCBUZXh0RWxlbWVudCwgVGV4dFBhdGhFbGVtZW50LCBUaXRsZUVsZW1lbnQsIFRyYW5zZm9ybSwgVHJhbnNsYXRlLCBVbmtub3duRWxlbWVudCwgVXNlRWxlbWVudCwgVmlld1BvcnQsIGNvbXByZXNzU3BhY2VzLCBDYW52ZyBhcyBkZWZhdWx0LCBnZXRTZWxlY3RvclNwZWNpZmljaXR5LCBub3JtYWxpemVBdHRyaWJ1dGVOYW1lLCBub3JtYWxpemVDb2xvciwgcGFyc2VFeHRlcm5hbFVybCwgaW5kZXggYXMgcHJlc2V0cywgdG9OdW1iZXJzLCB0cmltTGVmdCwgdHJpbVJpZ2h0LCB2ZWN0b3JNYWduaXR1ZGUsIHZlY3RvcnNBbmdsZSwgdmVjdG9yc1JhdGlvIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1WlhNdWFuTWlMQ0p6YjNWeVkyVnpJanBiWFN3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2x0ZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenNpZlE9PVxuIl0sIm5hbWVzIjpbIl9hc3luY1RvR2VuZXJhdG9yIiwiX2RlZmluZVByb3BlcnR5IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiUkdCQ29sb3IiLCJTVkdQYXRoRGF0YSIsImNhbnZhc1JHQkEiLCJvZmZzY3JlZW4iLCJET01QYXJzZXIiLCJET01QYXJzZXJGYWxsYmFjayIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInByZXNldCIsIndpbmRvdyIsImlnbm9yZUFuaW1hdGlvbiIsImlnbm9yZU1vdXNlIiwiY3JlYXRlQ2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJPZmZzY3JlZW5DYW52YXMiLCJjcmVhdGVJbWFnZSIsInVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJibG9iIiwiaW1nIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJSZWZsZWN0IiwiZGVsZXRlUHJvcGVydHkiLCJub2RlIiwiX3JlZiIsImNhbnZhcyIsImxvYWRJbWFnZSIsImluZGV4IiwiT2JqZWN0IiwiZnJlZXplIiwiX19wcm90b19fIiwiY29tcHJlc3NTcGFjZXMiLCJzdHIiLCJyZXBsYWNlIiwidHJpbUxlZnQiLCJ0cmltUmlnaHQiLCJ0b051bWJlcnMiLCJtYXRjaGVzIiwibWF0Y2giLCJtYXAiLCJwYXJzZUZsb2F0IiwiYWxsVXBwZXJjYXNlIiwibm9ybWFsaXplQXR0cmlidXRlTmFtZSIsIm5hbWUiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJwYXJzZUV4dGVybmFsVXJsIiwidXJsTWF0Y2giLCJleGVjIiwibm9ybWFsaXplQ29sb3IiLCJjb2xvciIsInN0YXJ0c1dpdGgiLCJyZ2JQYXJ0cyIsIm5vcm1hbGl6ZWRDb2xvciIsIm51bSIsImlzRmxvYXQiLCJTdHJpbmciLCJNYXRoIiwicm91bmQiLCJhdHRyaWJ1dGVSZWdleCIsImlkUmVnZXgiLCJjbGFzc1JlZ2V4IiwicHNldWRvRWxlbWVudFJlZ2V4IiwicHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCIsInBzZXVkb0NsYXNzUmVnZXgiLCJlbGVtZW50UmVnZXgiLCJmaW5kU2VsZWN0b3JNYXRjaCIsInNlbGVjdG9yIiwicmVnZXgiLCJnZXRTZWxlY3RvclNwZWNpZmljaXR5Iiwic3BlY2lmaWNpdHkiLCJjdXJyZW50U2VsZWN0b3IiLCJkZWx0YSIsImpvaW4iLCJQU0VVRE9fWkVSTyIsInZlY3Rvck1hZ25pdHVkZSIsInYiLCJzcXJ0IiwicG93IiwidmVjdG9yc1JhdGlvIiwidSIsInZlY3RvcnNBbmdsZSIsImFjb3MiLCJDQjEiLCJ0IiwiQ0IyIiwiQ0IzIiwiQ0I0IiwiUUIxIiwiUUIyIiwiUUIzIiwiUHJvcGVydHkiLCJjb25zdHJ1Y3RvciIsImRvY3VtZW50IiwidmFsdWUiLCJpc05vcm1hbGl6ZWRDb2xvciIsImVtcHR5Iiwic3BsaXQiLCJzZXBhcmF0b3IiLCJnZXRTdHJpbmciLCJ0cmltIiwiaGFzVmFsdWUiLCJ6ZXJvSXNWYWx1ZSIsImlzU3RyaW5nIiwicmVnZXhwIiwicmVzdWx0IiwiaXNVcmxEZWZpbml0aW9uIiwiaXNQaXhlbHMiLCJhc1N0cmluZyIsImVuZHNXaXRoIiwic2V0VmFsdWUiLCJnZXRWYWx1ZSIsImRlZiIsImdldE51bWJlciIsIm4iLCJnZXRDb2xvciIsImdldERwaSIsImdldFJlbSIsInJvb3RFbVNpemUiLCJnZXRFbSIsImVtU2l6ZSIsImdldFVuaXRzIiwiZ2V0UGl4ZWxzIiwiYXhpc09ySXNGb250U2l6ZSIsInByb2Nlc3NQZXJjZW50IiwiYXhpcyIsImlzRm9udFNpemUiLCJ2aWV3UG9ydCIsInNjcmVlbiIsIm1pbiIsImNvbXB1dGVTaXplIiwibWF4IiwiZ2V0TWlsbGlzZWNvbmRzIiwiZ2V0UmFkaWFucyIsIlBJIiwiZ2V0RGVmaW5pdGlvbiIsImRlZmluaXRpb25zIiwiZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbiIsImVsZW1lbnQiLCJvcGFjaXR5IiwiY3JlYXRlR3JhZGllbnQiLCJjdHgiLCJjcmVhdGVQYXR0ZXJuIiwiZ2V0SHJlZkF0dHJpYnV0ZSIsInBhdHRlcm5UcmFuc2Zvcm0iLCJnZXRBdHRyaWJ1dGUiLCJnZXRUZXh0QmFzZWxpbmUiLCJ0ZXh0QmFzZWxpbmVNYXBwaW5nIiwiYWRkT3BhY2l0eSIsImxlbiIsImNvbW1hcyIsImkiLCJvayIsImFscGhhIiwidG9SR0JBIiwiVmlld1BvcnQiLCJ2aWV3UG9ydHMiLCJjbGVhciIsInNldEN1cnJlbnQiLCJwdXNoIiwicmVtb3ZlQ3VycmVudCIsInBvcCIsImdldEN1cnJlbnQiLCJkIiwiUG9pbnQiLCJ4IiwieSIsInBhcnNlIiwicG9pbnQiLCJkZWZhdWx0VmFsdWUiLCJwYXJzZVNjYWxlIiwic2NhbGUiLCJwYXJzZVBhdGgiLCJwYXRoIiwicG9pbnRzIiwicGF0aFBvaW50cyIsImFuZ2xlVG8iLCJhdGFuMiIsImFwcGx5VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwieHAiLCJ5cCIsIk1vdXNlIiwid29ya2luZyIsImV2ZW50cyIsImV2ZW50RWxlbWVudHMiLCJvbkNsaWNrIiwiYmluZCIsIm9uTW91c2VNb3ZlIiwiaXNXb3JraW5nIiwic3RhcnQiLCJvbmNsaWNrIiwib25tb3VzZW1vdmUiLCJzdG9wIiwiaGFzRXZlbnRzIiwicnVuRXZlbnRzIiwic3R5bGUiLCJjdXJzb3IiLCJmb3JFYWNoIiwicnVuIiwicGFyZW50IiwiY2hlY2tQYXRoIiwiX3JlZjIiLCJpc1BvaW50SW5QYXRoIiwiY2hlY2tCb3VuZGluZ0JveCIsImJvdW5kaW5nQm94IiwiX3JlZjMiLCJpc1BvaW50SW5Cb3giLCJtYXBYWSIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJzY3JvbGxYIiwic2Nyb2xsWSIsImV2ZW50IiwiY2xpZW50WCIsImNsaWVudFkiLCJ0eXBlIiwiZXZlbnRUYXJnZXQiLCJkZWZhdWx0V2luZG93IiwiZGVmYXVsdEZldGNoJDEiLCJTY3JlZW4iLCJGUkFNRVJBVEUiLCJNQVhfVklSVFVBTF9QSVhFTFMiLCJDTElFTlRfV0lEVEgiLCJDTElFTlRfSEVJR0hUIiwibW91c2UiLCJhbmltYXRpb25zIiwid2FpdHMiLCJmcmFtZUR1cmF0aW9uIiwiaXNSZWFkeUxvY2siLCJpc0ZpcnN0UmVuZGVyIiwiaW50ZXJ2YWxJZCIsIndhaXQiLCJjaGVja2VyIiwicmVhZHkiLCJyZWFkeVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImlzUmVhZHkiLCJldmVyeSIsIl8iLCJyZXNvbHZlUmVhZHkiLCJzZXREZWZhdWx0cyIsInN0cm9rZVN0eWxlIiwibGluZUNhcCIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsInNldFZpZXdCb3giLCJhc3BlY3RSYXRpbyIsImRlc2lyZWRXaWR0aCIsImRlc2lyZWRIZWlnaHQiLCJtaW5YIiwibWluWSIsInJlZlgiLCJyZWZZIiwiY2xpcCIsImNsaXBYIiwiY2xpcFkiLCJjbGVhbkFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW9BbGlnbiIsImFzcGVjdFJhdGlvTWVldE9yU2xpY2UiLCJhbGlnbiIsIm1lZXRPclNsaWNlIiwic2NhbGVYIiwic2NhbGVZIiwic2NhbGVNaW4iLCJzY2FsZU1heCIsImZpbmFsRGVzaXJlZFdpZHRoIiwiZmluYWxEZXNpcmVkSGVpZ2h0IiwicmVmWFByb3AiLCJyZWZZUHJvcCIsImhhc1JlZnMiLCJ0cmFuc2xhdGUiLCJzY2FsZWRDbGlwWCIsInNjYWxlZENsaXBZIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwiaXNNZWV0TWluWSIsImlzU2xpY2VNYXhZIiwiaXNNZWV0TWluWCIsImlzU2xpY2VNYXhYIiwiZW5hYmxlUmVkcmF3IiwiaWdub3JlRGltZW5zaW9ucyIsImlnbm9yZUNsZWFyIiwiZm9yY2VSZWRyYXciLCJzY2FsZVdpZHRoIiwic2NhbGVIZWlnaHQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInJlbmRlciIsIm5vdyIsIkRhdGUiLCJ0aGVuIiwidGljayIsInNob3VsZFVwZGF0ZSIsImNhbmNlbCIsInJlZHVjZSIsImFuaW1hdGlvbiIsInVwZGF0ZSIsIndpZHRoU3R5bGUiLCJnZXRTdHlsZSIsImhlaWdodFN0eWxlIiwiY29uY2F0IiwiY1dpZHRoIiwiY2xpZW50V2lkdGgiLCJjSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwidmlld0JveCIsInhSYXRpbyIsInlSYXRpbyIsIl93aWR0aFN0eWxlIiwiaXNOYU4iLCJfaGVpZ2h0U3R5bGUiLCJ0cmFuc2Zvcm1TdHlsZSIsImNsZWFyUmVjdCIsImRlZmF1bHRGZXRjaCIsIkRlZmF1bHRET01QYXJzZXIiLCJQYXJzZXIiLCJyZXNvdXJjZSIsIl90aGlzIiwicGFyc2VGcm9tU3RyaW5nIiwibG9hZCIsInhtbCIsInBhcnNlciIsImNoZWNrRG9jdW1lbnQiLCJlcnIiLCJwYXJzZXJFcnJvciIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiRXJyb3IiLCJ0ZXh0Q29udGVudCIsIl90aGlzMiIsInRleHQiLCJUcmFuc2xhdGUiLCJhcHBseSIsInVuYXBwbHkiLCJhcHBseVRvUG9pbnQiLCJSb3RhdGUiLCJyb3RhdGUiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJhbmdsZSIsIm9yaWdpblgiLCJvcmlnaW5ZIiwiY3giLCJjeSIsIm51bWJlcnMiLCJ0eCIsInR5IiwicmFkIiwiY29zIiwic2luIiwiU2NhbGUiLCJzY2FsZVNpemUiLCJNYXRyaXgiLCJtYXRyaXgiLCJhIiwiYiIsImMiLCJlIiwiZiIsImciLCJoIiwiZGV0IiwiU2tldyIsInNrZXciLCJTa2V3WCIsInRhbiIsIlNrZXdZIiwicGFyc2VUcmFuc2Zvcm1zIiwicGFyc2VUcmFuc2Zvcm0iLCJUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1zIiwiZGF0YSIsIlRyYW5zZm9ybVR5cGUiLCJ0cmFuc2Zvcm1UeXBlcyIsImZyb21FbGVtZW50IiwidHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5IiwidHJhbnNmb3JtT3JpZ2luWVByb3BlcnR5Iiwic2tld1giLCJza2V3WSIsIkVsZW1lbnQiLCJjYXB0dXJlVGV4dE5vZGVzIiwiYXR0cmlidXRlcyIsImNyZWF0ZSIsInN0eWxlcyIsInN0eWxlc1NwZWNpZmljaXR5IiwiYW5pbWF0aW9uRnJvemVuIiwiYW5pbWF0aW9uRnJvemVuVmFsdWUiLCJjaGlsZHJlbiIsIm5vZGVUeXBlIiwiQXJyYXkiLCJmcm9tIiwiYXR0cmlidXRlIiwibm9kZU5hbWUiLCJhZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uIiwiaWQiLCJjaGlsZE5vZGVzIiwiY2hpbGROb2RlIiwiYWRkQ2hpbGQiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwiZ2V0VGV4dCIsImNyZWF0ZUlmTm90RXhpc3RzIiwiYXR0ciIsIl9hdHRyIiwia2V5Iiwic2tpcEFuY2VzdG9ycyIsInBhcmVudFN0eWxlIiwiX3N0eWxlIiwic2F2ZSIsIm1hc2siLCJhcHBseUVmZmVjdHMiLCJmaWx0ZXIiLCJzZXRDb250ZXh0IiwicmVuZGVyQ2hpbGRyZW4iLCJjbGVhckNvbnRleHQiLCJyZXN0b3JlIiwiY2xpcFBhdGhTdHlsZVByb3AiLCJjaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJpZ25vcmVDaGlsZFR5cGVzIiwiaW5jbHVkZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJfbm9kZSRnZXRBdHRyaWJ1dGUiLCJzdHlsZUNsYXNzZXMiLCJjYWxsIiwic29tZSIsInN0eWxlQ2xhc3MiLCJleGlzdGluZ1NwZWNpZmljaXR5IiwicmVtb3ZlU3R5bGVzIiwiaWdub3JlU3R5bGVzIiwidG9SZXN0b3JlIiwic3R5bGVQcm9wIiwicmVzdG9yZVN0eWxlcyIsImlzRmlyc3RDaGlsZCIsIl90aGlzJHBhcmVudCIsImluZGV4T2YiLCJVbmtub3duRWxlbWVudCIsIndyYXBGb250RmFtaWx5IiwiZm9udEZhbWlseSIsInRyaW1tZWQiLCJwcmVwYXJlRm9udEZhbWlseSIsInByb2Nlc3MiLCJwcmVwYXJlRm9udFN0eWxlIiwiZm9udFN0eWxlIiwidGFyZ2V0Rm9udFN0eWxlIiwicHJlcGFyZUZvbnRXZWlnaHQiLCJmb250V2VpZ2h0IiwidGFyZ2V0Rm9udFdlaWdodCIsIkZvbnQiLCJmb250VmFyaWFudCIsImZvbnRTaXplIiwiaW5oZXJpdCIsImluaGVyaXRGb250IiwiZm9udCIsInBhcnRzIiwic2V0IiwicGFydCIsInZhcmlhbnRzIiwid2VpZ2h0cyIsInRvU3RyaW5nIiwiQm91bmRpbmdCb3giLCJ4MSIsIk51bWJlciIsIk5hTiIsInkxIiwieDIiLCJ5MiIsImFkZFBvaW50IiwiYWRkWCIsImFkZFkiLCJhZGRCb3VuZGluZ0JveCIsInN1bUN1YmljIiwicDAiLCJwMSIsInAyIiwicDMiLCJiZXppZXJDdXJ2ZUFkZCIsImZvclgiLCJiMmFjIiwidDEiLCJ0MiIsImFkZEJlemllckN1cnZlIiwicDB4IiwicDB5IiwicDF4IiwicDF5IiwicDJ4IiwicDJ5IiwicDN4IiwicDN5IiwiYWRkUXVhZHJhdGljQ3VydmUiLCJjcDF4IiwiY3AxeSIsImNwMngiLCJjcDJ5IiwiUGF0aFBhcnNlciIsImNvbnRyb2wiLCJjdXJyZW50IiwiY29tbWFuZCIsImNvbW1hbmRzIiwicHJldmlvdXNDb21tYW5kIiwiYW5nbGVzIiwicmVzZXQiLCJpc0VuZCIsIm5leHQiLCJnZXRQb2ludCIsInhQcm9wIiwieVByb3AiLCJtYWtlQWJzb2x1dGUiLCJnZXRBc0NvbnRyb2xQb2ludCIsImdldEFzQ3VycmVudFBvaW50IiwiZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50IiwiQ1VSVkVfVE8iLCJTTU9PVEhfQ1VSVkVfVE8iLCJRVUFEX1RPIiwiU01PT1RIX1FVQURfVE8iLCJveCIsIm95IiwicmVsYXRpdmUiLCJhZGRNYXJrZXIiLCJwcmlvclRvIiwiYWRkTWFya2VyQW5nbGUiLCJnZXRNYXJrZXJQb2ludHMiLCJnZXRNYXJrZXJBbmdsZXMiLCJqIiwiUmVuZGVyZWRFbGVtZW50IiwibW9kaWZpZWRFbVNpemVTdGFjayIsImNhbGN1bGF0ZU9wYWNpdHkiLCJvcGFjaXR5U3R5bGUiLCJmcm9tTWVhc3VyZSIsImZpbGxTdHlsZVByb3AiLCJmaWxsT3BhY2l0eVN0eWxlUHJvcCIsInN0cm9rZVN0eWxlUHJvcCIsInN0cm9rZU9wYWNpdHlQcm9wIiwiZmlsbFN0eWxlIiwiX2ZpbGxTdHlsZSIsIl9maWxsU3R5bGUyIiwiX3N0cm9rZVN0eWxlIiwiX3N0cm9rZVN0eWxlMiIsInN0cm9rZVdpZHRoU3R5bGVQcm9wIiwibmV3TGluZVdpZHRoIiwibGluZVdpZHRoIiwic3Ryb2tlTGluZWNhcFN0eWxlUHJvcCIsInN0cm9rZUxpbmVqb2luU3R5bGVQcm9wIiwic3Ryb2tlTWl0ZXJsaW1pdFByb3AiLCJzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AiLCJzdHJva2VEYXNob2Zmc2V0UHJvcCIsImdhcHMiLCJzZXRMaW5lRGFzaCIsIndlYmtpdExpbmVEYXNoIiwibW96RGFzaCIsIm9mZnNldCIsImxpbmVEYXNoT2Zmc2V0Iiwid2Via2l0TGluZURhc2hPZmZzZXQiLCJtb3pEYXNoT2Zmc2V0IiwiZm9udFN0eWxlUHJvcCIsImZvbnRTdHlsZVN0eWxlUHJvcCIsImZvbnRWYXJpYW50U3R5bGVQcm9wIiwiZm9udFdlaWdodFN0eWxlUHJvcCIsImZvbnRTaXplU3R5bGVQcm9wIiwiZm9udEZhbWlseVN0eWxlUHJvcCIsImdsb2JhbEFscGhhIiwicG9wRW1TaXplIiwiUGF0aEVsZW1lbnQiLCJwYXRoUGFyc2VyIiwiTU9WRV9UTyIsInBhdGhNIiwiTElORV9UTyIsInBhdGhMIiwiSE9SSVpfTElORV9UTyIsInBhdGhIIiwiVkVSVF9MSU5FX1RPIiwicGF0aFYiLCJwYXRoQyIsInBhdGhTIiwicGF0aFEiLCJwYXRoVCIsIkFSQyIsInBhdGhBIiwiQ0xPU0VfUEFUSCIsInBhdGhaIiwiZ2V0Qm91bmRpbmdCb3giLCJnZXRNYXJrZXJzIiwibWFya2VycyIsImZpbGxSdWxlU3R5bGVQcm9wIiwiZmlsbCIsInNldFRyYW5zZm9ybSIsInN0cm9rZSIsIm1hcmtlcnNMYXN0SW5kZXgiLCJtYXJrZXJTdGFydFN0eWxlUHJvcCIsIm1hcmtlck1pZFN0eWxlUHJvcCIsIm1hcmtlckVuZFN0eWxlUHJvcCIsIm1hcmtlciIsIl9tYXJrZXIiLCJfcG9pbnQiLCJfYW5nbGUiLCJfbWFya2VyMiIsIl9wb2ludDIiLCJfYW5nbGUyIiwiY29udHJvbFBvaW50IiwiY3VycmVudFBvaW50IiwiYmV6aWVyQ3VydmVUbyIsInF1YWRyYXRpY0N1cnZlVG8iLCJyWCIsInJZIiwieFJvdCIsImxBcmNGbGFnIiwic3dlZXBGbGFnIiwieEF4aXNSb3RhdGlvbiIsImN1cnJwIiwibCIsInMiLCJjcHAiLCJjZW50cCIsImExIiwiYWQiLCJkaXIiLCJhaCIsImhhbGZXYXkiLCJyIiwic3giLCJzeSIsImFyYyIsIkJvb2xlYW4iLCJHbHlwaEVsZW1lbnQiLCJob3JpekFkdlgiLCJ1bmljb2RlIiwiYXJhYmljRm9ybSIsIlRleHRFbGVtZW50IiwibWVhc3VyZUNhY2hlIiwidGV4dEJhc2VsaW5lIiwiaW5pdGlhbGl6ZUNvb3JkaW5hdGVzIiwibGVhZlRleHRzIiwidGV4dENodW5rU3RhcnQiLCJQT1NJVElWRV9JTkZJTklUWSIsIm1heFgiLCJORUdBVElWRV9JTkZJTklUWSIsImdldFRFbGVtZW50Qm91bmRpbmdCb3giLCJhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlIiwiY2hpbGRCb3VuZGluZ0JveCIsImdldENoaWxkQm91bmRpbmdCb3giLCJnZXRGb250U2l6ZSIsImluaGVyaXRGb250U2l6ZSIsIm1lYXN1cmVUZXh0IiwiZ2V0R2x5cGgiLCJjaGFyIiwiZ2x5cGgiLCJpc0FyYWJpYyIsInByZXZDaGFyIiwibmV4dENoYXIiLCJnbHlwaHMiLCJtYXliZUdseXBoIiwibWlzc2luZ0dseXBoIiwiZ2V0VGV4dEZyb21Ob2RlIiwicGFyZW50Tm9kZSIsImxhc3RJbmRleCIsInJlbmRlclRFbGVtZW50Q2hpbGRyZW4iLCJyZW5kZXJDaGlsZCIsInJlbmRlclRleHQiLCJjdXN0b21Gb250IiwidW5pdHNQZXJFbSIsImZvbnRGYWNlIiwiY3R4Rm9udCIsImlzUlRMIiwicmV2ZXJzZSIsImR4IiwibHciLCJmaWxsVGV4dCIsInN0cm9rZVRleHQiLCJhcHBseUFuY2hvcmluZyIsImZpcnN0RWxlbWVudCIsInRleHRBbmNob3IiLCJzaGlmdCIsImFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlIiwidGV4dFBhcmVudCIsImFkanVzdENoaWxkQ29vcmRpbmF0ZXMiLCJ4QXR0ciIsInlBdHRyIiwiZHhBdHRyIiwiZHlBdHRyIiwiZ2V0SW5oZXJpdGVkQXR0cmlidXRlIiwibWVhc3VyZSIsIm1lYXN1cmVUYXJnZXRUZXh0IiwidGFyZ2V0VGV4dCIsIl9tZWFzdXJlIiwicGFyZW50QXR0ciIsIlRTcGFuRWxlbWVudCIsIlRleHROb2RlIiwiU1ZHRWxlbWVudCIsInJvb3QiLCJfdGhpcyRub2RlJHBhcmVudE5vZGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImZvbnRTaXplUHJvcCIsInJlZlhBdHRyIiwicmVmWUF0dHIiLCJ2aWV3Qm94QXR0ciIsInJlc2l6ZSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJ3aWR0aEF0dHIiLCJoZWlnaHRBdHRyIiwic3R5bGVBdHRyIiwib3JpZ2luV2lkdGgiLCJvcmlnaW5IZWlnaHQiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ciIsIlJlY3RFbGVtZW50IiwicnhBdHRyIiwicnlBdHRyIiwicngiLCJyeSIsIktBUFBBIiwiQ2lyY2xlRWxlbWVudCIsIkVsbGlwc2VFbGVtZW50IiwiTGluZUVsZW1lbnQiLCJnZXRQb2ludHMiLCJ4MCIsInkwIiwiUG9seWxpbmVFbGVtZW50IiwiUG9seWdvbkVsZW1lbnQiLCJQYXR0ZXJuRWxlbWVudCIsInBhcmVudE9wYWNpdHlQcm9wIiwicGF0dGVyblN2ZyIsInBhdHRlcm5DYW52YXMiLCJwYXR0ZXJuQ3R4IiwiZ2V0Q29udGV4dCIsInBhdHRlcm4iLCJNYXJrZXJFbGVtZW50Iiwib3JpZW50IiwibWFya2VyVW5pdHMiLCJtYXJrZXJTdmciLCJvdmVyZmxvdyIsIkRlZnNFbGVtZW50IiwiR0VsZW1lbnQiLCJHcmFkaWVudEVsZW1lbnQiLCJhdHRyaWJ1dGVzVG9Jbmhlcml0Iiwic3RvcHMiLCJnZXRHcmFkaWVudFVuaXRzIiwic3RvcHNDb250YWluZXIiLCJpbmhlcml0U3RvcENvbnRhaW5lciIsImdyYWRpZW50IiwiZ2V0R3JhZGllbnQiLCJhZGRQYXJlbnRPcGFjaXR5IiwiYWRkQ29sb3JTdG9wIiwicm9vdFZpZXciLCJyZWN0IiwiZ3JvdXAiLCJhdHRyaWJ1dGVUb0luaGVyaXQiLCJjb2xvclByb3AiLCJMaW5lYXJHcmFkaWVudEVsZW1lbnQiLCJpc0JvdW5kaW5nQm94VW5pdHMiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsIlJhZGlhbEdyYWRpZW50RWxlbWVudCIsImZ4IiwiZnkiLCJmciIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiU3RvcEVsZW1lbnQiLCJzdG9wT3BhY2l0eSIsInN0b3BDb2xvciIsIkFuaW1hdGVFbGVtZW50IiwiZHVyYXRpb24iLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsVW5pdHMiLCJyZW1vdmVkIiwiZnJvemVuIiwiYmVnaW4iLCJtYXhEdXJhdGlvbiIsInRvIiwidmFsdWVzIiwidmFsdWVzQXR0ciIsImdldFByb3BlcnR5IiwiYXR0cmlidXRlVHlwZSIsImF0dHJpYnV0ZU5hbWUiLCJjYWxjVmFsdWUiLCJwcm9ncmVzcyIsImdldFByb2dyZXNzIiwibmV3VmFsdWUiLCJwcm9wIiwidXBkYXRlZCIsInR5cGVBdHRyIiwicCIsImxiIiwiZmxvb3IiLCJ1YiIsImNlaWwiLCJBbmltYXRlQ29sb3JFbGVtZW50IiwiY29sb3JGcm9tIiwiY29sb3JUbyIsIkFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50IiwidHJhbnNmb3JtRnJvbSIsInRyYW5zZm9ybVRvIiwiRm9udEVsZW1lbnQiLCJmb250RmFtaWx5U3R5bGUiLCJGb250RmFjZUVsZW1lbnQiLCJhc2NlbnQiLCJkZXNjZW50IiwiTWlzc2luZ0dseXBoRWxlbWVudCIsIlRSZWZFbGVtZW50IiwiZmlyc3RDaGlsZCIsIkFFbGVtZW50IiwiaGFzVGV4dCIsIm9wZW4iLCJvd25LZXlzJDIiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsIl9vYmplY3RTcHJlYWQkMiIsInRhcmdldCIsInNvdXJjZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJUZXh0UGF0aEVsZW1lbnQiLCJ0ZXh0V2lkdGgiLCJ0ZXh0SGVpZ2h0IiwicGF0aExlbmd0aCIsImdseXBoSW5mbyIsImxldHRlclNwYWNpbmdDYWNoZSIsIm1lYXN1cmVzQ2FjaGUiLCJNYXAiLCJwYXRoRWxlbWVudCIsImRhdGFBcnJheSIsInBhcnNlUGF0aERhdGEiLCJ0aGV0YSIsImRUaGV0YSIsInBzaSIsImZzIiwic2V0VGV4dERhdGEiLCJ0ZXh0RGVjb3JhdGlvbiIsInJvdGF0aW9uIiwicGFydGlhbFRleHQiLCJnZXRMZXR0ZXJTcGFjaW5nQXQiLCJpZHgiLCJmaW5kU2VnbWVudFRvRml0Q2hhciIsImFuY2hvciIsInRleHRGdWxsV2lkdGgiLCJmdWxsUGF0aFdpZHRoIiwic3BhY2VzTnVtYmVyIiwiaW5wdXRPZmZzZXQiLCJkeSIsImNoYXJJIiwiZ2x5cGhXaWR0aCIsInNwbGluZVN0ZXAiLCJnZXRFcXVpZGlzdGFudFBvaW50T25QYXRoIiwic2VnbWVudCIsImR5WCIsImR5WSIsImhhcyIsImdldCIsImNoYXJzIiwidGhpc1NwYWNpbmciLCJwYXJlbnRTcGFjaW5nIiwibGV0dGVyU3BhY2luZyIsInRleHRMZW4iLCJkeFN1bSIsImFjYyIsImN1ciIsImdldFBhdGhMZW5ndGgiLCJzdGFydE9mZnNldCIsIm5leHRPZmZzZXQiLCJwYXRoQ29tbWFuZHMiLCJzdGFydFgiLCJzdGFydFkiLCJuZXh0Q29tbWFuZFR5cGUiLCJjYWxjTGVuZ3RoIiwiY29tbWFuZFR5cGUiLCJnZXRMaW5lTGVuZ3RoIiwiZ2V0UG9pbnRPbkN1YmljQmV6aWVyIiwiZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllciIsImVuZCIsImluYyIsImFicyIsImdldFBvaW50T25FbGxpcHRpY2FsQXJjIiwiZ2V0UG9pbnRPbkxpbmUiLCJkaXN0IiwiZnJvbVgiLCJmcm9tWSIsIm0iLCJyaXNlIiwicHQiLCJpeCIsIml5IiwicFJpc2UiLCJwUnVuIiwiZ2V0UG9pbnRPblBhdGgiLCJkaXN0YW5jZSIsImZ1bGxMZW4iLCJjdW11bGF0aXZlUGF0aExlbmd0aCIsImN1cnJlbnRUIiwicGN0IiwicDR4IiwicDR5IiwiY29zUHNpIiwic2luUHNpIiwiYnVpbGRFcXVpZGlzdGFudENhY2hlIiwiaW5wdXRTdGVwIiwiaW5wdXRQcmVjaXNpb24iLCJwcmVjaXNpb24iLCJzdGVwIiwiZXF1aWRpc3RhbnRDYWNoZSIsInRhcmdldERpc3RhbmNlIiwiZGF0YVVyaVJlZ2V4IiwiSW1hZ2VFbGVtZW50IiwibG9hZGVkIiwiaHJlZiIsImlzU3ZnIiwiaW1hZ2VzIiwibG9hZFN2ZyIsImltYWdlIiwiY29uc29sZSIsImVycm9yIiwiYXRvYiIsImRlY29kZVVSSUNvbXBvbmVudCIsInN2ZyIsInN1YkRvY3VtZW50IiwiY2FudmciLCJmb3JrU3RyaW5nIiwiZG9jdW1lbnRFbGVtZW50IiwiX2ltYWdlIiwiY29tcGxldGUiLCJkcmF3SW1hZ2UiLCJTeW1ib2xFbGVtZW50IiwiU1ZHRm9udExvYWRlciIsImZvbnRzIiwic3ZnRG9jdW1lbnQiLCJmb250Tm9kZSIsIlN0eWxlRWxlbWVudCIsImNzcyIsImNzc0RlZnMiLCJjc3NQYXJ0cyIsImNzc0NsYXNzZXMiLCJjc3NQcm9wcyIsImNzc0NsYXNzIiwicHJvcHMiLCJjc3NQcm9wIiwic3Vic3RyIiwic3JjcyIsInNyYyIsIlVzZUVsZW1lbnQiLCJ0ZW1wU3ZnIiwib2xkUGFyZW50IiwiZWxlbWVudFRyYW5zZm9ybSIsImNhY2hlZEVsZW1lbnQiLCJpbUdldCIsIl9oZWlnaHQiLCJyZ2JhIiwiaW1TZXQiLCJ2YWwiLCJtaSIsIm0xIiwibTIiLCJtMyIsIkZlQ29sb3JNYXRyaXhFbGVtZW50IiwiaW5jbHVkZU9wYWNpdHkiLCJfeCIsIl95Iiwic3JjRGF0YSIsImdldEltYWdlRGF0YSIsIm5yIiwibmciLCJuYiIsIm5hIiwicHV0SW1hZ2VEYXRhIiwiTWFza0VsZW1lbnQiLCJpZ25vcmVkU3R5bGVzIiwibWFza0NhbnZhcyIsIm1hc2tDdHgiLCJ0bXBDYW52YXMiLCJ0bXBDdHgiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJmaWxsUmVjdCIsIm5vb3AiLCJDbGlwUGF0aEVsZW1lbnQiLCJjb250ZXh0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIkZpbHRlckVsZW1lbnQiLCJweCIsInB5IiwiZWZkIiwiZXh0cmFGaWx0ZXJEaXN0YW5jZSIsInRtcENhbnZhc1dpZHRoIiwidG1wQ2FudmFzSGVpZ2h0IiwiRmVEcm9wU2hhZG93RWxlbWVudCIsIl93aWR0aCIsIkZlTW9ycGhvbG9neUVsZW1lbnQiLCJGZUNvbXBvc2l0ZUVsZW1lbnQiLCJGZUdhdXNzaWFuQmx1ckVsZW1lbnQiLCJibHVyUmFkaXVzIiwiYm9keSIsImdldFVuaXF1ZUlkIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJUaXRsZUVsZW1lbnQiLCJEZXNjRWxlbWVudCIsImVsZW1lbnRzIiwib3duS2V5cyQxIiwiX29iamVjdFNwcmVhZCQxIiwiX2NyZWF0ZUltYWdlIiwiYW5vbnltb3VzQ3Jvc3NPcmlnaW4iLCJjcm9zc09yaWdpbiIsInJlamVjdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJfZXZlbnQiLCJfc291cmNlIiwiX2xpbmVubyIsIl9jb2xubyIsIkRvY3VtZW50IiwiZW1TaXplU3RhY2siLCJ1bmlxdWVJZCIsImJpbmRDcmVhdGVJbWFnZSIsImlzSW1hZ2VzTG9hZGVkIiwiaXNGb250c0xvYWRlZCIsImZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4iLCJjcmVhdGVEb2N1bWVudEVsZW1lbnQiLCJlbGVtZW50VHlwZSIsIkVsZW1lbnRUeXBlIiwiZWxlbWVudFR5cGVzIiwiY29uZmlnIiwib3duS2V5cyIsIl9vYmplY3RTcHJlYWQiLCJDYW52ZyIsIm9wdGlvbnMiLCJfYXJndW1lbnRzIiwiZnJvbVN0cmluZyIsImZvcmsiLCJfYXJndW1lbnRzMiIsImJhc2VPcHRpb25zIiwiZGVmYXVsdCIsInByZXNldHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvg/lib/index.es.js\n");

/***/ })

};
;